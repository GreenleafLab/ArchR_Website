[["index.html", "ArchR: Robust and scaleable analysis of single-cell chromatin accessibility data. ", " ArchR: Robust and scaleable analysis of single-cell chromatin accessibility data. Jeffrey Granja and Ryan Corces 2025-02-06 ArchR is a full-featured software suite for the analysis of single-cell chromatin accessibility data. It is designed to handle hundreds of thousands of single cells without large memory or computational requirements, keeping pace with the experimental scale that is achievable with commercial platforms such as the 10x Genomics Chromium system. This website is a complete user’s guide to ArchR. We explain how to use ArchR by walking through examples of every analysis we could think of. We also include some more extensive documention on some of the more salient points of scATAC-seq analysis such as dimensionality reduction and clustering. All of the chapters will utilize the same downsampled dataset of hematopoietic cells Granja* et al. Nature Biotechnology 2019. Each chapter will build on the previous so you should ideally start from the beginning and perform all analyses in sequence. Importantly, these tutorials assume that you are running ArchR locally. This walkthrough assumes that you have already successfully installed ArchR and all dependencies. If that is not the case, please visit the home page for installation instructions. Cant find what you are looking for? There is a search feature that can be enabled using the magnifying glass in the navigation bar above which will help you find whatever it is you are looking for. If you dont find it in this book, or if you think the documentation on this website or in the function annotations is unclear, please post to our GitHub Discussions forum with the Q&amp;A form and we will do our best to clarify. If none of these options help, send us an email and we will do our best to respond in a timely fashion. 0.0.1 Documentation corresponding to previous ArchR releases Below you will find links to snapshots of this manual for previous ArchR releases. Feel free to use these for reference if you are forced to use an older version of ArchR for whatever reason. Snapshots for this manual began with release 1.0.2. 1.0.2 "],["debugging-and-troubleshooting-in-archr.html", "Chapter 1 Debugging and Troubleshooting in ArchR", " Chapter 1 Debugging and Troubleshooting in ArchR This chapter details steps to debug or troubleshoot common problems. Please read this fully before posting to GitHub or requesting help in any other forum. 1.0.1 Package dependencies ArchR has a lot of dependencies. On top of that, ArchR’s dependencies have dependencies. These dependencies are used to deliver the feature-rich end-user experience that we find so important but they also can cause problems. When one package changes something, it can have complicated downstream effects on ArchR. Because of this, we now provide a complete R package environment to use with each stable distribution of ArchR. Each package environment specifies the exact package version for each dependency and is run with a specific version of R to provide a uniform and stable end-user experience. See the chapter on renv for how to set up and use this provided environment. If you do not use the provided environment, we may not provide support for addressing your issues. Help us help you by using this standardized set of dependencies with renv. Not only is this helpful for us, it is also good coding practice to maximize reproducibility and stability of code. 1.0.2 Debugging steps First and foremost, you should read this entire manual and perform all of the different steps on the tutorial data. If you get errors on the master branch with the tutorial data using the tutorial code, then there is likely something wrong with your computational environment. Such environment specific issues are extremely challenging for us to address and will require substantial effort on your part. The tutorial has been run by hundreds of individuals on a wide array of computational set ups and it is very stable. Common issues that users run into are related to parallelization and HDF5 file access (for ArrowFiles). To ensure that these are not a problem for you, try running without parallelization (threads = 1 and addArchRLocking(locking = TRUE) where applicable). If you are running in RStudio, note that console output messages from parallel processes will likely not display correctly and this is expected. Similarly, some users have reported issues with parallelization in jupyter notebooks and it seems that these are related to settings on the end-user side. Make sure to carefully read all of the parameter definitions which can either be found through your R console or at the function definition page of our website. Pay special attention to situations where an ellipsis (...) is included as a function parameter. This indicates that additional arguments can be passed to the given function and will often be passed through to other function calls downstream. For example, in addClusters(), the ellipsis indicates that any additional parameters supplied to the addClusters() function will be passed through to Seurat::FindClusters() or scran::buildSNNGraph() depending on which is used. More information on this “three dots” / ellipsis construction here. 1.0.3 Testing ArchR via testthat As of release_1.0.3 ArchR comes with the ability to quickly test the majority of functionalities via the testthat package. In addition to running through the code provided in this entire manual, it is a good idea to run the full suite of functionality tests as described in the chapter on testing. 1.0.4 Posting to GitHub for help ArchR is now quite mature and it is rare that true bugs are uncovered. Most remaining issues relate to the handling of outlier cases such as those present in non-standard genomes or new features that have been recently implemented and are inherently less stable. If you are getting an error, first thoroughly search the issues and discussions forums to make sure it has not already been answered. To keep things organized, errors and bugs should be posted to issues while usage questions and feature requests should be posted to discussions. When posting an error report or question, please keep in mind that this is free academic software maintained by scientists who have many other commitments. For errors/bugs, please follow the provided issue template. This ensures that you include all of the information that we need. Always include the log file that ArchR generates, and where relevant include the output of traceback() to help us understand where the error is coming from. Never copy and paste screenshots of your R console to show us the error! Instead, use Markdown code block syntax (three backticks in a row) and copy and paste the actual text. This makes it so the text is searchable in the future for users who may encounter the same error. 1.0.5 Re-installing or upgrading ArchR Our convention is to have this package accessible in three different ways: The master branch which will always hold the most recently released stable version of ArchR. Stable numerically tagged releases that provide persistent snapshots of previous stable releases. A “development” version on a branch called dev that holds all updates since the last stable release. When bugs are found or feature requests are added, they will be committed into the dev branch and eventually merged into master to create a stable release. If you create a pull request, make sure that it uses dev as the base branch. To re-install or upgrade ArchR, you need to ensure that the old version of ArchR, if currently loaded, is unloaded and reattached, forcing your current R session to begin using the changed ArchR codebase. This is most effectively accomplished using the below code. In this example, the branch we are installing is called “dev” but you can install any branch or even any specific commit SHA by passing it to the ref parameter. #install your desired branch devtools::install_github(&quot;GreenleafLab/ArchR&quot;, ref=&quot;dev&quot;, repos = BiocManager::repositories(), upgrade = &quot;never&quot;) #unload the previously installed version of ArchR detach(&quot;package:ArchR&quot;, unload=TRUE) #load the newly installed version of ArchR library(ArchR) "],["manage-archrs-dependencies.html", "Chapter 2 Manage ArchR’s Dependencies", " Chapter 2 Manage ArchR’s Dependencies We recommend installing ArchR using renv, a tool for dependency management that will make it easier for you to get going with analysis without having to worry about package installation and versions issues. For each stable release of ArchR, we provide an renv environment that specifies exactly which versions of each ArchR dependency have been tested to work with the ArchR codebase. We find this solution to be quite flexible and this is the only approved way to interact with ArchR. If you run into an issue and you are not using the approved renv environment, we will not be able to help you troubleshoot. Please take the time to familiarize yourself with how renv works by reading this chapter. "],["using-renv-to-manage-dependencies.html", "2.1 Using renv to manage dependencies", " 2.1 Using renv to manage dependencies Before you are ready to use renv, you must ensure that you are working on the same R version that we used for the provided renv environment. The R version used for the current master branch is: as.character(R.version[&quot;version.string&quot;]) ## [1] &quot;R version 4.4.1 (2024-06-14)&quot; The basis of an renv environment is called a lock file. With this file, you will be able to quickly establish an environment that mimics the precise package versions that we know work with ArchR. The renv environment does not control for other aspects of your environment. If you are used to working with virtual environments in Python, it is important to note that renv environments are not the same. For renv, an environment is meant to be specific to a single project or dataset. Each project that you are working on is meant to be stored in its own directory and each of those directories/projects would have its own renv environment that you load specifically when working on that project. One of the best parts of renv is that it effectively creates a cache of many different versions of the various packages you have used, making it very easy to switch between different projects very easily without having to constantly install new packages. First, lets make sure that the renv package is installed and loaded. install.packages(&quot;renv&quot;) library(renv) Then, lets create a directory for the start of this tutorial and set it as our working directory. dir.create(path = &quot;./ArchRTutorial&quot;, showWarnings = FALSE) setwd(&quot;./ArchRTutorial&quot;) Then, lets download the lock file for the current master branch of ArchR. download.file(url = &quot;https://pub-9ae435458ecc412abbbc9420a502ec38.r2.dev/renv.lock&quot;, destfile = &quot;./renv.lock&quot;) Now, we can initiate our renv project environment. If you’ve never installed ArchR before, this should take care of installing all of the dependencies. Because of that, it may take quite some time to complete so go get a coffee if thats the case. When you run the below renv::init() command, it will ask you how you want to load the project and you should select the option that says to initialize the environment from the provided lock file. #output of this has been hidden for display purposes renv::init() After running renv::init(), you’ll notice that renv created some new files in your working directory. These files correspond to the particular environment that has just been set up. As mentioned before, renv environments are project specific and the renv environment here is only meant to be used for the analysis that will be done within this ./ArchRTutorial directory. You’ll notice that within the subdirectories is essentially an entire R library but this is established through symbolic linking to your central R library (or to an renv cache if you’ve set that up). If all went well, ArchR and all of its dependencies should be availble to you and you can go ahead and load ArchR. library(ArchR) ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## ## ArchR : Version 1.0.3 ## For more information see our website : www.ArchRProject.com ## If you encounter a bug please report : https://github.com/GreenleafLab/ArchR/issues ## Loading Required Packages... ## Loading Package : devtools v2.4.5 ## Loading Package : grid v4.4.1 ## Loading Package : gridExtra v2.3 ## Loading Package : gtools v3.9.5 ## Loading Package : gtable v0.3.6 ## Loading Package : ggplot2 v3.5.1 ## Loading Package : magrittr v2.0.3 ## Loading Package : plyr v1.8.9 ## Loading Package : stringr v1.5.1 ## Loading Package : data.table v1.16.2 ## Loading Package : matrixStats v1.4.1 ## Loading Package : sparseMatrixStats v1.16.0 ## Loading Package : S4Vectors v0.42.1 ## Loading Package : GenomicRanges v1.56.2 ## Loading Package : BiocGenerics v0.50.0 ## Loading Package : Matrix v1.7.1 ## Loading Package : Rcpp v1.0.13 ## Loading Package : RcppArmadillo v14.0.2.1 ## Loading Package : SummarizedExperiment v1.34.0 ## Warning: replacing previous import &#39;S4Arrays::makeNindexFromArrayViewport&#39; by ## &#39;DelayedArray::makeNindexFromArrayViewport&#39; when loading &#39;SummarizedExperiment&#39; ## Loading Package : rhdf5 v2.48.0 ## Setting default number of Parallel threads to 12. 2.1.1 Managing your renv environment Full documentation on renv can be found here and we encourage you to read the renv documentation for more advanced usage. Below, we outline a few things that will make working with renv easier for you. 2.1.1.1 Installing new packages or upgrading existing packages While we, of course, want you to use the approved renv environment, you may find that this environment lacks certain packages or there is an updated version of a package that you would like to use. For example, if there are new ArchR features or bug fixes that have been incorporated into the dev (development) branch on GitHub but have not been incorporated into a stable release, you might want to upgrade your ArchR installation within your renv environment. To do this, we would specify the dev branch as the desired ref in devtools::install_github(). Importantly, any time you install a new package, R will give you the option of upgrading existing packages that have newer versions. While using renv, you should always select “none” (option 3) to avoid unintentionally altering packages that are part of the expected renv environment. The whole point of the renv environment is to keep ArchR’s dependencies as stable as possible so you should upgrade with caution. Before upgrading, check the currently installed ArchR version. packageVersion(&quot;ArchR&quot;) ## [1] &#39;1.0.3&#39; Then run devtools::install_github(). Note that this command and those that follow in this section are not meant to be run in the context of the tutorial. They are only here for reference. The tutorial is run using the master branch, not the dev branch. devtools::install_github(&quot;GreenleafLab/ArchR&quot;, ref=&quot;dev&quot;, repos = BiocManager::repositories(), upgrade = &quot;never&quot;) After installing, we need to make sure to detach the old version of ArchR and reload the newly installed version. detach(&quot;package:ArchR&quot;, unload=TRUE) library(ArchR) After we do this, we could use the packageVersion() command above to see that the version of ArchR has changed. This updated package version is stored within your renv environment. If you were to use renv::deactivate() to deactivate your current renv environment, work on a different project, and then come back to this renv environment using renv::activate(), renv would remember the version of ArchR you were using when you last worked on this project. It will do this for any packages you install. One note of caution with switching between renv environments when using RStudio - because of how renv environments are set up, they also remember which files you had open and any unsaved changes. However, if you are not careful and you tell RStudio not to save your environment during the renv::deactivate() process, you could lose unsaved information. "],["other-environment-managers.html", "2.2 Other environment managers", " 2.2 Other environment managers We strongly encourage the use of renv as it allows you to precisely manage package versions. Package dependency issues are always cropping up and we can only guarantee that ArchR works given the precise R version and renv environment provided with each release. Though we do not provide support for this, some users prefer to use Conda and you can find an example ArchR user-generated recipe here. "],["using-docker-for-pre-compiled-environment-setup.html", "2.3 Using Docker for pre-compiled environment setup", " 2.3 Using Docker for pre-compiled environment setup Some users may choose to use pre-compiled containers to run ArchR instead. Containers allow for the creation of pre-compiled environments that already have all of the necessary dependencies pre-installed. This is a great option for users who may not have the time or resources to set up their own environment. We also provide Docker images, built off of rocker/rstudio, that already have ArchR and all dependencies pre-loaded. The latest version can be found at: greenleaflab/archr:latest and other versions, including images built with differing R versions, can be found at: https://hub.docker.com/r/greenleaflab/archr/tags To utilize these images, the user can first install Docker as mentioned in their documentation Following, create a container using the following command: docker image pull immanuelazn/archr:latest docker run -it --rm -v &lt;your_workspace&gt;:/workspace -p &lt;your_port_of_interest&gt;:8787 This will spin up a container that has Rstudio turned on by default. Rstudio can be accessed through: localhost:&lt;your_port_of_interest&gt; If you would like an interactive bash console instead, the following command can instead be called: docker run -it --rm -v &lt;your_workspace&gt;:/workspace -p &lt;your_port_of_interest&gt;:8787 bash "],["getting-started-with-archr.html", "Chapter 3 Getting Started with ArchR", " Chapter 3 Getting Started with ArchR This chapter will introduce you to how to import data into ArchR and how to create ArrowFiles, the base unit of ArchR analysis. "],["a-brief-primer-on-atac-seq-terminology.html", "3.1 A Brief Primer on ATAC-seq Terminology", " 3.1 A Brief Primer on ATAC-seq Terminology The most fundamental component of any ATAC-seq experiment is a “fragment”. In ATAC-seq, a fragment refers to a sequenceable DNA molecule created by two transposition events. Each end of that fragment is sequenced using paired-end sequencing. The inferred single-base position of the start and end of the fragment is adjusted based on the insertion offset of Tn5. As reported previously, Tn5 transposase binds to DNA as a homodimer with 9-bp of DNA between the two Tn5 molecules. Because of this, each Tn5 homodimer binding event creates two insertions, separated by 9 bp. Thus, the actual central point of the “accessible” site is in the very center of the Tn5 dimer, not the location of each Tn5 insertion. To account for this, we apply an offset to the individual Tn5 insertions, adjusting plus-stranded insertion events by +4 bp and minus-stranded insertion events by -5 bp. This is consistent with the convention put forth during the original description of ATAC-seq. Thus, in ArchR, “fragments” refers to a table or genomic ranges object containing the chromosome, offset-adjusted single-base chromosome start position, offset-adjusted single-base chromosome end position, and unique cellular barcode ID corresponding to each sequenced fragment. Similarly, “insertions” refer to the offset-adjusted single-base position at the very center of an accessible site. "],["why-use-archr.html", "3.2 Why use ArchR?", " 3.2 Why use ArchR? There are multiple tools for single-cell ATAC-seq analysis out there so why should you use ArchR? At the time of publication, ArchR provided features and enabled analyses that other tools did not. Since publication, other tools have released similar functionalities. Nevertheless, we believe ArchR to be the most full-featured and user-friendly analysis pacakge for scATAC-seq and multi-omic data and we aim to continue to develop ArchR to maintain that. In addition to offering a comprehensive set of analytical tools, ArchR is also faster and uses less memory than other available tools due to heavy optimization of the data structures and parallelization methods that form the basis of the ArchR software. When analyzing more than 70,000 cells, some tools require high-performance computing environments, exceeding 128 GB of available memory (OoM = out of memory). The below benchmarking plots are certainly out of date and represent our comparison at the time of publication but the general message remains the same - ArchR scales very well to large numbers of cells. ArchR is designed to be used on a Unix-based laptop. For experiments of moderate size (fewer than 100,000 cells), ArchR is fast enough to perform ad hoc analysis and visualize results in real time, making it possible to interact with the data in a more in-depth and biologically meaningful way. Of course, for higher cell numbers or for users that prefer server-based analysis, ArchR provides fascile export of plots and projects that can be downloaded and used after generation on a server. Currently, ArchR is not supported to run on Windows. "],["what-is-an-arrow-file-archrproject.html", "3.3 What is an Arrow file / ArchRProject?", " 3.3 What is an Arrow file / ArchRProject? The base unit of an analytical project in ArchR is called an Arrow file. Each Arrow file stores all of the data associated with an individual sample (i.e. metadata, accessible fragments, and data matrices). Here, an “individual sample” would be the most detailed unit of analysis desired (for ex. a single replicate of a particular condition). During creation and as additional analyses are performed, ArchR updates and edits each Arrow file to contain additional layers of information. It is worth noting that, to ArchR, an Arrow file is actually just a path to an external file stored on disk. More explicitly, an Arrow file is not an R-language object that is stored in memory but rather an HDF5-format file stored on disk. Because of this, we use an ArchRProject object to associate these Arrow files together into a single analytical framework that can be rapidly accessed in R. This ArchRProject object is small in size and is stored in memory. Certain actions can be taken directly on Arrow files while other actions are taken on an ArchRProject which in turn updates each associated Arrow file. Because Arrow files are stored as large HDF5-format files, “get-er” functions in ArchR retrieve data by interacting with the ArchRProject while “add-er” functions either (i) add data directly to Arrow files, (ii) add data directly to an ArchRProject, or (iii) add data to Arrow files by interacting with an ArchRProject. Many of ArchR’s analytical steps can be performed using parallel processing to minimize run-time. This is made possible by the unique data storage employed in Arrow files. Specifically, ATAC-seq fragments are stored per-chromosome and accessed in a chunk-wise fashion. "],["input-file-types-in-archr.html", "3.4 Input File Types in ArchR", " 3.4 Input File Types in ArchR ArchR can utilize multiple input formats of scATAC-seq data which is most frequently in the format of fragment files and BAM files. Fragment files are tabix-sorted text files containing each scATAC-seq fragment and the corresponding cell ID, one fragment per line. BAM files are binarized tabix-sorted files that contain each scATAC-seq fragment, raw sequence, cellular barcode id and other information. The input format used will depend on the pre-processing pipeline used. For example, the 10x Genomics Cell Ranger software returns fragment files while sci-ATAC-seq applications would use BAM files. ArchR uses scanTabix to read fragment files and scanBam to read BAM files. During this input process, inputs are chunked and each input chunk is converted into a compressed table-based representation of fragments containing each fragment chromosome, offset-adjusted chromosome start position, offset-adjusted chromosome end position, and cellular barcode ID. These chunk-wise fragments are then stored in a temporary HDF5-formatted file to preserve memory usage while maintaining rapid access to each chunk. Finally, all chunks associated with each chromosome are read, organized, and re-written to an Arrow file within a single HDF5 group called “fragments”. This pre-chunking procedure enables ArchR to process extremely large input files efficiently and with low memory usage, enabling full utilization of parallel processing. "],["getting-set-up.html", "3.5 Getting Set Up", " 3.5 Getting Set Up The first thing we do is change to our desired our working directory, set the number of threads we would like to use, and load our gene and genome annotations. Depending on the configuration of your local environment, you may need to modify the number of threads used below in addArchRThreads(). By default ArchR uses half of the total number of threads available but you can adjust this manually as you see fit. As a reminder, ArchR is not supported on Windows. For the purposes of this tutorial, we are assuming that you followed the instructions in the chapter on handling ArchR’s dependencies using renv and that you have set up a working directory for running this tutorial. First, we load the ArchR library. If this fails, you have not properly installed ArchR and should revisit the installation instructions. We will also set our seed for randomized opperations for consistency. You can set your seed to whatever you would like (here we use 1), but we encourage you to be consistent and always set the same seed. library(ArchR) set.seed(1) Next, we either enable or disable file locking for HDF5 files. File locking allows for processes to take advantage of subthreading but may not work on certain network-based file systems, such as network-based lustre file systems, that are often present on high-performance computing clusters. This has caused a lot of problems for specific users, in the past (perhaps best summarized here). Thus, it is extremely important to consistently enable or disable file locking based on your particular computational environment. Enabling file locking will prevent subthreading, disabling file locking will permit it. Regardless, whatever you chose for file locking is controlled by environment variables and only persists during the current R session so you should include a call to addArchRFileLocking() in the beginning of each new R session (just like set.seed() or addArchRThreads() etc.). The filesystem used to generate this tutorial works best with locking = TRUE so that is what we set below but you should use whatever you think is best for your system. If you have trouble with Arrow File generation on the tutorial data or with various HDF5 file accessibility errors, try setting locking = TRUE at the beginning of your project (before Arrow File generation). addArchRLocking(locking = TRUE) ## Setting ArchRLocking to TRUE. Next, we set the default number of threads for ArchR functions. This is something you will have to do during each new R session. We recommend setting threads to 1/2 to 3/4 of the total available cores. The memory usage in ArchR will often scale with the number of threads used so allowing ArchR to use more threads will also lead to higher memory usage. addArchRThreads(threads = 1) ## Setting default number of Parallel threads to 1. Then, we set the genome to be used for gene and genome annotations. As above, this is something you will have to do during each new R session. Of course, this genome version must match the genome version that was used for alignment. For the data used in this tutorial, we will use the hg19 reference genome but ArchR natively supports additional genome annotations and custome genome annotations as outlined in the next section. addArchRGenome(&quot;hg19&quot;) ## Setting default genome to Hg19. ArchR requires gene and genome annotations to do things such as calculate TSS enrichment scores, nucleotide content, and gene activity scores. Because our tutorial dataset uses scATAC-seq data that has already been aligned to the hg19 reference genome, we have set “hg19” as the default genome in the previous section. However, ArchR supports “hg19”, “hg38”, “mm9”, and “mm10” natively and you can create your own genome and gene annotations using the createGeneAnnotation() and createGenomeAnnotation() functions. Providing this information to ArchR is streamlined through the addArchRGenome() function. This function tells ArchR that, for all analyses in the current session, it should use the genomeAnnotation and geneAnnotation associated with the defined ArchRGenome. Each of the natively supported genomes are composed of a BSgenome object that defines the genomic coordinates and sequence of each chromosome, a GRanges object containing a set of blacklisted regions, a TxDb object that defines the positions and structures of all genes, and an OrgDb object that provides a central gene identifier and contains mappings between this identifier and other kinds of identifiers. Below are examples of how to load gene and genome annotations for the natively supported genomes as well as information on their BSgenome and blacklist components. The precompiled version of the hg19 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg19, TxDb.Hsapiens.UCSC.hg19.knownGene, org.Hs.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the hg19 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg19 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg19 genome: addArchRGenome(&quot;hg19&quot;) The precompiled version of the hg38 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg38, TxDb.Hsapiens.UCSC.hg38.knownGene, org.Hs.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the hg38 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg38 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg38 genome: addArchRGenome(&quot;hg38&quot;) The precompiled version of the mm9 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm9, TxDb.Mmusculus.UCSC.mm9.knownGene, org.Mm.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the mm9 v1 blacklist regions from Anshul Kundaje and from mitochondrial regions that show high mappability to the mm9 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled mm9 genome: addArchRGenome(&quot;mm9&quot;) The precompiled version of the mm10 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm10, TxDb.Mmusculus.UCSC.mm10.knownGene, org.Mm.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the mm10 v2 blacklist regions and from mitochondrial regions that show high mappability to the mm10 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled mm10 genome: addArchRGenome(&quot;mm10&quot;) 3.5.1 Creating a Custom ArchRGenome As described above, an ArchRGenome consists of a genome annotation and a gene annotation. If you create your own genome and gene annotations, then you would pass these directly to createArrowFiles() using the genomeAnnotation and geneAnnotation parameters, rather than calling addArchRGenome(). To create a custom genome annotation, we use createGenomeAnnotation(). To do this, you will need the following information: A BSgenome object which contains the sequence information for a genome. These are commonly Bioconductor packages (for example, BSgenome.Hsapiens.UCSC.hg38) that can be easily found with google. A GRanges genomic ranges object containing a set of blacklisted regions that will be used to filter out unwanted regions from downstream analysis. This is not required but is recommended. For information on how blacklists are created, see the publication on the ENCODE blacklists. For example, if we wanted to create a custom genome annotation from Drosophila melanogaster, we would first identify and install and load the relevant BSgenome object. if (!requireNamespace(&quot;BSgenome.Dmelanogaster.UCSC.dm6&quot;, quietly = TRUE)){ BiocManager::install(&quot;BSgenome.Dmelanogaster.UCSC.dm6&quot;, update = FALSE) } library(BSgenome.Dmelanogaster.UCSC.dm6) ## Loading required package: BSgenome ## Loading required package: Biostrings ## Loading required package: XVector ## ## Attaching package: &#39;XVector&#39; ## The following object is masked from &#39;package:plyr&#39;: ## ## compact ## ## Attaching package: &#39;Biostrings&#39; ## The following object is masked from &#39;package:grid&#39;: ## ## pattern ## The following object is masked from &#39;package:base&#39;: ## ## strsplit ## Loading required package: BiocIO ## Loading required package: rtracklayer ## ## Attaching package: &#39;rtracklayer&#39; ## The following object is masked from &#39;package:BiocIO&#39;: ## ## FileForFormat Then we create a genome annotation from this BSgenome object. genomeAnnotation &lt;- createGenomeAnnotation(genome = BSgenome.Dmelanogaster.UCSC.dm6) ## Getting genome.. ## Attempting to infer chromSizes.. ## Attempting to infer blacklist.. ## Blacklist not downloaded! Continuing without, be careful for downstream biases.. Examining this object shows the constituent parts of an ArchR genome annotation. genomeAnnotation ## List of length 3 ## names(3): genome chromSizes blacklist To create a custom gene annotation, we use createGeneAnnotation(). To do this, you will need the following information: A TxDb object (transcript database) from Bioconductor which contains information for gene/transcript coordinates. An OrgDb object (organism database) from Bioconductor which provides a unified framework to map between gene names and various gene identifiers. Continuing with our example from Drosophila melanogaster, we first install and load the relevant TxDb and OrgDb objects. if (!requireNamespace(&quot;TxDb.Dmelanogaster.UCSC.dm6.ensGene&quot;, quietly = TRUE)){ BiocManager::install(&quot;TxDb.Dmelanogaster.UCSC.dm6.ensGene&quot;, update = FALSE) } if (!requireNamespace(&quot;org.Dm.eg.db&quot;, quietly = TRUE)){ BiocManager::install(&quot;org.Dm.eg.db&quot;, update = FALSE) } ## library(TxDb.Dmelanogaster.UCSC.dm6.ensGene) ## Loading required package: GenomicFeatures ## Loading required package: AnnotationDbi library(org.Dm.eg.db) Then we create the gene annotation object. geneAnnotation &lt;- createGeneAnnotation(TxDb = TxDb.Dmelanogaster.UCSC.dm6.ensGene, OrgDb = org.Dm.eg.db) ## Getting Genes.. ## 1 gene was dropped because it has exons located on both strands of the ## same reference sequence or on more than one reference sequence, so ## cannot be represented by a single genomic range. ## Use &#39;single.strand.genes.only=FALSE&#39; to get all the genes in a ## GRangesList object, or use suppressMessages() to suppress this message. ## Determined Annotation Style = ENSEMBL ## Getting Exons.. ## Getting TSS.. Examining this object shows the constituent parts of an ArchR gene annotation. geneAnnotation ## List of length 3 ## names(3): genes exons TSS In some cases, information contained within the OrgDb object and the TxDb object might not match as expected. ArchR will attempt to default to an annotation style / keytype of “ENTREZID” or “ENSEMBL” to map between gene names within the TxDb object and various gene identifiers within the OrgDb object. For some organisms, (for ex. arabidopsis), you may need to specify a particular annotation style to the annoStyle parameter of createGeneAnnotation() to tell ArchR what the keytype is of the gene names contained within your TxDb object. Alternatively, if you dont have a TxDb and OrgDb object, you can create a geneAnnotation object from the following information : A “genes” object - a GRanges object containing gene coordinates (start to end). This object must have a symbols column matching the symbols column of the “exons” object described below. An “exons” object - GRanges object containing gene exon coordinates. Must have a symbols column matching the symbols column of the “genes” object described above. A GRanges object containing standed transcription start site (TSS) coordinates. geneAnnotation &lt;- createGeneAnnotation( TSS = geneAnnotation$TSS, exons = geneAnnotation$exons, genes = geneAnnotation$genes ) In general, we cannot provide much support for non-standard genomes. However, some ArchR users have created a repository to hold custom genome annotations for some popular model organisms. We encourage you to check out and contribute to that user-developed custom genomes repository. If you are looking for information on how to forge your own custom gene annotation, you should read through previous issue posts for inspiration. For species with lots of small scaffolds, please make sure to remove genes within 2 kb of scaffold ends from the gene annotation, remove unassembled scaffolds from the genome annotation, and remove any scaffolds that lack genes as these will interfere with downstream analyses. When creating a custom genome for use with ArchR, it is imperative that all of the provided information matches. More explicitly, the chromosomes/seqnames present in your genomeAnnotation must match those present in your geneAnnotation and both must match the genome used for alignment. If you have contigs with no mapped reads, these may cause problems for ArchR and you should remove them entirely from your data and annotations. 3.5.2 Using Non-standard Genomes in ArchR ArchR implements some checks to prevent you from doing things that we consider “out of the norm”. One of these checks forces the seqnames of your genome annotation to start with “chr”. This is true in most applications but there are some genomes (for example Maize) which do not use “chr” as a prefix for the different chromosomes. To perform any ArchR analyses on such a genome, you have to tell ArchR to ignore the chromosome prefixes. To do this, you must run addArchRChrPrefix(chrPrefix = FALSE) prior to creating your Arrow files. This will turn off the requirement for “chr” prefixes on seqnames globally in the current R session. Please keep in mind ArchR converts chromosome/seqnames to character by default. Thus, if your seqnames are just integers, you will need to supply them as characters i.e. useSeqnames = c(\"1\", \"2\", \"3\") instead of useSeqnames = c(1, 2, 3). You can always check if chromosome prefixes are required in the current R session using getArchRChrPrefix(). "],["creating-arrow-files.html", "3.6 Creating Arrow Files", " 3.6 Creating Arrow Files For the remainder of this tutorial, we will use data from a downsampled dataset of hematopoietic cells from Granja* et al. Nature Biotechnology 2019. This includes data from bone marrow mononuclear cells (BMMC), peripheral blood mononuclear cells (PBMC), and CD34+ hematopoietic stem and progenitor cells from bone marrow (CD34 BMMC). This data is downloaded as fragment files which contain the start and end genomic coordinates of all aligned sequenced fragments. Fragment files are one of the base file types of the 10x Genomics analytical platform (and other platforms) and can be easily created from any BAM file. See the 10x Genomics website for information on making your own fragment files for input to ArchR. Importantly, if you are creating your own fragment files, these files must be sorted on position and zipped/compressed using the bgzip utility. Despite having a .gz suffix, bgzipped files are different than gzipped files. While ArchR can handle BAM files as input, fragment files are the most optimal. If using cellranger, you should not use the output of aggr in ArchR because this groups samples together, thus eliminating the ability of ArchR to parallelize across samples. If you are using non-10x Genomics data, you should be extra careful to make sure that your input files match what ArchR expects. For example, bio-rad data is often aligned using multi-species references and fragment files for ArchR can only have one species. Similarly, if your data is from single-end sequencing, you would need to create pseudo-fragments the span a single base-pair, though this is not something that we have tested or support. Once we have our fragment files, we provide their paths as a character vector to createArrowFiles(). During creation, some basic metadata and matrices are added to each Arrow file including a “TileMatrix” containing insertion counts across genome-wide 500-bp bins (see addTileMatrix()) and a “GeneScoreMatrix” that stores predicted gene expression based on weighting insertion counts in tiles nearby a gene promoter (see addGeneScoreMatrix()). The tutorial data can be downloaded using the getTutorialData() function. The tutorial data is approximately 0.5 GB in size. If you have already downloaded the tutorial in the current working directory, ArchR will bypass downloading. library(ArchR) library(parallel) inputFiles &lt;- getTutorialData(&quot;Hematopoiesis&quot;) ## Downloading files to HemeFragments... ## Downloading file scATAC_BMMC_R1.fragments.tsv.gz... ## Downloading file scATAC_CD34_BMMC_R1.fragments.tsv.gz... ## Downloading file scATAC_PBMC_R1.fragments.tsv.gz... inputFiles ## scATAC_BMMC_R1 ## &quot;HemeFragments/scATAC_BMMC_R1.fragments.tsv.gz&quot; ## scATAC_CD34_BMMC_R1 ## &quot;HemeFragments/scATAC_CD34_BMMC_R1.fragments.tsv.gz&quot; ## scATAC_PBMC_R1 ## &quot;HemeFragments/scATAC_PBMC_R1.fragments.tsv.gz&quot; If we inspect inputFiles, you’ll notice that it is simply a named vector of fragment files. This vector is automatically created for convenience by the getTutorialData() function but you will need to create it yourself for your own data like so: inputFiles_example &lt;- c(&quot;/path/to/fragFile1.tsv.gz&quot;, &quot;/path/to/fragFile2.tsv.gz&quot;) names(inputFiles_example) &lt;- c(&quot;Sample1&quot;,&quot;Sample2&quot;) As always, before starting a project we must set the ArchRGenome and default threads for parallelization. The tutorial data was aligned to the hg19 reference genome so we will use that. The number of threads used will depend on your system so you should adjust that accordingly. addArchRGenome(&quot;hg19&quot;) ## Setting default genome to Hg19. addArchRThreads(threads = 16) ## Setting default number of Parallel threads to 16. Now we will create our Arrow Files which will take 10-15 minutes for the tutorial data. For each sample, this step will: Read accessible fragments from the provided input files. Calculate quality control information for each cell (i.e. TSS enrichment scores and nucleosome info). Filter cells based on quality control parameters. Create a genome-wide TileMatrix using 500-bp bins. Create a GeneScoreMatrix using the custom geneAnnotation that was defined when we called addArchRGenome(). ArrowFiles &lt;- createArrowFiles( inputFiles = inputFiles, sampleNames = names(inputFiles), minTSS = 4, #Dont set this too high because you can always increase later minFrags = 1000, addTileMat = TRUE, addGeneScoreMat = TRUE ) ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## ArchR logging to : ArchRLogs/ArchR-createArrows-3c354112e256-Date-2024-12-03_Time-22-34-27.114667.log ## If there is an issue, please report to github with logFile! ## Cleaning Temporary Files ## subThreading Disabled since ArchRLocking is TRUE see `addArchRLocking` ## 2024-12-03 22:34:27.795516 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-createArrows-3c354112e256-Date-2024-12-03_Time-22-34-27.114667.log One important parameter in createArrowFiles() is the subThreading parameter. However, the subThreading parameter does not trump the ArchRLocking established with addArchRLocking() mentioned above. Instead, if ArchRLocking is set to FALSE, then you may enable subthreading by setting subThreading = TRUE. We can inspect the ArrowFiles object to see that it is actually just a character vector of Arrow file paths. ArrowFiles ## [1] &quot;scATAC_BMMC_R1.arrow&quot; &quot;scATAC_CD34_BMMC_R1.arrow&quot; ## [3] &quot;scATAC_PBMC_R1.arrow&quot; "],["per-cell-quality-control.html", "3.7 Per-cell Quality Control", " 3.7 Per-cell Quality Control Strict quality control (QC) of scATAC-seq data is essential to remove the contribution of low-quality cells. In ArchR, we consider three characteristics of data: The number of unique nuclear fragments (i.e. not mapping to mitochondrial DNA). The signal-to-background ratio. Low signal-to-background ratio is often attributed to dead or dying cells which have de-chromatinzed DNA which allows for random transposition genome-wide. The fragment size distribution. Due to nucleosomal periodicity, we expect to see depletion of fragments that are the length of DNA wrapped around a nucleosome (approximately 147 bp). The first metric, unique nuclear fragments, is straightforward - cells with very few usable fragments will not provide enough data to make useful interpretations and should therefore be excluded. The second metric, signal-to-background ratio, is calculated as the TSS enrichment score. Traditional bulk ATAC-seq analysis has used this TSS enrichment score as part of a standard workflow for determination of signal-to-background (for example, the ENCODE project). We and others have found the TSS enrichment to be representative across the majority of cell types tested in both bulk ATAC-seq and scATAC-seq. The idea behind the TSS enrichment score metric is that ATAC-seq data is universally enriched at gene TSS regions compared to other genomic regions, due to large protein complexes that bind to promoters. By looking at per-basepair accessibility centered at these TSS regions, we see a local enrichment relative to flanking regions (1900-2000 bp distal in both directions). The ratio between the peak of this enrichment (centered at the TSS) relative to these flanking regions represents the TSS enrichment score. Traditionally, the per-base-pair accessibility is computed for each bulk ATAC-seq sample and then this profile is used to determine the TSS enrichment score. Performing this operation on a per-cell basis in scATAC-seq is relatively slow and computationally expensive. To accurately approximate the TSS enrichment score per single cell, we count the average accessibility within a 50-bp region centered at each single-base TSS position and divide this by the average accessibility of the TSS flanking positions (+/- 1900 - 2000 bp). This approximation was highly correlated (R &gt; 0.99) with the original method and values were extremely close in magnitude. The third metric, fragment size distribution, is generally less important but always good to manually inspect. Because of the patterned way that DNA wraps around nucleosomes, we expect to see a nucleosomal periodicity in the distribution of fragment sizes in our data. These hills and valleys appear because fragments must span 0, 1, 2, etc. nucleosomes (Tn5 cannot cut DNA that is tightly wrapped around a nucleosome. By default in ArchR, pass-filter cells are identified as those cells having a TSS enrichment score greater than 4 and more than 1000 unique nuclear fragments. It is important to note that the actual numeric value of the TSS enrichment score depends on the set of TSSs used. The default values in ArchR were designed for human data and it may be important to change the default thresholds when running createArrowFiles(). Other quality metrics have been used for ATAC-seq data previously. In particular, the Fraction of Reads in Peaks (aka FRiP) was adopted from ChIP-seq analysis to serve as a signal-to-background measurement. The problem with using FRiP is that you must first define a peak set to use for calculating the fraction of reads within that peak set. This becomes problematic in quality control of single-cell ATAC-seq data because this means that you must define your peak set before clustering because you should filter out low quality cells before clustering. For this reason, FRiP is typically calculated per-cell based on a peak set identified from the merged set of all cells. This obscures cell type-specific peaks from lowly abundant cell types (less than 20%) and thus biases more abundant cell types to having better quality scores. This is certainly not desirable and also underlies the problems associated with using the cells x peaks matrix provided (for ex.) by cellranger which uses peaks called on the merged set of all cells. To get around this without having to calculate TSS enrichment scores, other tools (SnapATAC v1) have used the Fraction of reads in Promoters (aka FIP) which does not require a pre-defined peak set. However, this metric does not provide as clear a stratification of high-quality cells from low-quality cells. Creation of Arrow files will create a folder in the current working directory called “QualityControl” which will contain 2 plots associated with each of your samples. The first plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines. The second shows the fragment size distribution. For our tutorial data, we have three samples as shown below: For BMMC: For CD34 BMMC: For PBMC: We are now ready to tidy up these Arrow files and then create an ArchRProject. "],["using-bam-files-for-arrow-file-creation.html", "3.8 Using BAM files for Arrow File creation", " 3.8 Using BAM files for Arrow File creation Though fragment files are strongly preferred because of their very standardized format, BAM files can also be used as input for Arrow File creation in ArchR. The key to getting this to work is understanding your BAM file structure, in particular which field of the BAM file contains the cell-specific barcode information. In this example, we will download some data from 10x Genomics to illustrate how to use BAM files as input to createArrowFiles(). Using samtools view #set timeout to prevent interrupting large file download options(timeout=1000) dir.create(path = &quot;./PBMC_BAM&quot;) down_df &lt;- data.frame( fileUrl = c(&quot;https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_possorted_bam.bam&quot;, &quot;https://cf.10xgenomics.com/samples/cell-atac/2.0.0/atac_pbmc_500_nextgem/atac_pbmc_500_nextgem_possorted_bam.bam.bai&quot;), md5sum = c(&quot;8140a2218ecdfd276aca5c4bb999c989&quot;,&quot;d3c5f5a00fec76378f2a947749ff2cf5&quot;) ) #we will use a hidden ArchR function to do the download. This automatically checks the md5sum. ArchR:::.downloadFiles(filesUrl = down_df, pathDownload = &quot;./PBMC_BAM&quot;, threads = 1) ## Downloading files to ./PBMC_BAM... ## Downloading file atac_pbmc_500_nextgem_possorted_bam.bam... ## Downloading file atac_pbmc_500_nextgem_possorted_bam.bam.bai... ## [[1]] ## [1] 0 ## ## [[2]] ## [1] 0 If we were to use samtools view from the command line to look at this BAM file, the first line would look like this: A00519:269:H7FM2DRXX:2:1201:1985:18834 83 chr1 9997 0 50M = 10022 -25 CAGATAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAACCCTAAC ,,,:FF,,F,FF,FFFFFFF:FFFFFFFFFFFFFFF:FF:FFF,:FFFFF NM:i:1 MD:Z:1C48 AS:i:48 XS:i:47 CR:Z:GCGGGTTAGAACGTCG CY:Z:FFFFFFFF:FFFFFFF CB:Z:GCGGGTTAGAACGTCG-1 BC:Z:ATCGTACT QT:Z:FFFFFFFF RG:Z:atac_pbmc_500_nextgem:MissingLibrary:1:H7FM2DRXX:2 Here, the CB tag is used to store the cell-specific barcode, in this case CB:Z:GCGGGTTAGAACGTCG-1. This means that we will pass bcTag = \"CB\" to createArrowFiles() to tell it to look for the CB tag. If, for example, your BAM files come from a scATAC-seq technology other than 10x Genomics, the relevant tag will likely be different. On top of that, the format of the cell-specific barcode may also be different. In these cases, it may be necessary to use the gsubExpression parameter to clean up the cell-specific barcode string. The other important input parameter is bamFlag which will determine which reads or fragments are viewed as valid. The value passed to bamFlag should be in the format of a scanBamFlag used by ScanBam in Rsamtools. In addition to understanding the structure of you BAM file, you may need to pre-process your BAM file by: Removing any fragments less than 20 bp in length Marking/removing PCR duplicates Removing barcode reads that are NA In the case of our example data that we just downloaded, we can proceed to Arrow file creation. addArchRGenome(&quot;hg38&quot;) ## Setting default genome to Hg38. ArrowBam &lt;- createArrowFiles( inputFiles = &quot;./PBMC_BAM/atac_pbmc_500_nextgem_possorted_bam.bam&quot;, sampleNames = &quot;bam10x&quot;, minTSS = 4, #Dont set this too high because you can always increase later minFrags = 1000, addTileMat = FALSE, addGeneScoreMat = FALSE, bcTag = &quot;CB&quot;, bamFlag = list(isMinusStrand = FALSE, isProperPair = TRUE, isDuplicate = FALSE) ) ## Using GeneAnnotation set by addArchRGenome(Hg38)! ## Using GeneAnnotation set by addArchRGenome(Hg38)! ## ArchR logging to : ArchRLogs/ArchR-createArrows-3c35f9e82ed-Date-2024-12-03_Time-22-53-56.790142.log ## If there is an issue, please report to github with logFile! ## Cleaning Temporary Files ## subThreading Disabled since ArchRLocking is TRUE see `addArchRLocking` ## 2024-12-03 22:53:57.365419 : Batch Execution w/ safelapply!, 0 mins elapsed. ## (bam10x : 1 of 1) Determining Arrow Method to use! ## 2024-12-03 22:53:57.425019 : (bam10x : 1 of 1) Reading In Fragments from inputFiles (readMethod = bam), 0.001 mins elapsed. ## 2024-12-03 22:53:57.43465 : (bam10x : 1 of 1) Tabix Bam To Temporary File, 0.001 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:54:24.046554 : (bam10x : 1 of 1) Reading BamFile 8 Percent, 0.445 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:54:45.353068 : (bam10x : 1 of 1) Reading BamFile 17 Percent, 0.8 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:55:04.430925 : (bam10x : 1 of 1) Reading BamFile 25 Percent, 1.118 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:55:22.53187 : (bam10x : 1 of 1) Reading BamFile 33 Percent, 1.419 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:55:40.110187 : (bam10x : 1 of 1) Reading BamFile 42 Percent, 1.712 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:55:58.812456 : (bam10x : 1 of 1) Reading BamFile 50 Percent, 2.024 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:56:14.042159 : (bam10x : 1 of 1) Reading BamFile 58 Percent, 2.278 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:56:30.364622 : (bam10x : 1 of 1) Reading BamFile 67 Percent, 2.55 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:56:48.562311 : (bam10x : 1 of 1) Reading BamFile 75 Percent, 2.853 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:57:08.5803 : (bam10x : 1 of 1) Reading BamFile 83 Percent, 3.187 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:57:20.790855 : (bam10x : 1 of 1) Reading BamFile 92 Percent, 3.39 mins elapsed. ## Warning in sprintf(&quot;%s Reading BamFile %s Percent&quot;, prefix, round(100 * : one ## argument not used by format &#39;%s Reading BamFile %s Percent&#39; ## 2024-12-03 22:57:32.016427 : (bam10x : 1 of 1) Reading BamFile 100 Percent, 3.578 mins elapsed. ## 2024-12-03 22:57:32.942728 : (bam10x : 1 of 1) Successful creation of Temporary File, 3.593 mins elapsed. ## 2024-12-03 22:57:32.949099 : (bam10x : 1 of 1) Creating ArrowFile From Temporary File, 3.593 mins elapsed. ## 2024-12-03 22:58:36.770678 : (bam10x : 1 of 1) Successful creation of Arrow File, 4.657 mins elapsed. ## 2024-12-03 22:59:41.547574 : (bam10x : 1 of 1) CellStats : Number of Cells Pass Filter = 568 , 5.736 mins elapsed. ## 2024-12-03 22:59:41.552092 : (bam10x : 1 of 1) CellStats : Median Frags = 16887 , 5.736 mins elapsed. ## 2024-12-03 22:59:41.557904 : (bam10x : 1 of 1) CellStats : Median TSS Enrichment = 19.811 , 5.737 mins elapsed. ## 2024-12-03 22:59:42.741133 : (bam10x : 1 of 1) Adding Additional Feature Counts!, 5.756 mins elapsed. ## 2024-12-03 23:00:41.631099 : (bam10x : 1 of 1) Removing Fragments from Filtered Cells, 6.738 mins elapsed. ## 2024-12-03 23:00:41.638938 : (bam10x : 1 of 1) Creating Filtered Arrow File, 6.738 mins elapsed. ## 2024-12-03 23:01:05.535157 : (bam10x : 1 of 1) Finished Constructing Filtered Arrow File!, 7.136 mins elapsed. ## 2024-12-03 23:01:05.66431 : (bam10x : 1 of 1) Finished Creating Arrow File, 7.138 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-createArrows-3c35f9e82ed-Date-2024-12-03_Time-22-53-56.790142.log ArrowBam ## [1] &quot;bam10x.arrow&quot; "],["doublet-inference-with-archr.html", "Chapter 4 Doublet Inference with ArchR", " Chapter 4 Doublet Inference with ArchR One major source of trouble in single-cell data is the contribution of “doublets” to the analysis. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell that is effectively the average of the two cells. We remove these computationally and describe this doublet removal process in depth in this chapter. "],["how-does-doublet-identification-work-in-archr.html", "4.1 How does doublet identification work in ArchR?", " 4.1 How does doublet identification work in ArchR? Single-cell data generated on essentially any platform is susceptible to the presence of doublets. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell. For 10x, the percentage of total “cells” that are actually doublets is proportional to the number of cells loaded into the reaction. Even at the lower levels of doublets that result from standard kit use, more than 5% of the data may come from doublets and this exerts substantial effects on clustering. This issue becomes particularly problematic in the context of developmental/trajectory data because doublets look like a mixture between two cell types and this can be confounded with intermediate cell types or cell states. To predict which “cells” are actually doublets, we synthesize in silico doublets from the data by mixing the reads from thousands of combinations of individual cells. We then project these synthetic doublets into the UMAP embedding and identify their nearest neighbor. By iterating this procedure thousands of times, we can identify “cells” in our data whose signal looks very similar to synthetic doublets. To develop and validate ArchR’s doublet identification, we generated scATAC-seq data from pooled mixtures of 10 genetically distinct cell lines. In scATAC-seq space, these 10 cell lines should form 10 distinct clusters but when we deliberately overload the 10x Genomics scATAC-seq reaction, targetting 25,000 cells per reaction, we end up with many doublets. We know these are doublets because we use demuxlet to identify droplets that contain genotypes from two different cell types. This “ground truth” overlaps very strongly with the doublet predictions shown above, showing an area under the curve of the receiver opperating characteristic &gt;0.90. After we computationally remove these doublets with ArchR, the overall structure of our data changes dramatically and matches our expectation of 10 distinct cell types. "],["inferring-scatac-seq-doublets-with-archr.html", "4.2 Inferring scATAC-seq Doublets with ArchR", " 4.2 Inferring scATAC-seq Doublets with ArchR By default ArchR uses the doublet parameters described in the ArchR manuscript. This is likely a good place to start but we encourage all users to inspect the pre- and post-doublet removal data to understand how doublet removal is affecting the cells. We show some of the main adjustable features below to illustrate how this can be customized to a given application. In ArchR, doublet removal is performed in a single step using addDoubletScores(). This adds the infered doublet scores to each Arrow file and will take approximately 2-5 minutes per sample of the tutorial data. You can always try ?addDoubletScores to see further documentation on parameters for doublet identification (or any ArchR function for that matter). doubScores &lt;- addDoubletScores( input = ArrowFiles, k = 10, #Refers to how many cells near a &quot;pseudo-doublet&quot; to count. knnMethod = &quot;UMAP&quot;, #Refers to the embedding to use for nearest neighbor search with doublet projection. LSIMethod = 1 ) ## ArchR logging to : ArchRLogs/ArchR-addDoubletScores-974b4c906-Date-2025-02-06_Time-00-44-32.639996.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 00:44:32.966947 : Batch Execution w/ safelapply!, 0 mins elapsed. ## 2025-02-06 00:44:32.984376 : scATAC_BMMC_R1 (1 of 3) : Computing Doublet Statistics, 0 mins elapsed. ## scATAC_BMMC_R1 (1 of 3) : UMAP Projection R^2 = 0.98913 ## scATAC_BMMC_R1 (1 of 3) : UMAP Projection R^2 = 0.98913 ## 2025-02-06 00:46:06.974304 : scATAC_CD34_BMMC_R1 (2 of 3) : Computing Doublet Statistics, 1.567 mins elapsed. ## scATAC_CD34_BMMC_R1 (2 of 3) : UMAP Projection R^2 = 0.99312 ## scATAC_CD34_BMMC_R1 (2 of 3) : UMAP Projection R^2 = 0.99312 ## 2025-02-06 00:47:22.417418 : scATAC_PBMC_R1 (3 of 3) : Computing Doublet Statistics, 2.824 mins elapsed. ## scATAC_PBMC_R1 (3 of 3) : UMAP Projection R^2 = 0.99346 ## scATAC_PBMC_R1 (3 of 3) : UMAP Projection R^2 = 0.99346 ## ArchR logging successful to : ArchRLogs/ArchR-addDoubletScores-974b4c906-Date-2025-02-06_Time-00-44-32.639996.log In the above output, ArchR reports the R2 value for the UMAP projection for each Arrow file. If these R2 values are much lower (i.e. less than 0.9), this often indicates that the cells within the Arrow file have very little heterogeneity. This makes the accuracy of doublet calling worse because the majority of doublets would be “homotypic” - or a single droplet with two very similar cells. In these cases, ArchR will skip doublet prediction because it is not accurate. Alternatively, you can try setting knnMethod = \"LSI\" and force = TRUE to perform projection in the LSI subspace; however, you should manually assess the results and make sure this is performing as you would expect. Adding doublet scores will create plots in the “QualityControl” directory. There are 3 plots associated with each of your samples in this folder: Doublet Enrichments - These represent the enrichment of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. Doublet Scores - These represent the significance (-log10(binomial adjusted p-value)) of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. We have found this value to be less consistent than the doublet enrichments and therefore use doublet enrichments for doublet identification. Doublet Density - This represents the density of the simulated doublet projections. This allows you to visualize where the synthetic doublets were located after projection into your 2-dimensional embedding. For BMMC : For CD34 BMMC : For PBMC : "],["using-demuxlet-with-archr.html", "4.3 Using demuxlet with ArchR", " 4.3 Using demuxlet with ArchR Doublets can also be identified (in human data) based on sample genotype. If you know the genotypes of your samples ahead of time (and even if you don’t), you can determine which droplets have multiple cells from different genetically distinct samples because those droplets would contain single-nucleotide polymorphisms that should not co-exist in a single sample. Of course, this requires you to mix multiple samples into an individual scATAC-seq reaction, which most labs do not routinely do. However, this “cell hashing” can be a good experimental workflow to reduce batch effects and costs. More justification for this can be found here. ArchR provides easy import of the results from demuxlet via the addDemuxletResults() function. This function takes as input your ArchRProject object, a vector of .best files output by demuxlet, and a vector of sampleNames that is ordered to allow matching of your ArchRProject sample names with the demuxlet .best files provided. More explicitly, given the order of the .best files provided to the bestFiles parameter, you should create a properly ordered vector of sample names that corresponds to each .best file. Because we do not have this type of analysis for the tutorial data, we do not showcase this functionality here. The final output of this function is an updated ArchRProject object and, like other “add-ers” in ArchR, must be stored into an ArchRProject object. This will add two columns to cellColData, one labeled DemuxletClassify which will show whether the cell is classified as a singlet, doublet, or ambiguous, and one labeled DemuxletBest which contains the output of demuxlet identifying the sample to which the given cell corresponds. Cells not classified by demuxlet would be labeled as “NotClassified” for these columns. A hypothetical usage would look like this: ArchRProj &lt;- addDemuxletResults(ArchRProj = ArchRProj, bestFiles = c(&quot;myBestFile1.best&quot;, &quot;myBestFile2.best&quot;), sampleNames = c(&quot;Sample1&quot;, &quot;Sample2&quot;)) "],["creating-an-archrproject.html", "Chapter 5 Creating an ArchRProject", " Chapter 5 Creating an ArchRProject An ArchRProject allows us to group multiple Arrow files together into a single project. This ArchRProject is small and is stored in memory. By interacting with the ArchRProject we can rapidly push and pull data from the Arrow files. As such, it forms the basis of nearly all ArchR functions and analytical workflows. Moreover, ArchRProject objects can be saved and re-loaded at a later date, providing continuity of analyses and facilitating sharing of analytical projects across collaborators. This chapter describes how to create and interact with an ArchRProject object. "],["creating-an-archrproject-1.html", "5.1 Creating An ArchRProject", " 5.1 Creating An ArchRProject First, we must create our ArchRProject by providing a list of Arrow files and a few other parameters. The outputDirectory here describes where all downstream analyses and plots will be saved. ArchR will automatically associate the previously provided geneAnnotation and genomeAnnotation with the new ArchRProject. These were stored when we ran addArchRGenome(\"hg19\") in a previous chapter. Importantly, multiple ArchRProject objects cannot be combined later so any samples that you want to analyze must be included as Arrow files at this project creation step. You’ll note that we set the parameter copyArrows = TRUE which is recommended because we will modify the Arrow files in downstream operations and this preserves an original copy of the Arrow files for future usage as necessary. projHeme1 &lt;- ArchRProject( ArrowFiles = ArrowFiles, outputDirectory = &quot;HemeTutorial&quot;, copyArrows = TRUE ) ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## Validating Arrows... ## Getting SampleNames... ## ## Copying ArrowFiles to Ouptut Directory! If you want to save disk space set copyArrows = FALSE ## 1 2 3 ## Getting Cell Metadata... ## ## Merging Cell Metadata... ## Initializing ArchRProject... ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## We call this ArchRProject “projHeme1” because it is the first iteration of our hematopoiesis project. Throughout this walkthrough we will modify and update this ArchRProject and keep track of which version of the project we are using by iterating the project number (i.e. “projHeme2”). We can examine the contents of our ArchRProject: projHeme1 ## ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## ## class: ArchRProject ## outputDirectory: /workspace/ArchR/ArchR_Website_Testing/bookdown/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(15): Sample TSSEnrichment ... DoubletEnrichment ## BlacklistRatio ## numberOfCells(1): 10660 ## medianTSS(1): 16.815 ## medianFrags(1): 3049.5 We can see from the above that our ArchRProject has been initialized with a few important attributes: The specified outputDirectory. The sampleNames of each sample which were obtained from the Arrow files. A matrix called sampleColData which contains data associated with each sample. A matrix called cellColData which contains data associated with each cell. Because we already computed doublet enrichment scores using addDoubletScores(), which added those values to each cell in the Arrow files, we can see columns corresponding to the “DoubletEnrichment” and “DoubletScore” in the cellColData matrix. The total number of cells in our project which represents all samples after doublet identification and removal. The median TSS enrichment score and the median number of fragments across all cells and all samples. We can check how much memory is used to store the ArchRProject in memory within R: paste0(&quot;Memory Size = &quot;, round(object.size(projHeme1) / 10^6, 3), &quot; MB&quot;) ## [1] &quot;Memory Size = 37.477 MB&quot; We can also ask which data matrices are available within the ArchRProject which will be useful downstream once we start adding to this project: getAvailableMatrices(projHeme1) ## [1] &quot;GeneScoreMatrix&quot; &quot;TileMatrix&quot; Taking a closer look at cellColData, we can see all of the metadata that is stored here. As the name suggests, this is metadata that applies to each individual cell. head(projHeme1@cellColData) ## DataFrame with 6 rows and 15 columns ## Sample TSSEnrichment ReadsInTSS ## &lt;Rle&gt; &lt;array&gt; &lt;array&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 scATAC_BMMC_R1 7.204 1146 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 scATAC_BMMC_R1 7.949 831 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 scATAC_BMMC_R1 4.447 384 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 scATAC_BMMC_R1 6.941 659 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 scATAC_BMMC_R1 4.771 412 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 scATAC_BMMC_R1 9.185 1104 ## ReadsInPromoter ReadsInBlacklist ## &lt;array&gt; &lt;array&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4306 611 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 3542 502 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 1686 311 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 2811 475 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 2108 331 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 4457 341 ## PromoterRatio PassQC NucleosomeRatio ## &lt;array&gt; &lt;array&gt; &lt;array&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 0.0822100882049716 1 3.22675919948354 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 0.0857710189848896 1 1.23149248892251 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 0.044391785150079 1 3.69933184855234 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 0.0768200699606471 1 4.27870744373918 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 0.0603734677511742 1 4.03838383838384 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 0.130253083172599 1 2.58453802639849 ## nMultiFrags nMonoFrags nFrags nDiFrags ## &lt;array&gt; &lt;array&gt; &lt;array&gt; &lt;array&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 3801 6196 26189 16192 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 3448 9253 20648 7947 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 3119 4041 18990 11830 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 3853 3466 18296 10977 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 3564 3465 17458 10429 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 3605 4773 17109 8731 ## DoubletScore DoubletEnrichment ## &lt;array&gt; &lt;array&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 0 1.55 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 91.1760813271055 5.75 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 0 1.3 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 70.630505425003 5.05 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 163.664669675752 7.9 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 120.537764456854 6.65 ## BlacklistRatio ## &lt;array&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 0.0116652029478025 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 0.0121561410306083 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 0.00818852027382833 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 0.0129809794490599 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 0.00947989460419292 ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 0.00996551522590449 You’ll notice that many of these columns correspond to per-cell quality control information that was calculated during Arrow file creation. These columns are: TSSEnrichment - the per-cell TSS enrichment score ReadsInTSS - the number of reads that fall within TSS regions (default is 100 bp around TSS) ReadsInPromoter - the number of reads that fall in promoter regions (default is -2000 to +100 from the TSS) PromoterRatio - the ratio of reads in promoters to reads outside of promoters ReadsInBlacklist - the number of reads that fall in blacklist regions BlacklistRatio - the ratio of reads in blacklist regions to reads outside of blacklist regions NucleosomeRatio - similar to above but for reads mapping to nucleosome-sized reads, defined as: (nDiFrags + nMultiFrags) / nMonoFrags) nFrags - the number of fragments recovered per cell nMonoFrags - the number of fragments that have length less than 2 * nucLength (nucLength is the length of DNA that wraps around a nucleosome (147 bp by default)) nDiFrags - the number of fragments that have length less than 3 * nucLength but greater than 2 * nucLength nMultiFrags - the number of fragments that have length &gt;= 3*nucLength PassQC - equal to 1 if the cell passed QC filters or 0 if not Throughout the tutorial, other data will get added to cellColData, for example the number of ReadsInPeaks or FRiP when we add a peak set to the project. "],["manipulating-an-archrproject.html", "5.2 Manipulating An ArchRProject", " 5.2 Manipulating An ArchRProject Now that we have created an ArchRProject, there are many things that we can do to easily access or manipulate the associated data. Example 1. The $ accessor allows direct access to cellColData We can access the cell names associated with each cell: head(projHeme1$cellNames) ## [1] &quot;scATAC_BMMC_R1#TTATGTCAGTGATTAG-1&quot; &quot;scATAC_BMMC_R1#AAGATAGTCACCGCGA-1&quot; ## [3] &quot;scATAC_BMMC_R1#GCATTGAAGATTCCGT-1&quot; &quot;scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1&quot; ## [5] &quot;scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1&quot; &quot;scATAC_BMMC_R1#AGTTACGAGAACGTCG-1&quot; We can access the sample names associated with each cell: head(projHeme1$Sample) ## [1] &quot;scATAC_BMMC_R1&quot; &quot;scATAC_BMMC_R1&quot; &quot;scATAC_BMMC_R1&quot; &quot;scATAC_BMMC_R1&quot; ## [5] &quot;scATAC_BMMC_R1&quot; &quot;scATAC_BMMC_R1&quot; We can access the TSS Enrichment Scores for each cell: quantile(projHeme1$TSSEnrichment) ## 0% 25% 50% 75% 100% ## 4.10900 13.92550 16.81500 19.93025 41.98000 Example 2. Subsetting an ArchRProject by cells There are many ways that we can subset an ArchRProject to obtain only a select set of cells. However, the different ways to subset an ArchRProject have very different effects and should not be considered equivalent. The only robust way to subset an ArchRProject is to use the subsetArchRProject() function. This function takes a list of cells and an outputDirectory and creates a new full copy of the ArchRProject and corresponding Arrow files in the designated directory. This is the ideal way to subset an ArchRProject because it ensures that only one ArchRProject object is referring to the specified Arrow files (more details on this below). Additionally, by using the dropCells argument, you can remove unnecessary cells from downstream analyses. Setting dropCells = TRUE is almost always the correct choice and setting dropCells = FALSE can lead to some unexpected downstream issues depending on your workflow. For example, we could use subsetArchRProject() to keep only the cells from a specific sample (shown below) or cluster to perform a subsetted downstream analysis. All you need to do is pass the cellNames of the cells that you would like to retain to the cells parameter. idxSample &lt;- BiocGenerics::which(projHeme1$Sample %in% &quot;scATAC_BMMC_R1&quot;) projSubset &lt;- subsetArchRProject( ArchRProj = projHeme1, cells = projHeme1$cellNames[idxSample], outputDirectory = &quot;ArchRSubset&quot;, dropCells = TRUE, force = TRUE ) ## Copying ArchRProject to new outputDirectory : /workspace/ArchR/ArchR_Website_Testing/bookdown/ArchRSubset ## Copying Arrow Files... ## .copyArrow : Initializing Out ArrowFile ## .copyArrow : Adding Metadata to Out ArrowFile ## .copyArrow : Adding SubMatrices to Out ArrowFile ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## Copying Other Files... ## Copying Other Files (1 of 1): Plots ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## It is important to note that some operations will need to be re-run after project subsetting. Much of this is dictated by common sense. For example, if you want to look at only the subsetted cells on a new UMAP embedding, you need to create that new embedding first. Similarly, if you want to perform sub-clustering, you should almost certainly re-run dimensionality reduction (LSI) first. The primary disadvantage of subsetArchRProject() is that it makes copies of the Arrow files which can be quite large for bigger data sets. Nevertheless, this is the absolute most stable way to subset a project and is the only way that we recommend. If your data set size is so massive that copying the Arrow files is not reasonable, you can try subsetting the project manually as illustrated below. However, it is important to note if you do this, you can run into the situation where you have multiple ArchRProject objects pointing to the same Arrow files. You may alter those Arrow files in one project, causing something to unexpectedly break in the other project. We do not consider this type of project subsetting to be stable and strongly recommend against using this strategy. For example, we can subset the project numerically, for example taking the first 100 cells in the project: projHeme1[1:100, ] ## ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## ## class: ArchRProject ## outputDirectory: /workspace/ArchR/ArchR_Website_Testing/bookdown/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(15): Sample TSSEnrichment ... DoubletEnrichment ## BlacklistRatio ## numberOfCells(1): 100 ## medianTSS(1): 10.794 ## medianFrags(1): 10200.5 And we can subset the project based on certain cell names: projHeme1[projHeme1$cellNames[1:100], ] ## ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## ## class: ArchRProject ## outputDirectory: /workspace/ArchR/ArchR_Website_Testing/bookdown/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(15): Sample TSSEnrichment ... DoubletEnrichment ## BlacklistRatio ## numberOfCells(1): 100 ## medianTSS(1): 10.794 ## medianFrags(1): 10200.5 We can subset the project to keep all cells corresponding to a specific sample: idxSample &lt;- BiocGenerics::which(projHeme1$Sample %in% &quot;scATAC_BMMC_R1&quot;) cellsSample &lt;- projHeme1$cellNames[idxSample] projHeme1[cellsSample, ] ## ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## ## class: ArchRProject ## outputDirectory: /workspace/ArchR/ArchR_Website_Testing/bookdown/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(15): Sample TSSEnrichment ... DoubletEnrichment ## BlacklistRatio ## numberOfCells(1): 4932 ## medianTSS(1): 15.2575 ## medianFrags(1): 2771 We can subset the project to only keep cells that meet a specific cutoff for the TSS enrichment score: idxPass &lt;- which(projHeme1$TSSEnrichment &gt;= 8) cellsPass &lt;- projHeme1$cellNames[idxPass] projHeme1[cellsPass, ] ## ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## ## class: ArchRProject ## outputDirectory: /workspace/ArchR/ArchR_Website_Testing/bookdown/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(15): Sample TSSEnrichment ... DoubletEnrichment ## BlacklistRatio ## numberOfCells(1): 10499 ## medianTSS(1): 16.899 ## medianFrags(1): 3042 Example 3. Adding data to an ArchRProject We can add columns to cellColData to store any type of cell-specific metadata relevant to our project. For example, we can add a column to cellColData that contains more legible sample names by removing excess info from the original sample names: bioNames &lt;- gsub(&quot;_R2|_R1|scATAC_&quot;,&quot;&quot;,projHeme1$Sample) head(bioNames) ## [1] &quot;BMMC&quot; &quot;BMMC&quot; &quot;BMMC&quot; &quot;BMMC&quot; &quot;BMMC&quot; &quot;BMMC&quot; One way to add a column called to cellColData is by directly using the $ accessor. projHeme1$bioNames &lt;- bioNames Alternatively, we can add a column to cellColData using the addCellColData() function. ArchR allows for the addition of columns that only contain information for a subset of cells. bioNames &lt;- bioNames[1:10] cellNames &lt;- projHeme1$cellNames[1:10] projHeme1 &lt;- addCellColData(ArchRProj = projHeme1, data = paste0(bioNames), cells = cellNames, name = &quot;bioNames2&quot;) By default, ArchR will fill in missing entries with NA. Because of this, when we can compare these two columns, we see NA filled in where data wasnt available for bioNames2: getCellColData(projHeme1, select = c(&quot;bioNames&quot;, &quot;bioNames2&quot;)) ## DataFrame with 10660 rows and 2 columns ## bioNames bioNames2 ## &lt;character&gt; &lt;character&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 BMMC BMMC ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 BMMC BMMC ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 BMMC BMMC ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 BMMC BMMC ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 BMMC BMMC ## ... ... ... ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 PBMC NA ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 PBMC NA ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 PBMC NA ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 PBMC NA ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 PBMC NA Example 4. Obtaining columns from cellColData ArchR provides the getCellColData() function to enable easy retreival of metadata columns from an ArchRProject. For example, we can retrieve a column by name, such as the number of unique nuclear (i.e. non-mitochondrial) fragments per cell: df &lt;- getCellColData(projHeme1, select = &quot;nFrags&quot;) df ## DataFrame with 10660 rows and 1 column ## nFrags ## &lt;numeric&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 26189 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 20648 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 18990 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 18296 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 17458 ## ... ... ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 1038 ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 1037 ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 1033 ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 1033 ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 1002 Instead of selecting a column by name, we can actually perform operations on a given column using its column name: df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;nFrags - 1&quot;)) df ## DataFrame with 10660 rows and 2 columns ## log10(nFrags) nFrags - 1 ## &lt;numeric&gt; &lt;numeric&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.41812 26188 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31488 20647 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27852 18989 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26236 18295 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199 17457 ## ... ... ... ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01620 1037 ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01578 1036 ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410 1032 ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410 1032 ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00087 1001 Example 5. Plotting QC metrics - log10(Unique Fragments) vs TSS enrichment score Repeating the example shown above, we can easily obtain standard scATAC-seq metrics for quality control of individual cells. We have found that the most robust metrics for quality control are the TSS enrichment score (a measure of signal-to-background in ATAC-seq data) and the number of unique nuclear fragments (because cells with very few fragments do not have enough data to confidently analyze). df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;TSSEnrichment&quot;)) df ## DataFrame with 10660 rows and 2 columns ## log10(nFrags) TSSEnrichment ## &lt;numeric&gt; &lt;numeric&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.41812 7.204 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31488 7.949 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27852 4.447 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26236 6.941 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199 4.771 ## ... ... ... ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01620 24.257 ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01578 22.537 ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410 19.888 ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410 30.000 ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00087 21.287 Now lets plot the number of unique nuclear fragments (log10) by the TSS enrichment score. This type of plot is key for identifying high quality cells. You’ll notice that the cutoffs that we previously specified when creating the Arrow files (via filterTSS and filterFrags) have already removed low quality cells. However, if we noticed that the previously applied QC filters were not adequate for this sample, we could further adjust our cutoffs based on this plot or re-generate the Arrow files if needed. p &lt;- ggPoint( x = df[,1], y = df[,2], colorDensity = TRUE, continuousSet = &quot;sambaNight&quot;, xlabel = &quot;Log10 Unique Fragments&quot;, ylabel = &quot;TSS Enrichment&quot;, xlim = c(log10(500), quantile(df[,1], probs = 0.99)), ylim = c(0, quantile(df[,2], probs = 0.99)) ) + geom_hline(yintercept = 4, lty = &quot;dashed&quot;) + geom_vline(xintercept = 3, lty = &quot;dashed&quot;) p To save an editable vectorized version of this plot, we use plotPDF(). This saves the plot within the “Plots” sub-directory of our ArchRProject directory (defined by getOutputDirectory(projHeme1)). plotPDF(p, name = &quot;TSS-vs-Frags.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE) ## Plotting Ggplot! "],["plotting-sample-statistics-from-an-archrproject.html", "5.3 Plotting Sample Statistics from an ArchRProject", " 5.3 Plotting Sample Statistics from an ArchRProject When working with multiple distinct samples in a single integrated data set, it can be important to compare various metrics across all samples. ArchR provides two main plotting mechanisms for grouped data: ridge plots and violin plots. These are both accessed through the plotGroups() function. Of course, this plot type is not limited to sample-level data and can be used for plotting of downstream group-level information for groups such as clusters. Example 1. Make a ridge plot for each sample for the TSS enrichment scores. To make a ridge plot, we set plotAs = \"ridges\". p1 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;ridges&quot;, baseSize = 10 ) ## 1 p1 ## Picking joint bandwidth of 0.918 Example 2. Make a violin plot for each sample for the TSS enrichment scores. To make a violin plot, we set plotAs = \"violin\". Violin plots in ArchR come with a box-and-whiskers plot in the style of Tukey as implemented by ggplot2. This means that the lower and upper hinges correspond to the 25th and 75th percentiles, respectively, and the middle corresponds to the median. The lower and upper whiskers extend from the hinge to the lowest or highest value or 1.5 times the interquartile range (the distance between the 25th and 75th percentiles). p2 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, baseSize = 10, addBoxPlot = TRUE, ) ## 1 p2 Example 3. Make a ridge plot for each sample for the log10(unique nuclear fragments). p3 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;ridges&quot;, baseSize = 10 ) ## 1 p3 ## Picking joint bandwidth of 0.0506 Example 4. Make a violin plot for each sample for the log10(unique nuclear fragments). p4 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, baseSize = 10, addBoxPlot = TRUE ) ## 1 p4 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;QC-Sample-Statistics.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 4, height = 4) ## Plotting Ggplot! ## Picking joint bandwidth of 0.918 ## Picking joint bandwidth of 0.918 ## Plotting Ggplot! ## Plotting Ggplot! ## Picking joint bandwidth of 0.0506 ## Picking joint bandwidth of 0.0506 ## Plotting Ggplot! "],["plotting-sample-fragment-size-distribution-and-tss-enrichment-profiles..html", "5.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles.", " 5.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles. Because of how the data is stored and accessed, ArchR can compute fragment size distributions and TSS enrichment profiles from Arrow files very quickly. Fragment size distributions To plot the fragment size distributions of all samples, we use the plotFragmentSizes() function. Fragment size distributions in ATAC-seq can be quite variable across samples, cell types, and batches. Slight differences like those shown below are common and do not necessarily correlate with differences in data quality. p1 &lt;- plotFragmentSizes(ArchRProj = projHeme1) ## ArchR logging to : ArchRLogs/ArchR-plotFragmentSizes-920ac6fda-Date-2025-02-06_Time-00-51-06.046969.log ## If there is an issue, please report to github with logFile! ## ArchR logging successful to : ArchRLogs/ArchR-plotFragmentSizes-920ac6fda-Date-2025-02-06_Time-00-51-06.046969.log p1 TSS enrichment profiles To plot TSS enrichment profiles, we use the plotTSSEnrichment() function. TSS enrichment profiles should show a clear peak in the center and a smaller shoulder peak right-of-center which is caused by the well-positioned +1 nucleosome. p2 &lt;- plotTSSEnrichment(ArchRProj = projHeme1) ## ArchR logging to : ArchRLogs/ArchR-plotTSSEnrichment-979253056-Date-2025-02-06_Time-00-51-58.725218.log ## If there is an issue, please report to github with logFile! ## subThreading Disabled since ArchRLocking is TRUE see `addArchRLocking` ## 2025-02-06 00:51:59.759476 : scATAC_BMMC_R1 Computing TSS (1 of 3)!, 0.017 mins elapsed. ## 2025-02-06 00:52:57.795726 : scATAC_BMMC_R1 Finished Computing TSS (1 of 3)!, 0.984 mins elapsed. ## 2025-02-06 00:52:57.822864 : scATAC_CD34_BMMC_R1 Computing TSS (2 of 3)!, 0.985 mins elapsed. ## 2025-02-06 00:53:54.614138 : scATAC_CD34_BMMC_R1 Finished Computing TSS (2 of 3)!, 1.931 mins elapsed. ## 2025-02-06 00:53:54.618581 : scATAC_PBMC_R1 Computing TSS (3 of 3)!, 1.932 mins elapsed. ## 2025-02-06 00:54:50.901624 : scATAC_PBMC_R1 Finished Computing TSS (3 of 3)!, 2.87 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-plotTSSEnrichment-979253056-Date-2025-02-06_Time-00-51-58.725218.log p2 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2, name = &quot;QC-Sample-FragSizes-TSSProfile.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! "],["saving-and-loading-an-archrproject.html", "5.5 Saving and Loading an ArchRProject", " 5.5 Saving and Loading an ArchRProject ArchR provides a facile way to save an ArchRProject object to either re-load at a later time or share with other users. Fundamentally, an ArchRProject points to a set of Arrow files. Because of this, the process of saving an ArchRProject using the saveArchRProject() function will: Copy the current Arrow files and other associated project files to the designated outputDirectory so that they are exclusively associated with the new ArchRProject object. Save a copy of the designated ArchRProject in the outputDirectory. For example, we can save our projHeme1 using saveArchRProject() which will allow us to use this project in future chapters. projHeme1 &lt;- saveArchRProject(ArchRProj = projHeme1, outputDirectory = &quot;Save-ProjHeme1&quot;, load = TRUE) ## Copying ArchRProject to new outputDirectory : /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme1 ## Copying Arrow Files... ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## Copying Other Files... ## Copying Other Files (1 of 1): Plots ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## This will copy the Arrow files and save a .RDS file of the projHeme1 ArchRProject object in the specified outputDirectory. The saveArchRProject() function also has the dropCells parameter. If dropCells = TRUE then cells that exist within the ArrowFiles but have been otherwise removed from the ArchRProject will be trimmed from the ArrowFiles before they are copied to the outputDirectory. Very important! The load parameter determines whether or not the saveArchRProject() function will return the saved ArchRProject object which you would assign to overwrite the original ArchRProject object or provide a new ArchRProject name using &lt;-. This effectively saves and loads the ArchRProject from its new location. If load = FALSE, then this process does NOT update the ArchRProject object that is active in your current R session. Specifically, the object named projHeme1 in the current R session will still point to the original location of the Arrow files, not the copied Arrow files that reside in the specified outputDirectory. You might use this behavior if you were saving your ArchRProject and shutting down your R session so that the project can be reloaded at a later time. Also important! The term ArchRProject can be confusing to some users because we use this both to refer to the object that is actively loaded within the R environment and to the file that has been saved on disk as part of the saveArchRProject() process. However, it is extremely important to understand that these are not equivalent. Manipulations that you perform on an ArchRProject that is actively loaded within the R environment do not automatically propagate to the on-disk file. You must run the saveArchRProject() function to store those changes. To load an ArchRProject that has been previously saved using saveArchRProject() we would use the loadArchRProject() function. To do this, we must provide the path to the directory containing the ArchRProject object which is stored in a file named Save-ArchR-Project.rds. For example, the above call to saveArchRProject() would have created a directory named Save-ProjHeme1 with the following contents: list.files(path = &quot;./Save-ProjHeme1&quot;) ## [1] &quot;ArrowFiles&quot; &quot;Embeddings&quot; &quot;ImputeWeights&quot; ## [4] &quot;IterativeLSI&quot; &quot;IterativeLSI2&quot; &quot;IterativeLSI3&quot; ## [7] &quot;Plots&quot; &quot;RNAIntegration&quot; &quot;Save-ArchR-Project.rds&quot; To load this project we would therefore run: projHeme1 &lt;- loadArchRProject(path = &quot;./Save-ProjHeme1&quot;) ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## "],["filtering-doublets-from-an-archrproject.html", "5.6 Filtering Doublets from an ArchRProject", " 5.6 Filtering Doublets from an ArchRProject After we have added information on the predicted doublets using addDoubletScores(), we can remove these predicted doublets using filterDoublets(). One of the key elements of this filtering step is the filterRatio which is the maximum ratio of predicted doublets to filter based on the number of pass-filter cells. For example, if there are 5000 cells, the maximum number of filtered predicted doublets would be filterRatio * 5000^2 / (100000) (which simplifies to filterRatio * 5000 * 0.05). This filterRatio allows you to apply a consistent filter across multiple different samples that may have different percentages of doublets because they were run with different cell loading concentrations. The higher the filterRatio, the greater the number of cells potentially removed as doublets. The other parameters that can be tweaked for doublet filtration are cutEnrich and cutScore. The cutEnrich is equivalent to the number of simulated doublets identified as a nearest neighbor to the cell divided by the expected number given a random uniform distribution. The cutScore refers to the -log10(pval) of the enrichment and we have found this to be a worse predictor of doublets than cutEnrich. Params for doublet filtering should be sensible and thats why the filter ratio is set to ensure that you do not over filter. If you were to plot the distribution of DoubletEnrichment or DoubletScore (which are stored in cellColData), you should see a small population with high score or enrichment and these represent putative doublets. The goal here is to filter as many doublets as possible while not removing true singlets. To filter doublets, we use the filterDoublets() function. We save the output of this function call as a new ArchRProject for the purposes of this stepwise tutorial but you can always overwrite your original ArchRProject object. projHeme2 &lt;- filterDoublets(projHeme1) ## Filtering 410 cells from ArchRProject! ## scATAC_BMMC_R1 : 243 of 4932 (4.9%) ## scATAC_CD34_BMMC_R1 : 107 of 3275 (3.3%) ## scATAC_PBMC_R1 : 60 of 2453 (2.4%) We can compare the number of cells in projHeme1 (pre-doublet-removal) and in projHeme2 (post-doublet-removal) and see that some cells have been removed during the doublet filtration process. length(getCellNames(ArchRProj = projHeme1)) ## [1] 10660 length(getCellNames(ArchRProj = projHeme2)) ## [1] 10250 If you wanted to filter more cells from the ArchR Project, you would use a higher filterRatio or alternatively tweak cutEnrich or cutScore as described above. projHemeTmp &lt;- filterDoublets(projHeme1, filterRatio = 1.5) ## Filtering 614 cells from ArchRProject! ## scATAC_BMMC_R1 : 364 of 4932 (7.4%) ## scATAC_CD34_BMMC_R1 : 160 of 3275 (4.9%) ## scATAC_PBMC_R1 : 90 of 2453 (3.7%) Since projHemeTmp was only created for illustrative purposes, we remove it from our R session. rm(projHemeTmp) "],["dimensionality-reduction-with-archr.html", "Chapter 6 Dimensionality Reduction with ArchR", " Chapter 6 Dimensionality Reduction with ArchR Dimensionality reduction with scATAC-seq is challenging due to the sparsity of the data. In scATAC-seq, a particular site can either be accessible on one allele, both alleles, or no alleles. Even in higher-quality scATAC-seq data, the majority of accessible regions are not transposed and this leads to many loci having 0 accessible alleles. Moreover, when we see (for example) three Tn5 insertions within a single peak region in a single cell, the sparsity of the data prevents us from confidently determining that this site in this cell is actually three times more accessible than another cell that only has one insertion in the same site. For this reason a lot of analytical strategies work on a binarized scATAC-seq data matrix. This binarized matrix still ends up being mostly 0s because transposition is rare. However, it is important to note that a 0 in scATAC-seq could mean “non-accessible” or “not sampled” and these two inferences are very different from a biological standpoint. Because of this, the 1s have information and the 0s do not. This low information content is what makes our scATAC-seq data sparse. If you were to perform a standard dimensionality reduction, like Principal Component Analysis, on this sparse insertion counts matrix and plot the top two principal components, you would not obtain the desired result because the sparsity causes high inter-cell similarity at all of the 0 positions. To get around this issue, we use a layered dimensionality reduction approach. First, we use Latent Semantic Indexing (LSI), an approach from natural language processing that was originally designed to assess document similarity based on word counts. This solution was created for natural language processing because the data is sparse and noisy (many different words and many low frequency words). LSI was first introduced for scATAC-seq by Cusanovich et al. (Science 2015). In the case of scATAC-seq, different samples are the documents and different regions/peaks are the words. First, we calculate the term frequency by depth normalization per single cell. These values are then normalized by the inverse document frequency which weights features by how often they occur to identify features that are more “specific” rather than commonly accessible. The resultant term frequency-inverse document frequency (TF-IDF) matrix reflects how important a word (aka region/peak) is to a document (aka sample). Then, through a technique called singular value decomposition (SVD), the most valuable information across samples is identified and represented in a lower dimensional space. LSI allows you to reduce the dimensionality of the sparse insertion counts matrix from many thousands to tens or hundreds. Then, a more conventional dimensionality reduction technique, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE) can be used to visualize the data. In ArchR, these visualization methods are referred to as embeddings. "],["archrs-lsi-implementation.html", "6.1 ArchR’s LSI Implementation", " 6.1 ArchR’s LSI Implementation ArchR implements a few different LSI implementations and we have benchmarked many of these methods across multiple different test data sets. ArchR’s default LSI implementation is related to the method introduced by Timothy Stuart in Signac, which uses a term frequency that has been depth normalized to a constant (10,000) followed by normalization with the inverse document frequency and then log-transforming the resultant matrix (aka log(TF-IDF)). One of the key inputs to LSI dimensionality reduction is the starting matrix. Thus far, the two main strategies in scATAC-seq have been to (1) use peak regions or (2) genome-wide tiles. However, using peak regions for LSI is inherently challenging because we do not have clusters or cluster-specific peaks prior to dimensionality reduction. Moreover, calling peaks on aggregated cells prior to clustering obscures cell type-specific peaks. Moreover, any union peak set will change when new samples are added to an experiment, making this strategy less stable. The second strategy, using genome-wide tiles, mitigates these issues by using a consistent and unbiased feature set (genome-wide tiles). However, a genome-wide tile matrix of all cells by all regions can become prohibitively large. For this reason, most implementations use tiles that are greater than or equal to 5 kilobases in size. This drastically reduces the resolution of the approach because most accessible regions are only a few hundred basepairs long. Because of the way that Arrow files are designed, ArchR is able to perform LSI very rapidly using genome-wide 500-bp tiles. This solves the problem of resolution and allows for the identification of clusters prior to calling peaks. The challenge is that 500-bp bins generate around 6 million features to be included in the cell by tile matrix. While ArchR is able to read this large amount of data into R by chunking the relevant matrices, we have also implemented an “estimated LSI” approach that performs the initial dimensionality reduction on a subset of the total cells. This estimated LSI approach has two main utilities - (i) it speeds up dimensionality reduction and (ii) as you decrease the number of cells used in the intial dimensionality reduction, this decreases the granularity of the data. This reduction in granularity can be used to your advantage to reduce batch effects in your data. However, it can also obscure true biology so estimated LSI approaches should be used under close manual supervision. "],["iterative-latent-semantic-indexing-lsi.html", "6.2 Iterative Latent Semantic Indexing (LSI)", " 6.2 Iterative Latent Semantic Indexing (LSI) In scRNA-seq identifying variable genes is a common way to compute dimensionality reduction (such as PCA). This is done because these highly variable genes are more likely to be biologically important and this reduces experimental noise. In scATAC-seq, the data is binary and thus you cannot identify variable peaks for dimensionality reduction. Rather than identifying the most variable peaks, we have tried using the most accessible features as input to LSI; however, the results when running multiple samples have shown high degrees of noise and low reproducibility. To remedy this we introduced the “iterative LSI” approach (Satpathy*, Granja* et al. Nature Biotechnology 2019 and Granja*, Klemm* and McGinnis* et al. Nature Biotechnology 2019). This approach computes an inital LSI transformation on the most accessible tiles and identifies lower resolution clusters that are not batch confounded. For example, when performed on peripheral blood mononuclear cells, this will identify clusters corresponding to the major cell types (T cells, B cells, and monocytes). Then ArchR computes the average accessibility for each of these clusters across all features. ArchR then identifies the most variable peaks across these clusters and uses these features for LSI again. In this second iteration, the most variable peaks are more similar to the variable genes used in scRNA-seq LSI implementations. The user can set how many iterations of LSI should be performed. We have found this approach to minimize observed batch effects and allow dimensionality reduction operations on a more reasonably sized feature matrix. To perform iterative LSI in ArchR, we use the addIterativeLSI() function. The default parameters should cover most cases but we encourage you to explore the available parameters and how they each affect your particular data set. See ?addIterativeLSI for more details on inputs. The most common parameters to tweak are iterations, varFeatures, and resolution. For the purposes of this tutorial, we will create a reducedDims object called “IterativeLSI”. projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( #See Seurat::FindClusters resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) ## Checking Inputs... ## ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-953dd3ebb-Date-2025-02-06_Time-00-55-14.773066.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 00:55:15.811966 : Computing Total Across All Features, 0.006 mins elapsed. ## 2025-02-06 00:55:19.767864 : Computing Top Features, 0.072 mins elapsed. ## ########### ## 2025-02-06 00:55:21.778108 : Running LSI (1 of 2) on Top Features, 0.106 mins elapsed. ## ########### ## 2025-02-06 00:55:21.820077 : Sampling Cells (N = 10001) for Estimated LSI, 0.106 mins elapsed. ## 2025-02-06 00:55:21.82588 : Creating Sampled Partial Matrix, 0.106 mins elapsed. ## 2025-02-06 00:55:27.261534 : Computing Estimated LSI (projectAll = FALSE), 0.197 mins elapsed. ## 2025-02-06 00:55:56.161278 : Identifying Clusters, 0.679 mins elapsed. ## 2025-02-06 00:56:15.429568 : Identified 5 Clusters, 1 mins elapsed. ## 2025-02-06 00:56:15.456056 : Saving LSI Iteration, 1 mins elapsed. ## 2025-02-06 00:56:27.719641 : Creating Cluster Matrix on the total Group Features, 1.205 mins elapsed. ## 2025-02-06 00:56:41.079614 : Computing Variable Features, 1.427 mins elapsed. ## ########### ## 2025-02-06 00:56:41.163378 : Running LSI (2 of 2) on Variable Features, 1.429 mins elapsed. ## ########### ## 2025-02-06 00:56:41.183343 : Creating Partial Matrix, 1.429 mins elapsed. ## 2025-02-06 00:56:46.30877 : Computing LSI, 1.514 mins elapsed. ## 2025-02-06 00:57:12.663592 : Finished Running IterativeLSI, 1.954 mins elapsed. ArchR automatically checks each dimension to determine whether it is highly correlated to the sequencing depth. The corCutOff parameter sets the threshold for this correlation before exclusion of a particular dimension. In some cases, the 1st dimension may be correlated to other technical noise not depth related. In general, ArchR defaults are reasonable and dont need to be changed. However, if you think that your results make more sense if you manually exclude the first dimension, that is a reasonable thing to do. Biological intuition is important to adequately evaluate the results of dimensionality reduction and if removing a specific dimensions steers you closer to your expectation than that is fine. In most cases, the exclusion of a specific dimension doesnt have a strong effect because of the way that the iterative LSI method works compared to non-iterative implementations (e.g. in Signac). To manually exclude a specific dimension, you would alter the dimsToUse parameter. If you see downstream that you have subtle batch effects, another option is to add more LSI iterations and to start from a lower intial clustering resolution as shown below. Additionally the number of variable features can be lowered to increase focus on the more variable features. We will name this reducedDims object “IterativeLSI2” for illustrative purposes but we won’t use it downstream. projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI2&quot;, iterations = 4, clusterParams = list( #See Seurat::FindClusters resolution = c(0.1, 0.2, 0.4), sampleCells = 10000, n.start = 10 ), varFeatures = 15000, dimsToUse = 1:30 ) ## Checking Inputs... ## ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-96daedeeb-Date-2025-02-06_Time-00-57-12.68402.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 00:57:13.770849 : Computing Total Across All Features, 0.007 mins elapsed. ## 2025-02-06 00:57:16.345678 : Computing Top Features, 0.05 mins elapsed. ## ########### ## 2025-02-06 00:57:18.516286 : Running LSI (1 of 4) on Top Features, 0.086 mins elapsed. ## ########### ## 2025-02-06 00:57:18.557341 : Sampling Cells (N = 10001) for Estimated LSI, 0.087 mins elapsed. ## 2025-02-06 00:57:18.563297 : Creating Sampled Partial Matrix, 0.087 mins elapsed. ## 2025-02-06 00:57:23.664754 : Computing Estimated LSI (projectAll = FALSE), 0.172 mins elapsed. ## 2025-02-06 00:57:45.719368 : Identifying Clusters, 0.539 mins elapsed. ## 2025-02-06 00:58:06.130947 : Identified 4 Clusters, 0.879 mins elapsed. ## 2025-02-06 00:58:06.157373 : Saving LSI Iteration, 0.88 mins elapsed. ## 2025-02-06 00:58:16.87973 : Creating Cluster Matrix on the total Group Features, 1.059 mins elapsed. ## 2025-02-06 00:58:31.873538 : Computing Variable Features, 1.308 mins elapsed. ## ########### ## 2025-02-06 00:58:31.948147 : Running LSI (2 of 4) on Variable Features, 1.31 mins elapsed. ## ########### ## 2025-02-06 00:58:31.991523 : Sampling Cells (N = 10001) for Estimated LSI, 1.31 mins elapsed. ## 2025-02-06 00:58:31.997838 : Creating Sampled Partial Matrix, 1.311 mins elapsed. ## 2025-02-06 00:58:37.006133 : Computing Estimated LSI (projectAll = FALSE), 1.394 mins elapsed. ## 2025-02-06 00:58:53.722307 : Identifying Clusters, 1.673 mins elapsed. ## 2025-02-06 00:59:13.595061 : Identified 5 Clusters, 2.004 mins elapsed. ## 2025-02-06 00:59:13.619166 : Saving LSI Iteration, 2.004 mins elapsed. ## 2025-02-06 00:59:27.295542 : Creating Cluster Matrix on the total Group Features, 2.232 mins elapsed. ## 2025-02-06 00:59:40.851247 : Computing Variable Features, 2.458 mins elapsed. ## ########### ## 2025-02-06 00:59:40.937428 : Running LSI (3 of 4) on Variable Features, 2.46 mins elapsed. ## ########### ## 2025-02-06 00:59:40.98348 : Sampling Cells (N = 10001) for Estimated LSI, 2.46 mins elapsed. ## 2025-02-06 00:59:40.988838 : Creating Sampled Partial Matrix, 2.46 mins elapsed. ## 2025-02-06 00:59:46.056044 : Computing Estimated LSI (projectAll = FALSE), 2.545 mins elapsed. ## 2025-02-06 01:00:03.55552 : Identifying Clusters, 2.836 mins elapsed. ## 2025-02-06 01:00:23.679975 : Identified 9 Clusters, 3.172 mins elapsed. ## 2025-02-06 01:00:23.702098 : Saving LSI Iteration, 3.172 mins elapsed. ## 2025-02-06 01:00:35.713982 : Creating Cluster Matrix on the total Group Features, 3.372 mins elapsed. ## 2025-02-06 01:00:50.354712 : Computing Variable Features, 3.616 mins elapsed. ## ########### ## 2025-02-06 01:00:50.475446 : Running LSI (4 of 4) on Variable Features, 3.618 mins elapsed. ## ########### ## 2025-02-06 01:00:50.49314 : Creating Partial Matrix, 3.619 mins elapsed. ## 2025-02-06 01:00:55.741873 : Computing LSI, 3.706 mins elapsed. ## 2025-02-06 01:01:13.678645 : Finished Running IterativeLSI, 4.005 mins elapsed. You can list the available reducedDims objects in an ArchRProject using the slot extraction opperator @: projHeme2@reducedDims ## List of length 2 ## names(2): IterativeLSI IterativeLSI2 "],["estimated-lsi.html", "6.3 Estimated LSI", " 6.3 Estimated LSI For extremely large scATAC-seq datasets, ArchR can estimate the LSI dimensionality reduction with LSI projection. This procedure is similar to the iterative LSI workflow, however the LSI procedure differs. First, a subset of randomly selected “landmark” cells is used for LSI dimensionality reduction. Second, the remaining cells are TF-IDF normalized using the inverse document frequency determined from the landmark cells. Third, these normalized cells are projected into the SVD subspace defined by the landmark cells. This leads to an LSI transformation based on a small set of cells used as landmarks for the projection of the remaining cells. This estimated LSI procedure is efficient with ArchR because, when projecting the new cells into the landmark cells LSI, ArchR iteratively reads in the cells from each sample and LSI projects them without storing them all in memory. This optimization leads to minimal memory usage and further increases the scalability for extremely large datasets. Importantly, the required landmark set size is dependent on the proportion of different cells within the dataset. Estimated LSI is accessed in ArchR via the addIterativeLSI() function by setting the sampleCellsFinal and projectCellsPre parameters. samplesCellsFinal designates the size of the landmark cell subset and projectCellsPre tells ArchR to use this landmark cell subset for projection of the remaining cells. "],["batch-effect-correction-wtih-harmony.html", "6.4 Batch Effect Correction wtih Harmony", " 6.4 Batch Effect Correction wtih Harmony Sometimes the iterative LSI approach isnt enough of a correction for strong batch effect differences. For this reason, ArchR implements a commonly used batch effect correction tool called Harmony which was originally designed for scRNA-seq. We provide a wrapper that will pass a dimensionality reduction object from ArchR directly to the HarmonyMatrix() function. Additional arguments can be directly passed to HarmonyMatrix() in the function via the additional parameters (...) . See ?addHarmony() for more details. Users should be aware of the caveats of batch correction for their particular application. projHeme2 &lt;- addHarmony( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;Harmony&quot;, groupBy = &quot;Sample&quot; ) ## Transposing data matrix ## Initializing state using k-means centroids initialization ## Harmony 1/10 ## Harmony 2/10 ## Harmony 3/10 ## Harmony converged after 3 iterations This process creates a new reducedDims object called “Harmony” in our projHeme2 object. For downstream functions where you would like to use this new reducedDims object, you should make sure to pass it to the reducedDims paramter, for example with addImputeWeights() or other functions that use a reducedDims object. In the context of this tutorial, the data does not really benefit from batch correction so we will continue to use the IterativeLSI reducedDims object. "],["clustering-with-archr.html", "Chapter 7 Clustering with ArchR", " Chapter 7 Clustering with ArchR Most single-cell clustering methods focus on computing nearest neighbor graphs in reduced dimensions and then identifying “communities” or clusters of cells. These approaches work extremely well and are a standard practice in scRNA-seq. For this reason, ArchR uses existing state-of-the-art clustering methods from scRNA-seq packages for clustering. "],["clustering-using-seurats-findclusters-function.html", "7.1 Clustering using Seurat’s FindClusters() function", " 7.1 Clustering using Seurat’s FindClusters() function We have had the most success using the graph clustering approach implemented by Seurat. In ArchR, clustering is performed using the addClusters() function which permits additional clustering parameters to be passed to the Seurat::FindClusters() function via .... In our hands, clustering using Seurat::FindClusters() is deterministic, meaning that the exact same input will always result in the exact same output. projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;Seurat&quot;, name = &quot;Clusters&quot;, resolution = 0.8 ) ## ArchR logging to : ArchRLogs/ArchR-addClusters-93b04e914-Date-2025-02-06_Time-01-01-27.957006.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:01:28.578552 : Running Seurats FindClusters (Stuart et al. Cell 2019), 0.001 mins elapsed. ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10250 ## Number of edges: 458538 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8668 ## Number of communities: 12 ## Elapsed time: 1 seconds ## 2025-02-06 01:01:47.388466 : Testing Outlier Clusters, 0.314 mins elapsed. ## 2025-02-06 01:01:47.394136 : Assigning Cluster Names to 12 Clusters, 0.315 mins elapsed. ## 2025-02-06 01:01:47.422364 : Finished addClusters, 0.315 mins elapsed. To access these clusters we can use the $ accessor which shows the cluster ID for each single cell. head(projHeme2$Clusters) ## [1] &quot;C9&quot; &quot;C11&quot; &quot;C4&quot; &quot;C4&quot; &quot;C4&quot; &quot;C7&quot; We can tabulate the number of cells present in each cluster: table(projHeme2$Clusters) ## ## C1 C10 C11 C12 C2 C3 C4 C5 C6 C7 C8 C9 ## 1532 903 1250 633 1120 314 351 386 702 1261 1377 421 To better understand which samples reside in which clusters, we can create a cluster confusion matrix across each sample using the confusionMatrix() function. cM &lt;- confusionMatrix(paste0(projHeme2$Clusters), paste0(projHeme2$Sample)) cM ## 12 x 3 sparse Matrix of class &quot;dgCMatrix&quot; ## scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## C9 254 5 162 ## C11 1202 . 48 ## C4 351 . . ## C7 310 940 11 ## C1 1489 10 33 ## C6 171 531 . ## C8 139 1238 . ## C12 86 . 547 ## C3 160 144 10 ## C10 322 . 581 ## C2 117 2 1001 ## C5 88 298 . To plot this confusion matrix as a heatmap, we use the pheatmap package: library(pheatmap) cM &lt;- cM / Matrix::rowSums(cM) p &lt;- pheatmap::pheatmap( mat = as.matrix(cM), color = paletteContinuous(&quot;whiteBlue&quot;), border_color = &quot;black&quot; ) p There are times where the relative location of cells within the 2-dimensional embedding does not agree perfectly with the identified clusters. More explicitly, cells from a single cluster may appear in multiple different areas of the embedding. In these contexts, it may be appropriate to adjust the clustering parameters or embedding parameters until there is agreement between the two. "],["clustering-using-scran.html", "7.2 Clustering using scran", " 7.2 Clustering using scran Additionally, ArchR allows for the identification of clusters with scran by changing the method parameter in addClusters(). projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;scran&quot;, name = &quot;ScranClusters&quot;, k = 15 ) ## ArchR logging to : ArchRLogs/ArchR-addClusters-973a2c43-Date-2025-02-06_Time-01-01-47.534412.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:01:49.387429 : Running Scran SNN Graph (Lun et al. F1000Res. 2016), 0.022 mins elapsed. ## 2025-02-06 01:01:50.742487 : Identifying Clusters (Lun et al. F1000Res. 2016), 0.045 mins elapsed. ## 2025-02-06 01:06:24.969245 : Testing Outlier Clusters, 4.615 mins elapsed. ## 2025-02-06 01:06:24.975199 : Assigning Cluster Names to 9 Clusters, 4.616 mins elapsed. ## 2025-02-06 01:06:25.046268 : Finished addClusters, 4.617 mins elapsed. "],["single-cell-embeddings.html", "Chapter 8 Single-cell Embeddings", " Chapter 8 Single-cell Embeddings In ArchR, embeddings, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE), are used to visualize single cells in reduced dimension space. These embeddings each have distinct advantages and disadvantages. We call these “embeddings” because they are strictly used to visualize the clusters and are not used to identify clusters which is done in an LSI sub-space as mentioned in previous chapters. The primary difference between UMAP and t-SNE is the interpretatino of the distance between cells or clusters. t-SNE is designed to preserve the local structure in the data while UMAP is designed to preserve both the local and most of the global structure in the data. In theory, this means that the distance between two clusters is not informative in t-SNE but is informative in UMAP. For example, t-SNE does not allow you to say that Cluster A is more similar to Cluster B than it is to Cluster C based on the observation that Cluster A is located closer to Cluster B than Cluster C on the t-SNE. UMAP, on the other hand, is designed to permit this type of comparison, though it is worth noting that UMAP is a new enough method that this is still being flushed out in the literature. It is important to note that neither t-SNE nor UMAP are naturally deterministic (same input always gives exactly the same output). However, t-SNE shows much more randomness across multiple replicates of the same input than does UMAP. Moreover, UMAP as implemented in the uwot package is effectively deterministic when using the same random seed. The choice of whether to use UMAP or t-SNE is nuanced but in our hands, UMAP works very well for a diverse set of applications and this is our standard choice for scATAC-seq data. UMAP also performs faster than t-SNE. Perhaps most importantly, with UMAP you can create an embedding and project new samples into that embedding and this is not possible with t-SNE because the fitting and prediction of data happens simultaneously. Regardless of which method you choose, the input parameters can have drastic effects on the resulting embedding. Because of this, it is important to understand the various input parameters and to tweak these to best meet the needs of your own data. ArchR implements a default set of input parameters that work for most applications but there is really no single set of parameters that will produce the desired results for datasets that vary greatly in cell number, complexity, and quality. "],["uniform-manifold-approximation-and-projection-umap.html", "8.1 Uniform Manifold Approximation and Projection (UMAP)", " 8.1 Uniform Manifold Approximation and Projection (UMAP) To run UMAP in ArchR we use the addUMAP() function: projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;UMAP&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) ## 01:06:36 UMAP embedding parameters a = 0.583 b = 1.334 ## 01:06:36 Read 10250 rows and found 30 numeric columns ## 01:06:36 Using Annoy for neighbor search, n_neighbors = 30 ## 01:06:36 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 01:06:36 Writing NN index file to temp file /tmp/RtmpCdKDaq/file9126e1277 ## 01:06:36 Searching Annoy index using 12 threads, search_k = 3000 ## 01:06:37 Annoy recall = 100% ## 01:06:38 Commencing smooth kNN distance calibration using 12 threads with target n_neighbors = 30 ## 01:06:40 Initializing from normalized Laplacian + noise (using RSpectra) ## 01:06:40 Commencing optimization for 200 epochs, with 467192 positive edges ## 01:06:45 Optimization finished ## 01:06:45 Creating temp model dir /tmp/RtmpCdKDaq/dir9755e01b4 ## 01:06:45 Creating dir /tmp/RtmpCdKDaq/dir9755e01b4 ## 01:06:57 Changing to /tmp/RtmpCdKDaq/dir9755e01b4 ## 01:06:57 Creating /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme1/Embeddings/Save-Uwot-UMAP-Params-IterativeLSI-92066cb76-Date-2025-02-06_Time-01-06-45.092175.tar You can list the available embeddings objects in an ArchRProject using the slot extraction opperator @: projHeme2@embeddings ## List of length 1 ## names(1): UMAP To plot the UMAP results, we use the plotEmbedding() function and pass the name of the UMAP embedding we just generated (“UMAP”). We can tell ArchR how to color the cells by using a combination of colorBy which tells ArchR which matrix to use to find the specified metadata column provided to name. p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9465835ee-Date-2025-02-06_Time-01-06-58.909634.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9465835ee-Date-2025-02-06_Time-01-06-58.909634.log Instead of coloring by “Sample” as above, we can color by “Clusters” which were identified in a previous chapter. p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-91ae2de6e-Date-2025-02-06_Time-01-07-00.236292.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-91ae2de6e-Date-2025-02-06_Time-01-07-00.236292.log We can visualize these two plots side by side using the ggAlignPlots() function, specifying a horizontal orientation using type = \"h\". ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! We can also use plotEmbedding() to visualize the results from clustering using scran: p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-97d2c7786-Date-2025-02-06_Time-01-07-06.523391.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-97d2c7786-Date-2025-02-06_Time-01-07-06.523391.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9769393fd-Date-2025-02-06_Time-01-07-07.846988.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9769393fd-Date-2025-02-06_Time-01-07-07.846988.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! "],["t-stocastic-neighbor-embedding-t-sne.html", "8.2 t-Stocastic Neighbor Embedding (t-SNE)", " 8.2 t-Stocastic Neighbor Embedding (t-SNE) To run t-SNE in ArchR we use the addTSNE() function: projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;TSNE&quot;, perplexity = 30 ) ## Read the 10250 x 30 data matrix successfully! ## OpenMP is working. 8 threads. ## Using no_dims = 2, perplexity = 30.000000, and theta = 0.500000 ## Computing input similarities... ## Building tree... ## - point 10000 of 10250 ## Done in 2.88 seconds (sparsity = 0.013336)! ## Learning embedding... ## Iteration 50: error is 96.107250 (50 iterations in 2.20 seconds) ## Iteration 100: error is 84.311951 (50 iterations in 2.32 seconds) ## Iteration 150: error is 81.621430 (50 iterations in 2.23 seconds) ## Iteration 200: error is 81.006119 (50 iterations in 2.26 seconds) ## Iteration 250: error is 80.709628 (50 iterations in 2.32 seconds) ## Iteration 300: error is 3.240719 (50 iterations in 2.12 seconds) ## Iteration 350: error is 2.991369 (50 iterations in 2.05 seconds) ## Iteration 400: error is 2.856670 (50 iterations in 2.06 seconds) ## Iteration 450: error is 2.771442 (50 iterations in 2.05 seconds) ## Iteration 500: error is 2.710819 (50 iterations in 2.04 seconds) ## Iteration 550: error is 2.664889 (50 iterations in 2.02 seconds) ## Iteration 600: error is 2.628754 (50 iterations in 2.06 seconds) ## Iteration 650: error is 2.600625 (50 iterations in 2.15 seconds) ## Iteration 700: error is 2.577976 (50 iterations in 2.08 seconds) ## Iteration 750: error is 2.559499 (50 iterations in 2.07 seconds) ## Iteration 800: error is 2.544428 (50 iterations in 2.08 seconds) ## Iteration 850: error is 2.531595 (50 iterations in 2.05 seconds) ## Iteration 900: error is 2.521211 (50 iterations in 2.09 seconds) ## Iteration 950: error is 2.512387 (50 iterations in 2.08 seconds) ## Iteration 1000: error is 2.505024 (50 iterations in 2.11 seconds) ## Fitting performed in 42.44 seconds. Similar to UMAP, we can plot the t-SNE embedding using plotEmbedding(). The same parameters apply to colorBy and name regardless of which type of embedding is being used. p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-965d8d97c-Date-2025-02-06_Time-01-07-22.337093.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-965d8d97c-Date-2025-02-06_Time-01-07-22.337093.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-97d30408f-Date-2025-02-06_Time-01-07-23.537508.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-97d30408f-Date-2025-02-06_Time-01-07-23.537508.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-TSNE-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! As we did with UMAP, we can compare the clustering results from Seurat::FindClusters() with the results of clusering with scran: p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-960f29936-Date-2025-02-06_Time-01-07-28.667797.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-960f29936-Date-2025-02-06_Time-01-07-28.667797.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-97aee90f5-Date-2025-02-06_Time-01-07-30.061919.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-97aee90f5-Date-2025-02-06_Time-01-07-30.061919.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-tSNE-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! "],["dimensionality-reduction-after-harmony.html", "8.3 Dimensionality Reduction After Harmony", " 8.3 Dimensionality Reduction After Harmony In a previous chapter, we performed batch correction using Harmony via the addHarmony() function, creating a reducedDims object named “Harmony”. We can assess the effects of Harmony by visualizing the embedding using UMAP or t-SNE and comparing this to the embeddings visualized in the previous sections for iterative LSI. Repeating the UMAP embedding with the same parameters but for the “Harmony” reducedDims object: projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;UMAPHarmony&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) ## 01:07:36 UMAP embedding parameters a = 0.583 b = 1.334 ## 01:07:36 Read 10250 rows and found 30 numeric columns ## 01:07:36 Using Annoy for neighbor search, n_neighbors = 30 ## 01:07:36 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 01:07:36 Writing NN index file to temp file /tmp/RtmpCdKDaq/file923d7b457 ## 01:07:36 Searching Annoy index using 12 threads, search_k = 3000 ## 01:07:37 Annoy recall = 100% ## 01:07:38 Commencing smooth kNN distance calibration using 12 threads with target n_neighbors = 30 ## 01:07:40 Initializing from normalized Laplacian + noise (using RSpectra) ## 01:07:40 Commencing optimization for 200 epochs, with 470210 positive edges ## 01:07:44 Optimization finished ## 01:07:44 Creating temp model dir /tmp/RtmpCdKDaq/dir9102aa005 ## 01:07:44 Creating dir /tmp/RtmpCdKDaq/dir9102aa005 ## 01:07:56 Changing to /tmp/RtmpCdKDaq/dir9102aa005 ## 01:07:56 Creating /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme1/Embeddings/Save-Uwot-UMAP-Params-Harmony-944036e93-Date-2025-02-06_Time-01-07-44.721748.tar p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAPHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9a577cc-Date-2025-02-06_Time-01-07-58.776653.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9a577cc-Date-2025-02-06_Time-01-07-58.776653.log p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAPHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9667e5148-Date-2025-02-06_Time-01-08-00.101279.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9667e5148-Date-2025-02-06_Time-01-08-00.101279.log ggAlignPlots(p3, p4, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;Plot-UMAP2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! And the same for t-SNE: projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;TSNEHarmony&quot;, perplexity = 30 ) ## Read the 10250 x 30 data matrix successfully! ## OpenMP is working. 8 threads. ## Using no_dims = 2, perplexity = 30.000000, and theta = 0.500000 ## Computing input similarities... ## Building tree... ## - point 10000 of 10250 ## Done in 3.96 seconds (sparsity = 0.013643)! ## Learning embedding... ## Iteration 50: error is 95.902970 (50 iterations in 2.25 seconds) ## Iteration 100: error is 87.051912 (50 iterations in 2.35 seconds) ## Iteration 150: error is 84.526702 (50 iterations in 2.27 seconds) ## Iteration 200: error is 84.307969 (50 iterations in 2.23 seconds) ## Iteration 250: error is 84.304736 (50 iterations in 2.19 seconds) ## Iteration 300: error is 3.461251 (50 iterations in 2.22 seconds) ## Iteration 350: error is 3.197965 (50 iterations in 2.14 seconds) ## Iteration 400: error is 3.059166 (50 iterations in 2.13 seconds) ## Iteration 450: error is 2.969836 (50 iterations in 2.13 seconds) ## Iteration 500: error is 2.906957 (50 iterations in 2.10 seconds) ## Iteration 550: error is 2.861397 (50 iterations in 2.12 seconds) ## Iteration 600: error is 2.825782 (50 iterations in 2.14 seconds) ## Iteration 650: error is 2.797092 (50 iterations in 2.13 seconds) ## Iteration 700: error is 2.773688 (50 iterations in 2.10 seconds) ## Iteration 750: error is 2.754990 (50 iterations in 2.09 seconds) ## Iteration 800: error is 2.739997 (50 iterations in 2.11 seconds) ## Iteration 850: error is 2.728881 (50 iterations in 2.14 seconds) ## Iteration 900: error is 2.720387 (50 iterations in 2.09 seconds) ## Iteration 950: error is 2.713294 (50 iterations in 2.11 seconds) ## Iteration 1000: error is 2.708060 (50 iterations in 2.08 seconds) ## Fitting performed in 43.13 seconds. p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNEHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9e59fa7-Date-2025-02-06_Time-01-08-17.156208.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9e59fa7-Date-2025-02-06_Time-01-08-17.156208.log p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNEHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-96198d9ca-Date-2025-02-06_Time-01-08-18.406349.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-96198d9ca-Date-2025-02-06_Time-01-08-18.406349.log ggAlignPlots(p3, p4, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;Plot-TSNE2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! "],["highlighting-specific-cells-on-an-embedding.html", "8.4 Highlighting specific cells on an embedding", " 8.4 Highlighting specific cells on an embedding ArchR also allows you to highlight specific cells on the embedding using the highlightCells parameter by passing the cell names of the desired cells to be highlighted. For example, we could highlight just the cells corresponding to cluster C1 by passing the cell names corresponding to those cells. plotEmbedding( ArchRProj = projHeme2, embedding = &quot;UMAP&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, size = 1, sampleCells = NULL, highlightCells = getCellNames(ArchRProj = projHeme2)[which(projHeme2@cellColData$Clusters == &quot;C1&quot;)], baseSize = 10, plotAs = &quot;points&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-91f990514-Date-2025-02-06_Time-01-08-26.466518.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-91f990514-Date-2025-02-06_Time-01-08-26.466518.log By default, ArchR colors these highlighted cells red. However, you can change the highlighted cell color using the pal paramter. To do this, you must pass a named vector that includes the name of the highlighted cells (“C1”), and another color designated by “Non.Highlighted”. plotEmbedding( ArchRProj = projHeme2, embedding = &quot;UMAP&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, size = 1, pal=c(&quot;C1&quot; = &quot;#50ADF9&quot;, &quot;Non.Highlighted&quot; = &quot;lightgrey&quot;), sampleCells = NULL, highlightCells = getCellNames(ArchRProj = projHeme2)[which(projHeme2@cellColData$Clusters == &quot;C1&quot;)], baseSize = 10, plotAs = &quot;points&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-97f61fa14-Date-2025-02-06_Time-01-08-29.438092.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-97f61fa14-Date-2025-02-06_Time-01-08-29.438092.log You can use this highlightCells parameter in conjuction with other data stored in your ArchRProject, for example colorBy = \"GeneScoreMatrix\". plotEmbedding( ArchRProj = projHeme2, embedding = &quot;UMAP&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CD14&quot;, size = 1, sampleCells = NULL, highlightCells = getCellNames(ArchRProj = projHeme2)[which(projHeme2@cellColData$Clusters %in% c(&quot;C1&quot;,&quot;C2&quot;,&quot;C7&quot;,&quot;C8&quot;,&quot;C9&quot;))], baseSize = 10, plotAs = &quot;points&quot;) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-98faac6d-Date-2025-02-06_Time-01-08-32.490955.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 01:08:33.369285 : ## ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-98faac6d-Date-2025-02-06_Time-01-08-32.490955.log "],["importing-an-embedding-from-external-software.html", "8.5 Importing an embedding from external software", " 8.5 Importing an embedding from external software If you have analyzed data using another package, you can always import your embedding coordinates into ArchR. To do this, you need to create the various attributes that ArchR expects of an embedding and then add this to the embeddings slot of your ArchRProject. The key component of an embedding in ArchR is a DataFrame that contains the cell names and the embedding coordinates of each cell. In the below example, we will randomly generate arbitrary UMAP coordinates for all of the cells in projHeme5 but in your own application you would need to provide UMAP coordinates ordered in the same order as returned by getCellNames(). #simulate mock UMAP data by random sampling umap1 &lt;- (sample(x = -100000:100000, size = length(getCellNames(projHeme2)), replace = FALSE))/10000 umap2 &lt;- (sample(x = -100000:100000, size = length(getCellNames(projHeme2)), replace = FALSE))/10000 #add embedding to projHeme2 umap_df &lt;- DataFrame(row.names = getCellNames(projHeme2), &quot;custom#UMAP1&quot; = umap1, &quot;custom#UMAP2&quot; = umap2, check.names = FALSE) projHeme2@embeddings$customUMAP &lt;- SimpleList(df = umap_df, params = list()) With this, we would be able to use this embedding by name as with any other embedding in our ArchRProject. It is important to note that the embedding coordinate column names (i.e \"custom#UMAP1\" and \"custom#UMAP2\" in the example above) must contain the # in the name as this is used in string splitting operations in plotEmbedding() and other functions. getEmbedding(ArchRProj = projHeme2, embedding = &quot;customUMAP&quot;) ## DataFrame with 10250 rows and 2 columns ## custom#UMAP1 custom#UMAP2 ## &lt;numeric&gt; &lt;numeric&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 8.0523 4.0882 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 9.5409 -1.0883 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 -2.0659 -0.2871 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 7.0213 2.7621 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 -9.3855 7.6017 ## ... ... ... ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 1.5187 0.0296 ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 0.0526 -9.3273 ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 -2.9732 4.4179 ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 -5.9111 3.7804 ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 0.5146 -2.9185 "],["gene-scores-and-marker-genes-with-archr.html", "Chapter 9 Gene Scores and Marker Genes with ArchR", " Chapter 9 Gene Scores and Marker Genes with ArchR While ArchR is able to robustly call clusters, it is not possible to know a priori which cell type is represented by each cluster. This task is often left to manual annotation because every application is different. There are, of course, new tools that help to do this annotation but these have largely been designed with scRNA-seq in mind. To do this cell type annotation when we only have scATAC-seq data available, we use prior knowledge of cell type-specific marker genes and we estimate gene expression for these genes from our chromatin accessibility data by uing gene scores. A gene score is essentially a prediction of how highly expressed a gene will be based on the accessibility of regulatory elements in the vicinity of the gene. To create these gene scores, ArchR allows for the use of complex user-supplied custom distance-weighted accessibility models. In addition to gene scores, we can also use module scores which allow you to group multiple features (e.g. genes or peaks) together to create more refined cell group definitions. "],["calculating-gene-scores-in-archr.html", "9.1 Calculating Gene Scores in ArchR", " 9.1 Calculating Gene Scores in ArchR In our publication, we tested over 50 different gene score models and identified a class of models that consistently outperformed the rest across a variety of test conditions. This class of model, which is implemented as the default in ArchR, has three major components: Accessibility within the entire gene body contributes to the gene score. An exponential weighting function that accounts for the activity of putative distal regulatory elements in a distance-dependent fashion. Imposed gene boundaries that minimizes the contribution of unrelated regulatory elements to the gene score. So how does ArchR calculate gene scores? For each chromosome, ArchR creates a tile matrix using a user-defined tile size that is not pre-computed (default is 500 bp), overlaps these tiles with the user-defined gene window (default is 100 kb on either side of the gene), and then computes the distance from each tile (start or end) to the gene body (with optional extensions upstream or downstream) or gene start. We have found that the best predictor of gene expression is the local accessibility of the gene region which includes the promoter and gene body. As mentioned above, to properly account for distal accessibility for a given gene, ArchR identifies the subset of tiles that are within the gene window and do not cross another gene region. This filtering allows for inclusion of distal regulatory elements that could improve the accuracy of predicting gene expression values but excludes regulatory elements more likely to be associated with another gene (for ex. the promoter of a nearby gene). The distance from each tile to the gene is then converted to a distance weight using a user-defined accessibility model (default is e(-abs(distance)/5000) + e-1). When the gene body is included in the gene region (where the distance-based weight is the maximum weight possible), we found that extremely large genes can bias the overall gene scores. In these cases, the total gene scores can vary substantially due to the inclusion of insertions in both introns and exons. To help adjust for these large differences in gene size, ArchR applies a separate weight for the inverse of the gene size (1 / gene size) and scales this inverse weight linearly from 1 to a user-defined hard maximum (default of 5). Smaller genes thus receive larger relative weights, partially normalizing this length effect. The corresponding distance and gene size weights are then multiplied by the number of Tn5 insertions within each tile and summed across all tiles within the gene window, while still accounting for nearby gene regions as described above. This summed accessibility is a “gene score” and is depth normalized across all genes to a user-defined constant (default of 10,000). Computed gene scores are then stored in the corresponding Arrow file for downstream analyses. To illustrate what the default ArchR gene score model looks like, we provide this toy example showing the weighting applied across the entire gene region: Gene scores are calculated for each Arrow file at the time of creation if the parameter addGeneScoreMat is set to TRUE - this is the default behavior. If you wish to change any of the default parameters for gene score calculation during Arrow file creation, you can use the GeneScoreMatParams parameter. By default, gene scores are depth normalized based on the scaleTo parameter. If you do not wish to add gene scores to your Arrow file at the time of creation, gene scores can be added to Arrow files at any time by using the addGeneScoreMatrix() function. Gene scores are stored in a matrix within each Arrow file called “GeneScoreMatrix”. Once caluclated, gene scores can be used for many different analyses. For example, individual cells of an embedding can be colored by their gene scores to help with the identification of various cell types. We illustrate the application of gene scores throughout the rest of this chapter. It is important to note that not all genes behave well with gene scores. In particular, genes that reside in very gene-dense areas can be problematic. Thus, it is always best to sanity check all gene score analyses by looking at sequencing tracks which is described in a later chapter. "],["identification-of-marker-features.html", "9.2 Identification of Marker Features", " 9.2 Identification of Marker Features In addition to using prior knowledge of relevant marker genes for annotation of clusters, ArchR enables unbiased identification of marker features for any given cell groupings (for example, clusters). These features can be anything - peaks, genes (based on gene scores), or transcription factor motifs (based on chromVAR deviations). ArchR does this using the getMarkerFeatures() function which can take as input any matrix via the useMatrix parameter and it identifies features unique to the groups indicated by the groupBy parameter. If the useMatrix parameter is set to “GeneScoreMatrix”, then the function will identify the genes that appear to be uniquely active in each cell type. This provides an unbiased way of seeing which genes are predicted to be active in each cluster and can aid in cluster annotation. As mentioned above, the same getMarkerFeatures() function can be used with any matrix stored in the Arrow files to identify features that are specific to certain cell groups. This is accomplished via the useMatrix parameter. For example, useMatrix = \"TileMatrix\" would identify genomic regions that are highly specific to a certain cell group and useMatrix = \"PeakMatrix\" would identify peaks that are highly specific to a certain cell group. Examples of how to use the getMarkerFeatures() function on other feature types are provided in later chapters. 9.2.1 How does marker feature identification happen? This process of marker feature identification hinges on the selection of a group of bias-matched background cells for each cell group. Across all features, each cell group is compared to its own background group of cells to determine if the given cell group has significantly higher accessibility. The selection of these background cell groups is critical to the success of this process and is performed across the multi-dimensional space provided by the user via the bias argument to getMarkerFeatures(). For each cell in the cell group, ArchR finds the nearest neighbor cell across the provided multi-dimensional space that is not a member of the given cell group and adds it to the background group of cells. In this way, ArchR creates a group of bias-matched cells that is as similar as possible to the given cell group, thus enabling a more robust determination of significance even if the group of cells is small. The way ArchR does this is by taking all of the dimensions provided via the bias parameter and quantile normalizing their values to distribute the variance of each dimension across the same relative scale. Taking a toy example, if the parameters TSS and log10(Num Fragments) were provided to bias, the pre-quantile normalized values might look like this: Here, the relative variance across the y-axis is very small compared to the variance across the x-axis. If we normalize these axes so that their values range from 0 to 1 instead, we make the relative variance much more equal. Importantly, we also change the nearest neighbors dramatically as indicated to the right of this plot. ArchR normalizes all of the dimensions and uses euclidean distance in this normalized multidimensional space to find the nearest neighbors. "],["identifying-marker-genes.html", "9.3 Identifying Marker Genes", " 9.3 Identifying Marker Genes To identify marker genes based on gene scores, we call the getMarkerFeatures() function with useMatrix = \"GeneScoreMatrix\". We specify that we want to know the cluster-specific features with groupBy = \"Clusters\" which tells ArchR to use the “Clusters” column in cellColData to stratify cell groups. markersGS &lt;- getMarkerFeatures( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, groupBy = &quot;Clusters&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-930080ad0-Date-2025-02-06_Time-01-08-45.467915.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Double.Matrix ## 2025-02-06 01:08:46.30961 : Matching Known Biases, 0.003 mins elapsed. ## ########### ## 2025-02-06 01:10:24.870633 : Completed Pairwise Tests, 1.646 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-930080ad0-Date-2025-02-06_Time-01-08-45.467915.log This function returns a SummarizedExperiment object containing relevant information on the marker features identified. This type of return value is common in ArchR and is one of the key ways that ArchR enables downstream data analysis. SummarizedExperiment objects are similar to a matrix where rows represent features of interest (i.e. genes) and columns represent samples. A SummarizedExperiment object contains one or more assays, each represented by a matrix-like object of numeric data, and metadata that applies to the rows or columns of the assays matrices. It is beyond the scope of this tutorial to dive into SummarizedExperiment objects but check out the bioconductor page if you need more information. We can get a list of DataFrame objects, one for each of our clusters, containing the relevant marker features using the getMarkers() function: markerList &lt;- getMarkers(markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;) markerList$C6 ## DataFrame with 460 rows and 9 columns ## seqnames start end strand name idx Log2FC ## &lt;Rle&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;numeric&gt; ## 14724 chr22 33454377 32908540 2 SYN3 266 1.50383 ## 7180 chr15 33603177 34158303 1 RYR3 143 1.61610 ## 15180 chr3 37493813 37861281 1 ITGA9 190 1.42296 ## 730 chr1 47655771 47649261 2 PDZK1IP1 730 2.31953 ## 4691 chr12 6055398 5671817 2 ANO2 53 1.66399 ## ... ... ... ... ... ... ... ... ## 4722 chr12 6949118 6956557 1 GNB3 84 1.72832 ## 12015 chr19 58180303 58190520 1 ZSCAN4 1563 1.30289 ## 17723 chr5 135528851 135527156 2 SMIM32 583 1.57534 ## 18899 chr6 78173120 78171948 2 HTR1B 740 1.25133 ## 22727 chrX 101112549 101087085 2 NXF5 510 1.82215 ## FDR MeanDiff ## &lt;numeric&gt; &lt;numeric&gt; ## 14724 1.00235e-28 1.258169 ## 7180 1.12058e-22 0.913549 ## 15180 6.17469e-21 0.908384 ## 730 1.52549e-20 0.758720 ## 4691 1.52549e-20 0.588930 ## ... ... ... ## 4722 0.00934267 0.2275534 ## 12015 0.00940705 0.0876258 ## 17723 0.00941627 0.2378894 ## 18899 0.00960201 0.4154427 ## 22727 0.00987594 0.0780624 To visualize all of the marker features simultaneously, we can create a heatmap using the markerHeatmap() function, optionally supplying some marker genes to label on the heatmap via the labelMarkers parameter. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;EBF1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;CEBPB&quot;, &quot;MPO&quot;, #Monocytes &quot;IRF8&quot;, &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) heatmapGS &lt;- markerHeatmap( seMarker = markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;, labelMarkers = markerGenes, transpose = TRUE ) ## Warning in markerHeatmap(seMarker = markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;, : &#39;markerHeatmap&#39; is deprecated. ## Use &#39;plotMarkerHeatmap&#39; instead. ## See help(&quot;Deprecated&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotMarkerHeatmap-9e5e6cd4-Date-2025-02-06_Time-01-10-25.770159.log ## If there is an issue, please report to github with logFile! ## Printing Top Marker Genes: ## C1: ## LOC100288069, RBP7, ARHGEF10L, CELA3A, LINC01226, C1orf185, ZFYVE9, MIR1262, F3, HSD3BP4, SRGAP2D, SNX27, S100A9, FCGR2C, MIR556 ## C2: ## PERM1, RHD, FGR, PPIEL, BTBD19, TCTEX1D4, L1TD1, MIR3671, GPR88, CASQ2, NHLH2, SLC22A15, IGSF3, FCGR1CP, LINC00869 ## C3: ## FAM131C, PLA2G5, IFNLR1, NCMAP, TSPAN1, TTC39A, SLC25A3P1, GBP1P1, GFI1, LOC100129046, S100A4, S100A16, BCAN, FCRL5, FCRL4 ## C4: ## LINC01342, MAD2L2, LDLRAP1, ITGB3BP, PGM1, ROR1, TTC24, FCRLB, MIR1231, KLHDC8A, LYPLAL1, PGBD5, OPN3, OR2L13, ZNF22 ## C5: ## TTLL10, KAZN, TFAP2E, RIMS3, TRABD2B, PGLYRP3, UCK2, TNR, KIAA1614, LEMD1, SERTAD4-AS1, CCDC3, DEPP1, PRKG1-AS1, SH2D4B ## C6: ## PAX7, RPS14P3, FAM43B, MIR378F, GRHL3, TRIM63, GJA4, RHBDL2, PPIE, MPL, PDZK1IP1, FOXE3, DNAJC6, OLFM3, PHTF1 ## C7: ## CFAP74, MIR34A, DMRTB1, MGAT4EP, LOC148709, EIF5AL1, RASSF10, SLC6A5, MIR4488, LRRC10B, SHANK2-AS1, CACNA1C-AS4, DCLK1, HTR2A, LRRC36 ## C8: ## LINC02593, PRDM16, MIR4251, MIR4689, TMEM51-AS1, PADI3, NBL1, RAP1GAP, LDLRAD2, HSPG2, MIR4253, CATSPER4, FAM229A, EPHA10, EDN2 ## C9: ## ID3, CNR2, BEND5, SHISAL2A, CLCA3P, LOC729970, TMEM56, MFSD14A, LRRC39, SLC16A4, DRAM2, PIFO, FCRL3, FCRL2, DNM3OS ## C10: ## MMP23B, RUNX3, IL12RB2, GBP2, GBP5, LOC729930, TGFBR3, VCAM1, HIST2H2BA, FCGR1B, CD160, PDZK1, SH2D2A, NTRK1, PYHIN1 ## C11: ## RCAN3AS, CRYBG2, PPP1R8, LCK, HOOK1, SYDE2, SNORD21, CHI3L2, CD2, HSPA7, BLZF1, SELL, RNU6-72P, PRKCQ-AS1, TAF3 ## C12: ## SNORA59B, C1orf194, AMIGO1, GPR61, CRABP2, GAS5-AS1, POLR2G, ZPR1, RPL13P5, PIP4K2C, DTX3, LINC02291, MTRNR2L4, TNK1, HOXB2 ## Identified 2736 markers! ## [1] &quot;CD34&quot; &quot;GATA1&quot; &quot;PAX5&quot; &quot;MS4A1&quot; &quot;EBF1&quot; &quot;MME&quot; &quot;CD14&quot; &quot;CEBPB&quot; &quot;MPO&quot; ## [10] &quot;IRF8&quot; &quot;CD3D&quot; &quot;CD8A&quot; &quot;TBX21&quot; &quot;IL7R&quot; ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotMarkerHeatmap-9e5e6cd4-Date-2025-02-06_Time-01-10-25.770159.log To plot this heatmap, we can use the ComplexHeatmap::draw() function because the heatmapGS object is actually a list of heatmaps: ComplexHeatmap::draw(heatmapGS, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) Many heatmaps in ArchR utilize the ComplexHeatmap package which provides a very versatile and flexible framework for plotting heatmaps. If you need to change something about how the heatmap looks when plotted, you should consult the documentation for ComplexHeatmap. For example, if you want to change the order in which the heatmap rows are plotted, you can edit the row_order slot of the heatmap object and re-plot it: heatmapGS@row_order &lt;- c(10,11,12,3,4,5,1,2,6,8,7,9) ComplexHeatmap::draw(heatmapGS, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(heatmapGS, name = &quot;GeneScores-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE) ## Plotting ComplexHeatmap! "],["visualizing-marker-genes-on-an-embedding.html", "9.4 Visualizing Marker Genes on an Embedding", " 9.4 Visualizing Marker Genes on an Embedding As mentioned previously, we can overlay per-cell gene scores on our UMAP embedding. This is accomplished using the colorBy and name parameters in the plotEmbedding() function. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;MPO&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;#TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, quantCut = c(0.01, 0.95), imputeWeights = NULL ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-91d1e5960-Date-2025-02-06_Time-01-10-33.836416.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 01:10:34.763947 : ## ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-91d1e5960-Date-2025-02-06_Time-01-10-33.836416.log To plot a specific gene, we can subset this plot list: p$CD14 To plot all genes we can use cowplot to arrange the various marker genes into a single plot. p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-WO-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! "],["marker-genes-imputation-with-magic.html", "9.5 Marker Genes Imputation with MAGIC", " 9.5 Marker Genes Imputation with MAGIC In the previous section, you may have noticed that some of the gene score plots appear quite variable. This is because of the sparsity of scATAC-seq data. We can use MAGIC to impute gene scores by smoothing signal across nearby cells. In our hands, this greatly improves the visual interpretation of gene scores. ArchR doesnt actually use the code in MAGIC to do this (you do not need to install the Rmagic package) but instead we have reimplemented the workflow within ArchR. We use the addImputeWeights() function to add impute weights to our ArchRProject. projHeme2 &lt;- addImputeWeights(projHeme2) ## ArchR logging to : ArchRLogs/ArchR-addImputeWeights-9791fa7e5-Date-2025-02-06_Time-01-10-50.001361.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:10:50.402409 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. These impute weights can then be passed to plotEmbedding() when plotting gene scores overlayed on the UMAP embedding. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;MPO&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;#TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme2) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-96160df2b-Date-2025-02-06_Time-01-11-01.366962.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 01:11:02.279902 : ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-96160df2b-Date-2025-02-06_Time-01-11-01.366962.log As before, we can subset this plot list to select a specific gene. p$CD14 Or we can plot all the marker genes at once using cowplot. #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-W-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! "],["module-scores.html", "9.6 Module Scores", " 9.6 Module Scores The reliability of gene scores derived from chromatin accessibility is highly dependent on the particular gene being queried. For example, genes that exist in highly gene-dense regions of the genome can be harder to accurately represent with gene scores because the surrounding peaks may not be acting to regulate its gene expression. For this reason, it’s often best to use gene scores from multiple different genes to (for example) assign cluster identities. To facilitate this, ArchR enables the use of “modules” which are user-defined groups of features where the signal from each individual feature is combined using equal weights into a single module score. The per-cell values for each user-defined module are stored as a new column in the cellColData of the given ArchRProject. Module scores are added using the addModuleScore() function. The key parameters for this function are features and name. features is a named list of character vectors containing gene names while name is the broad title that will be given to each column added to cellColData features &lt;- list( BScore = c(&quot;MS4A1&quot;, &quot;CD79A&quot;, &quot;CD74&quot;), TScore = c(&quot;CD3D&quot;, &quot;CD8A&quot;, &quot;GZMB&quot;, &quot;CCR7&quot;, &quot;LEF1&quot;) ) projHeme2 &lt;- addModuleScore(projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, name = &quot;Module&quot;, features = features) ## ArchR logging to : ArchRLogs/ArchR-addModuleScore-949bff563-Date-2025-02-06_Time-01-11-20.31739.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:11:23.538133 : Computing Module 1 of 2, 0.045 mins elapsed. ## 2025-02-06 01:11:29.221096 : Computing Module 2 of 2, 0.14 mins elapsed. ## 2025-02-06 01:11:34.689282 : Finished Running addModuleScore, 0.231 mins elapsed. In this example, two columns will be added to cellColData named “Module.BScore” and “Module.TScore”. This is because the column name is derived as name.featureName. If your feature list is unnamed, then the columns in cellColData will be numbered instead (i.e. “Module1” and “Module2” if name=\"Module\" as above). The “BScore” module contains 3 gene markers of B cells (MS4A1, CD79A, and CD74) while the “TScore” module contains 5 gene markers for T cells (CD3D, CD8A, GZMB, CCR7, and LEF1). We can then plot these modules on an embedding. p1 &lt;- plotEmbedding(projHeme2, embedding = &quot;UMAP&quot;, colorBy = &quot;cellColData&quot;, name=&quot;Module.BScore&quot;, imputeWeights = getImputeWeights(projHeme2)) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-96f64069d-Date-2025-02-06_Time-01-11-34.704557.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-96f64069d-Date-2025-02-06_Time-01-11-34.704557.log p2 &lt;- plotEmbedding(projHeme2, embedding = &quot;UMAP&quot;, colorBy = &quot;cellColData&quot;, name=&quot;Module.TScore&quot;, imputeWeights = getImputeWeights(projHeme2)) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-94beecddb-Date-2025-02-06_Time-01-11-37.610721.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-94beecddb-Date-2025-02-06_Time-01-11-37.610721.log plotPDF(ggAlignPlots(p1,p2,draw=F,type=&quot;h&quot;)) ## Plotting Gtable! ## NULL Module scores can be calculated from any matrix present within your ArchRProject. "],["track-plotting-with-archrbrowser.html", "9.7 Track Plotting with ArchRBrowser", " 9.7 Track Plotting with ArchRBrowser In addition to plotting gene scores per cell as a UMAP overlay, we can browse the local chromatin accessibility at these marker genes on a per cluster basis with genome browser tracks. To do this, we use the plotBrowserTrack() function which will create a list of plots, one for each of the genes specified by markerGenes. This function will plot a single track for each group in the groupBy parameter. It is worth noting that the plotBrowserTrack() function plots “pseudobulk” level data from the single-cell ATAC-seq data by grouping many individual cells together. The cells selected are random and the number of cells selected and the cell groupings that can be displayed are based on the maxCells and minCells parameters respectively. As such, to ensure reproducibility of the functionality of the plotBrowserTrack() function, you should make sure to set a consistent seed for random number generation prior to plotting. set.seed(1) markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotBrowserTrack( ArchRProj = projHeme2, groupBy = &quot;Clusters&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000 ) ## ArchR logging to : ArchRLogs/ArchR-plotBrowserTrack-95e5e270a-Date-2025-02-06_Time-01-11-44.301082.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:11:44.862885 : Validating Region, 0.009 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ------- ## seqinfo: 24 sequences from hg19 genome ## 2025-02-06 01:11:44.944524 : Adding Bulk Tracks (1 of 9), 0.011 mins elapsed. ## 2025-02-06 01:11:46.220729 : Adding Gene Tracks (1 of 9), 0.032 mins elapsed. ## 2025-02-06 01:11:46.487447 : Plotting, 0.036 mins elapsed. ## 2025-02-06 01:11:47.326255 : Adding Bulk Tracks (2 of 9), 0.05 mins elapsed. ## 2025-02-06 01:11:48.464799 : Adding Gene Tracks (2 of 9), 0.069 mins elapsed. ## 2025-02-06 01:11:48.66636 : Plotting, 0.073 mins elapsed. ## 2025-02-06 01:11:49.401257 : Adding Bulk Tracks (3 of 9), 0.085 mins elapsed. ## 2025-02-06 01:11:50.629416 : Adding Gene Tracks (3 of 9), 0.106 mins elapsed. ## 2025-02-06 01:11:50.83043 : Plotting, 0.109 mins elapsed. ## 2025-02-06 01:11:51.666649 : Adding Bulk Tracks (4 of 9), 0.123 mins elapsed. ## 2025-02-06 01:11:52.899921 : Adding Gene Tracks (4 of 9), 0.143 mins elapsed. ## 2025-02-06 01:11:53.102382 : Plotting, 0.147 mins elapsed. ## 2025-02-06 01:11:53.699439 : Adding Bulk Tracks (5 of 9), 0.157 mins elapsed. ## 2025-02-06 01:11:54.92057 : Adding Gene Tracks (5 of 9), 0.177 mins elapsed. ## 2025-02-06 01:11:55.127522 : Plotting, 0.18 mins elapsed. ## 2025-02-06 01:11:55.908475 : Adding Bulk Tracks (6 of 9), 0.193 mins elapsed. ## 2025-02-06 01:11:57.065717 : Adding Gene Tracks (6 of 9), 0.213 mins elapsed. ## 2025-02-06 01:11:57.261955 : Plotting, 0.216 mins elapsed. ## 2025-02-06 01:11:58.039566 : Adding Bulk Tracks (7 of 9), 0.229 mins elapsed. ## 2025-02-06 01:11:59.264726 : Adding Gene Tracks (7 of 9), 0.249 mins elapsed. ## 2025-02-06 01:11:59.459458 : Plotting, 0.253 mins elapsed. ## 2025-02-06 01:12:00.214306 : Adding Bulk Tracks (8 of 9), 0.265 mins elapsed. ## 2025-02-06 01:12:01.394616 : Adding Gene Tracks (8 of 9), 0.285 mins elapsed. ## 2025-02-06 01:12:01.638163 : Plotting, 0.289 mins elapsed. ## 2025-02-06 01:12:02.455899 : Adding Bulk Tracks (9 of 9), 0.303 mins elapsed. ## 2025-02-06 01:12:03.573727 : Adding Gene Tracks (9 of 9), 0.321 mins elapsed. ## 2025-02-06 01:12:03.765006 : Plotting, 0.324 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-plotBrowserTrack-95e5e270a-Date-2025-02-06_Time-01-11-44.301082.log Here, the output of plotBrowserTrack() is a list of plots. To plot a track of a specific gene, we can select one from the list. grid::grid.newpage() grid::grid.draw(p$CD14) We can save a multi-page PDF with a single page for each gene locus in our plot list using the plotPDF() function. plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL The plotBrowserTrack() function is highly versatile and therefore has a lot of different parameter options so you should explore all of those capabilities in the function documentation. There are multiple different types of plot elements that can be plotted and these are controlled using the plotSummary parameter. Those options include: bulkTrack - A pseudobulk representation of the ATAC-seq signal in the given region scTrack - The per-cell integration signal scATAC-seq signal. Each row represents an individual cell. The number of cells plotted per cell grouping is controlled by the scCellsMax parameter featureTrack - Regions to be shown as blocks below the tracks (i.e peak regions, or SNPs, or some other feature geneTrack - Line diagrams of genes with introns and exons shown. We’ve adopted the convention of plotting “plus-stranded” genes (those that point left-to-right with the TSS on the left) in red and “minus-stranded” genes (those that point right-to-left with the TSS on the right) in blue. loopTrack - Arcs showing links between a peak and a gene, for example from co-accessibility or peak-to-gene linkage analysis. The actual loops plotted is controlled by the loops parameter. For example, instead of providing a set of genes to plot via geneSymbol, you could provide a set of regions to plot as a GRanges object to the region parameter. You can also change which regions are shown as “features” by manipulating the features paramter. The default is to show the peakSet of your ArchRProject but you can provide a GRanges (for a single feature track) or a named GRangesList (for multiple feature tracks). If you provide a GRangesList, its best to provide a named list because the names will be used to label the individual feature tracks on the plot. By default, the pseudobulk ATAC-seq tracks will be normalized based on ReadsInTSS (from cellColData) but this can be changed via the normMethod parameter if desired. Lastly, you can highlight specific regions in the plots using the hightlight and highlightFill paramters. There are tons of ways to use the plotBrowserTrack() function, far more than can be adequately reviewed in this manual so take the time to explore. "],["launching-the-interactive-archrbrowser.html", "9.8 Launching the Interactive ArchRBrowser", " 9.8 Launching the Interactive ArchRBrowser One challenge inherent to scATAC-seq data analysis is genome-track level visualizations of chromatin accessibility observed within groups of cells. Traditionally, track visualization requires grouping the scATAC-seq fragments, creating a genome coverage bigwig, and normalizing this track for quantitative visualization. Typically, end-users use a genome browser such as the WashU Epigenome Browser, the UCSC Genome Browser, or the IGV browser to visualize these sequencing tracks. This process involves using multiple software and any change to the cellular groups or addition of more samples requires re-generation of bigwig files etc., which can become quite cumbersome. For this reason, ArchR has a Shiny-based interactive genome browser that can be launched with a single line of code ArchRBrowser(ArchRProj). The data storage strategy implemented in Arrow files allows this interactive browser to dynamically change the cell groupings, resolution, and normalization, enabling real-time track-level visualizations. The ArchR Genome Browser also allows for export of high-quality vectorized images in PDF format for publication or distribution. Additionally, the browser accepts user-supplied input files such as a GenomicRanges object to display features, via the features parameter, or genomic interaction files that define co-accessibility, peak-to-gene linkages, or loops from chromatin conformation data via the loops parameter. For loops, the expected format is a GRanges object whose start position represents the center position of one loop anchor and whose end position represents the center position of the other loop anchor. To launch our local interactive genome browser, we use the ArchRBrowser() function. If you are working in RStudio, you will want to click the “Show in new window” button to get a full-screen view. ArchRBrowser(projHeme2) When we start, we see a screen that looks like this: By selecting a gene via the “Gene Symbol” box, we can begin browsing. You may need to click the “Plot Track” button to force your browser session to update. Once we have plotted a gene locus, we see a single track representing each of the clusters in our data. If we click the “Additional Parameters” tab, we can specify which clusters to display and which to hide. By unclicking the check boes next to Clusters 1, 2, and 3, we will remove them from the plot. When we return to the “Plot” tab, we should see an updated plot with Clusters 1, 2, and 3 removed. Again, you may need to click the “Plot Track” button to force your browser session to update. At any point, we can export a vectorized PDF of the current track view using the “Download the Track” button. Don’t forget to hit the “Exit Browser” button when you are done, otherwise your R terminal won’t be responsive. "],["defining-cluster-identity-with-scrna-seq.html", "Chapter 10 Defining Cluster Identity with scRNA-seq", " Chapter 10 Defining Cluster Identity with scRNA-seq In addition to allowing cluster identity assignment with gene scores, ArchR also enables integration with scRNA-seq. This can help with cluster identity assignment because you can directly use clusters called in scRNA-seq space or use the gene expression measurements after integration. The way this integration works is by directly aligning cells from scATAC-seq with cells from scRNA-seq by comparing the scATAC-seq gene score matrix with the scRNA-seq gene expression matrix. Under the hood, this alignment is performed using the FindTransferAnchors() function from the Seurat package which allows you to align data across two datasets. However, to appropriately scale this procedure for hundreds of thousands of cells ArchR provides a parallelization of this procedure by dividing the total cells into smaller groups of cells and performing separate alignments. Effectively, for each cell in the scATAC-seq data, this integration process finds the cell in the scRNA-seq data that looks most similar and assigns the gene expression data from that scRNA-seq cell to the scATAC-seq cell. At the end, each cell in scATAC-seq space has been assigned a gene expression signature which can be used for many downstream analyses. This chapter illustrates how to use this information for assigning clusters while later chapters show how to use the linked scRNA-seq data for more complex analyses such as identifying predicted cis-regulatory interactions. We believe these integrative analyses will become increasingly relevant as multi-omic single-cell profiling becomes more common. In the meantime, using publicly available scRNA-seq data in matched cell types or scRNA-seq data that you have generated on your sample of interest can bolster the scATAC-seq analyses performed in ArchR. "],["cross-platform-linkage-of-scatac-seq-cells-with-scrna-seq-cells.html", "10.1 Cross-platform linkage of scATAC-seq cells with scRNA-seq cells", " 10.1 Cross-platform linkage of scATAC-seq cells with scRNA-seq cells In order to integrate our tutorial scATAC-seq data with matched scRNA-seq data, we will use scRNA-seq data derived from the same hematopoietic cell types from Granja* et al (2019). We have stored this scRNA-seq data as a 111 MB RangedSummarizedExperiment object. However, ArchR also accepts unmodified Seurat objects as input to the integration workflow. However, Seurat SCTransform-normalized data is not suitable for this integration workflow. Downloading and examining this object, we see that it has a gene expression counts matrix and associated metadata. if(!file.exists(&quot;scRNA-Hematopoiesis-Granja-2019.rds&quot;)){ download.file( url = &quot;https://jeffgranja.s3.amazonaws.com/ArchR/TestData/scRNA-Hematopoiesis-Granja-2019.rds&quot;, destfile = &quot;scRNA-Hematopoiesis-Granja-2019.rds&quot; ) } seRNA &lt;- readRDS(&quot;scRNA-Hematopoiesis-Granja-2019.rds&quot;) seRNA ## class: RangedSummarizedExperiment ## dim: 20287 35582 ## metadata(0): ## assays(1): counts ## rownames(20287): FAM138A OR4F5 ... S100B PRMT2 ## rowData names(3): gene_name gene_id exonLength ## colnames(35582): CD34_32_R5:AAACCTGAGTATCGAA-1 ## CD34_32_R5:AAACCTGAGTCGTTTG-1 ... ## BMMC_10x_GREENLEAF_REP2:TTTGTTGCATGTGTCA-1 ## BMMC_10x_GREENLEAF_REP2:TTTGTTGCATTGAAAG-1 ## colData names(10): Group nUMI_pre ... BioClassification Barcode The metadata contains a column called BioClassification which contains the cell type classifications for each cell in the scRNA-seq dataset. colnames(colData(seRNA)) ## [1] &quot;Group&quot; &quot;nUMI_pre&quot; &quot;nUMI&quot; ## [4] &quot;nGene&quot; &quot;initialClusters&quot; &quot;UMAP1&quot; ## [7] &quot;UMAP2&quot; &quot;Clusters&quot; &quot;BioClassification&quot; ## [10] &quot;Barcode&quot; Using table() we can see how many cells are in each of the scRNA-seq cell type classifications. table(colData(seRNA)$BioClassification) ## ## 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP ## 1425 1653 446 111 2260 ## 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC ## 903 2097 1050 544 325 ## 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 ## 1800 4222 292 520 377 ## 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 ## 710 1711 62 1521 2470 ## 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK ## 2364 3539 796 2080 2143 ## 26_Unk ## 161 There are two types of integration approaches that we can perform. Unconstrained integration is a completely agnostic approach that would take all of the cells in your scATAC-seq experiment and attempt to align them to any of the cells in the scRNA-seq experiment. While this is a feasible preliminary solution, we can improve the quality of our cross-platform alignment by constraining the integration process. To perform a constrained integration we use prior knowledge of the cell types to limit the search space of the alignment. For example, if we knew that Clusters A, B, and C in the scATAC-seq data corresponded to 3 different T cell clusters, and we knew that Clusters X and Y in the scRNA-seq data corresponded to 2 different T cell clusters, we could tell ArchR to specifically try to align cells from scATAC-seq Clusters A, B, and C to cell from scRNA-seq clusters X and Y. We illustrate these two approaches below, first performing an unconstrained integration to acheive preliminary cluster identities and then using this prior knowledge to perform a more refined constrained integration. However, please note that your own application must guide which type of integration you perform. Constrained integration may not be suited for all applications so the below sections are merely a guide for how to accomplish this and should not be viewed as a “tutorial” on how to integrate your own data. 10.1.1 Unconstrained Integration To integrate scATAC-seq with scRNA-seq, we use the addGeneIntegrationMatrix() function. As mentioned above, this function accepts either a Seurat object or a RangedSummarizedExperiment object via the seRNA parameter. The first round of integration we perform will be a preliminary unconstrained integration and we will not store this in the Arrow files (addToArrow = FALSE). We provide a name for the integration matrix that will be stored in the ArchRProject via the matrixName parameter. The other key parameters for this function provide column names in cellColData where certain information will be stored: nameCell will store the cell ID from the matched scRNA-seq cell, nameGroup will store the group ID from the scRNA-seq cell, and nameScore will store the cross-platform integration score. projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = FALSE, groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell_Un&quot;, nameGroup = &quot;predictedGroup_Un&quot;, nameScore = &quot;predictedScore_Un&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-96fff91fe-Date-2025-02-06_Time-01-12-33.290334.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:12:33.062668 : Running Seurat&#39;s Integration Stuart* et al 2019, 0.004 mins elapsed. ## 2025-02-06 01:12:32.572038 : Checking ATAC Input, 0.012 mins elapsed. ## 2025-02-06 01:12:33.079081 : Checking RNA Input, 0.004 mins elapsed. ## 2025-02-06 01:12:46.629328 : Found 18601 overlapping gene names from gene scores and rna matrix!, 0.222 mins elapsed. ## 2025-02-06 01:12:46.635656 : Creating Integration Blocks, 0.222 mins elapsed. ## 2025-02-06 01:12:46.81762 : Prepping Interation Data, 0.225 mins elapsed. ## subThreading Disabled since ArchRLocking is TRUE see `addArchRLocking` ## 2025-02-06 01:12:47.514509 : Computing Integration in 1 Integration Blocks!, 0 mins elapsed. ## 2025-02-06 01:12:47.520472 : Block (1 of 1) : Computing Integration, 0 mins elapsed. ## 2025-02-06 01:12:48.847046 : Block (1 of 1) : Identifying Variable Genes, 0.022 mins elapsed. ## 2025-02-06 01:12:52.413502 : Block (1 of 1) : Getting GeneScoreMatrix, 0.082 mins elapsed. ## 2025-02-06 01:13:02.035768 : Block (1 of 1) : Imputing GeneScoreMatrix, 0.242 mins elapsed. ## Getting ImputeWeights ## 2025-02-06 01:13:31.726271 : Block (1 of 1) : Seurat FindTransferAnchors, 0.737 mins elapsed. ## 2025-02-06 01:14:55.308332 : Block (1 of 1) : Seurat TransferData Cell Group Labels, 2.13 mins elapsed. ## 2025-02-06 01:15:11.375992 : Block (1 of 1) : Seurat TransferData Cell Names Labels, 2.398 mins elapsed. ## 2025-02-06 01:15:42.529609 : Block (1 of 1) : Saving TransferAnchors Joint CCA, 2.917 mins elapsed. ## 2025-02-06 01:15:44.67249 : Block (1 of 1) : Completed Integration, 2.953 mins elapsed. ## 2025-02-06 01:15:46.388204 : Block (1 of 1) : Plotting Joint UMAP, 2.981 mins elapsed. ## Length of unique values greater than palette, interpolating.. ## 2025-02-06 01:16:09.356606 : Completed Integration with RNA Matrix, 3.364 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-96fff91fe-Date-2025-02-06_Time-01-12-33.290334.log This unconstrained integration can be used as shown below to perform a more refined constrained integration. You may want to assess the “quality” of the integration between your scATAC-seq and scRNA-seq data. ArchR provides two general ways to do this. The first is the option to ouput a UMAP plot of the joint CCA subspace. This is enabled through the plotUMAP and UMAPParams parameters to addGeneIntegrationMatrix(). If plotUMAP = TRUE, then a UMAP plot is saved for each block of the integration in a subfolder (based on matrixName) of the “RNAIntegration” folder. These plots can be difficult to interpret, especially with the intercellular heterogeneity isn’t very strong. As an alternative, ArchR also stores the NAME.score value from Seurat::TransferData() in a column of cellColData indicated by what you pass to the nameScore parameter. 10.1.2 Constrained Integration Now that we have our preliminary unconstrained integration, we will identify general cell types to profide a framework to further refine the integration results. Given that this tutorial data is from hematopoietic cells, we would ideally constrain the integration to associate similar cell types togther. First, we will identify which cell types from the scRNA-seq data are most abundant in each of our scATAC-seq clusters. The goal of this is to identify the cells in both the scATAC-seq and scRNA-seq data that correspond to T cells and NK cells using the unconstrained integration so that we can perform a constrained integration using this information. To do this, we will create a confusionMatrix that looks at the intersection of Clusters and predictedGroup_Un which contains the cell types as identified by scRNA-seq. cM &lt;- as.matrix(confusionMatrix(projHeme2$Clusters, projHeme2$predictedGroup_Un)) preClust &lt;- colnames(cM)[apply(cM, 1 , which.max)] cbind(preClust, rownames(cM)) #Assignments ## preClust ## [1,] &quot;17_B&quot; &quot;C9&quot; ## [2,] &quot;20_CD4.N1&quot; &quot;C11&quot; ## [3,] &quot;16_Pre.B&quot; &quot;C4&quot; ## [4,] &quot;08_GMP.Neut&quot; &quot;C7&quot; ## [5,] &quot;12_CD14.Mono.2&quot; &quot;C1&quot; ## [6,] &quot;02_Early.Eryth&quot; &quot;C6&quot; ## [7,] &quot;01_HSC&quot; &quot;C8&quot; ## [8,] &quot;22_CD4.M&quot; &quot;C12&quot; ## [9,] &quot;09_pDC&quot; &quot;C3&quot; ## [10,] &quot;25_NK&quot; &quot;C10&quot; ## [11,] &quot;12_CD14.Mono.2&quot; &quot;C2&quot; ## [12,] &quot;15_CLP.2&quot; &quot;C5&quot; The above list shows which scRNA-seq cell type is most abundant in each of the 12 scATAC-seq clusters. First, lets look at the cell type labels from our scRNA-seq data that were used in our unconstrained integration: unique(unique(projHeme2$predictedGroup_Un)) ## [1] &quot;17_B&quot; &quot;22_CD4.M&quot; &quot;16_Pre.B&quot; &quot;06_CLP.1&quot; ## [5] &quot;08_GMP.Neut&quot; &quot;24_CD8.CM&quot; &quot;11_CD14.Mono.1&quot; &quot;12_CD14.Mono.2&quot; ## [9] &quot;07_GMP&quot; &quot;02_Early.Eryth&quot; &quot;05_CMP.LMPP&quot; &quot;03_Late.Eryth&quot; ## [13] &quot;04_Early.Baso&quot; &quot;09_pDC&quot; &quot;20_CD4.N1&quot; &quot;10_cDC&quot; ## [17] &quot;23_CD8.EM&quot; &quot;19_CD8.N&quot; &quot;25_NK&quot; &quot;15_CLP.2&quot; ## [21] &quot;21_CD4.N2&quot; &quot;01_HSC&quot; &quot;14_Unk&quot; &quot;13_CD16.Mono&quot; From the above list, we can see that the clusters in the scRNA-seq data that correspond to T cells and NK cells are Clusters 19-25. We will create a string-based representation of these clusters to use in the downstream constrained integration. #From scRNA cTNK &lt;- paste0(paste0(19:25), collapse=&quot;|&quot;) cTNK ## [1] &quot;19|20|21|22|23|24|25&quot; We can then take all of the other clusters and create a string-based representation of all “Non-T cell, Non-NK cell” clusters (i.e. Cluster 1 - 18). cNonTNK &lt;- paste0(c(paste0(&quot;0&quot;, 1:9), 10:13, 15:18), collapse=&quot;|&quot;) cNonTNK ## [1] &quot;01|02|03|04|05|06|07|08|09|10|11|12|13|15|16|17|18&quot; These string-based representations are pattern matching strings that we will use with grep to extract the scATAC-seq clusters that correspond to these scRNA-seq cell types. The | in the string acts as an or statement so we end up searching for any row in the preClust column of our confusion matrix that matches one of the scRNA-seq cluster numbers provided in the pattern match string. For T cells and NK cells, this identifies scATAC-seq clusters C7, C8, and C9: clustTNK &lt;- rownames(cM)[grep(cTNK, preClust)] clustTNK ## [1] &quot;C11&quot; &quot;C12&quot; &quot;C10&quot; For Non-T cells and Non-NK cells, this identifies the remaining scATAC-seq clusters: clustNonTNK &lt;- rownames(cM)[grep(cNonTNK, preClust)] clustNonTNK ## [1] &quot;C9&quot; &quot;C4&quot; &quot;C7&quot; &quot;C1&quot; &quot;C6&quot; &quot;C8&quot; &quot;C3&quot; &quot;C2&quot; &quot;C5&quot; We then perform a similar opperation to identify the scRNA-seq cells that correspond to these same cell types. First, we identify the T cell and NK cells in the scRNA-seq data rnaTNK &lt;- colnames(seRNA)[grep(cTNK, colData(seRNA)$BioClassification)] head(rnaTNK) ## [1] &quot;PBMC_10x_GREENLEAF_REP1:AAACCCAGTCGTCATA-1&quot; ## [2] &quot;PBMC_10x_GREENLEAF_REP1:AAACCCATCCGATGTA-1&quot; ## [3] &quot;PBMC_10x_GREENLEAF_REP1:AAACCCATCTCAACGA-1&quot; ## [4] &quot;PBMC_10x_GREENLEAF_REP1:AAACCCATCTCTCGAC-1&quot; ## [5] &quot;PBMC_10x_GREENLEAF_REP1:AAACGAACAATCGTCA-1&quot; ## [6] &quot;PBMC_10x_GREENLEAF_REP1:AAACGAACACGATTCA-1&quot; Then, we identify the Non-T cell Non-NK cell cells in the scRNA-seq data. rnaNonTNK &lt;- colnames(seRNA)[grep(cNonTNK, colData(seRNA)$BioClassification)] head(rnaNonTNK) ## [1] &quot;CD34_32_R5:AAACCTGAGTATCGAA-1&quot; &quot;CD34_32_R5:AAACCTGAGTCGTTTG-1&quot; ## [3] &quot;CD34_32_R5:AAACCTGGTTCCACAA-1&quot; &quot;CD34_32_R5:AAACGGGAGCTTCGCG-1&quot; ## [5] &quot;CD34_32_R5:AAACGGGAGGGAGTAA-1&quot; &quot;CD34_32_R5:AAACGGGAGTTACGGG-1&quot; To prepare for this constrained integration, we create a nested list. This is a SimpleList of multiple SimpleList objects, one for each group that we would like to constrain. In this example, we have two groups: one group called TNK that identifies the T cells and NK cells across the two platforms, and a second group called NonTNK that identifies the Non-T cell Non-NK cell cells across the two platforms. Each of these SimpleList objects has two vectors of cell IDs, one called ATAC and one called RNA as shown below: groupList &lt;- SimpleList( TNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustTNK], RNA = rnaTNK ), NonTNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustNonTNK], RNA = rnaNonTNK ) ) We pass this list to the groupList parameter of the addGeneIntegrationMatrix() function to constrain our integration. Note that, in this case, we are still not adding these results to the Arrow files (addToArrow = FALSE). We recommend checking the results of the integration thoroughly against your expectations prior to saving the results in the Arrow files. We illustrate this process in the next section of the book. #~5 minutes projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = FALSE, groupList = groupList, groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell_Co&quot;, nameGroup = &quot;predictedGroup_Co&quot;, nameScore = &quot;predictedScore_Co&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-964113428-Date-2025-02-06_Time-01-16-09.553575.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:16:09.702961 : Running Seurat&#39;s Integration Stuart* et al 2019, 0.002 mins elapsed. ## 2025-02-06 01:16:10.216911 : Checking ATAC Input, 0.011 mins elapsed. ## 2025-02-06 01:16:10.803531 : Checking RNA Input, 0.021 mins elapsed. ## 2025-02-06 01:16:20.078675 : Found 18601 overlapping gene names from gene scores and rna matrix!, 0.175 mins elapsed. ## 2025-02-06 01:16:20.085364 : Creating Integration Blocks, 0.176 mins elapsed. ## 2025-02-06 01:16:20.215961 : Prepping Interation Data, 0.178 mins elapsed. ## subThreading Disabled since ArchRLocking is TRUE see `addArchRLocking` ## 2025-02-06 01:16:20.969995 : Computing Integration in 2 Integration Blocks!, 0 mins elapsed. ## 2025-02-06 01:16:20.97575 : Block (1 of 2) : Computing Integration, 0 mins elapsed. ## 2025-02-06 01:16:21.053531 : Block (1 of 2) : Identifying Variable Genes, 0.001 mins elapsed. ## 2025-02-06 01:16:22.271847 : Block (1 of 2) : Getting GeneScoreMatrix, 0.022 mins elapsed. ## 2025-02-06 01:16:29.611887 : Block (1 of 2) : Imputing GeneScoreMatrix, 0.144 mins elapsed. ## Getting ImputeWeights ## 2025-02-06 01:16:35.062841 : Block (1 of 2) : Seurat FindTransferAnchors, 0.235 mins elapsed. ## 2025-02-06 01:17:42.601698 : Block (1 of 2) : Seurat TransferData Cell Group Labels, 1.361 mins elapsed. ## 2025-02-06 01:17:56.760959 : Block (1 of 2) : Seurat TransferData Cell Names Labels, 1.597 mins elapsed. ## 2025-02-06 01:18:16.00385 : Block (1 of 2) : Saving TransferAnchors Joint CCA, 1.917 mins elapsed. ## 2025-02-06 01:18:17.944235 : Block (1 of 2) : Completed Integration, 1.95 mins elapsed. ## 2025-02-06 01:18:19.693217 : Block (2 of 2) : Computing Integration, 1.979 mins elapsed. ## 2025-02-06 01:18:21.549586 : Block (2 of 2) : Identifying Variable Genes, 2.01 mins elapsed. ## 2025-02-06 01:18:23.398984 : Block (2 of 2) : Getting GeneScoreMatrix, 2.04 mins elapsed. ## 2025-02-06 01:18:33.821943 : Block (2 of 2) : Imputing GeneScoreMatrix, 2.214 mins elapsed. ## Getting ImputeWeights ## 2025-02-06 01:18:54.434112 : Block (2 of 2) : Seurat FindTransferAnchors, 2.558 mins elapsed. ## 2025-02-06 01:20:09.273425 : Block (2 of 2) : Seurat TransferData Cell Group Labels, 3.805 mins elapsed. ## 2025-02-06 01:20:26.046888 : Block (2 of 2) : Seurat TransferData Cell Names Labels, 4.085 mins elapsed. ## 2025-02-06 01:20:51.630491 : Block (2 of 2) : Saving TransferAnchors Joint CCA, 4.511 mins elapsed. ## 2025-02-06 01:20:53.716094 : Block (2 of 2) : Completed Integration, 4.546 mins elapsed. ## 2025-02-06 01:20:55.449856 : Block (1 of 2) : Plotting Joint UMAP, 4.575 mins elapsed. ## 2025-02-06 01:21:11.070896 : Block (2 of 2) : Plotting Joint UMAP, 4.835 mins elapsed. ## 2025-02-06 01:21:32.818702 : Completed Integration with RNA Matrix, 5.197 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-964113428-Date-2025-02-06_Time-01-16-09.553575.log 10.1.3 Comparing Unconstrained and Constrained Integrations To compare our unconstrained and constrained integrations, we will color the cells in our scATAC-seq data based on the scRNA-seq cell type identified through integration. To do this, we will create a color palette using the built-in ArchR function paletteDiscrete(). pal &lt;- paletteDiscrete(values = colData(seRNA)$BioClassification) ## Length of unique values greater than palette, interpolating.. In ArchR, a palette is essentially a named vector where the values are hex codes corresponding to the color to be associated with the names. pal ## 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP ## &quot;#D51F26&quot; &quot;#502A59&quot; &quot;#235D55&quot; &quot;#3D6E57&quot; &quot;#8D2B8B&quot; ## 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC ## &quot;#DE6C3E&quot; &quot;#F9B712&quot; &quot;#D8CE42&quot; &quot;#8E9ACD&quot; &quot;#B774B1&quot; ## 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 ## &quot;#D69FC8&quot; &quot;#C7C8DE&quot; &quot;#8FD3D4&quot; &quot;#89C86E&quot; &quot;#CC9672&quot; ## 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 ## &quot;#CF7E96&quot; &quot;#A27AA4&quot; &quot;#CD4F32&quot; &quot;#6B977E&quot; &quot;#518AA3&quot; ## 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK ## &quot;#5A5297&quot; &quot;#0F707D&quot; &quot;#5E2E32&quot; &quot;#A95A3C&quot; &quot;#B28D5C&quot; ## 26_Unk ## &quot;#3D3D3D&quot; We can now visualize the integration by overlaying the scRNA-seq cell types on our scATAC-seq data based on the unconstrained integration. p1 &lt;- plotEmbedding( projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup_Un&quot;, pal = pal ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-93ea75cb7-Date-2025-02-06_Time-01-21-32.959358.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-93ea75cb7-Date-2025-02-06_Time-01-21-32.959358.log p1 Similarly, we can visualize the integration by overlaying the scRNA-seq cell types on our scATAC-seq data based on the constrained integration. p2 &lt;- plotEmbedding( projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup_Co&quot;, pal = pal ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-92d19c5e1-Date-2025-02-06_Time-01-21-35.150673.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-92d19c5e1-Date-2025-02-06_Time-01-21-35.150673.log p2 The differences between these the unconstrained and constrained integration is very subtle in this example, largely because the cell types of interest are already very distinct. However, you should notice differences, especially in the T cell clusters (Clusters 17-22). To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(p1,p2, name = &quot;Plot-UMAP-RNA-Integration.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! We can now save our projHeme2 using the saveArchRProject() function. Here, we set load = TRUE to make sure that the projHeme2 object tracks with the project that we just saved. projHeme2 &lt;- saveArchRProject(ArchRProj = projHeme2, outputDirectory = &quot;Save-ProjHeme2&quot;, load = TRUE) ## Copying ArchRProject to new outputDirectory : /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme2 ## Copying Arrow Files... ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights... ## Copying Other Files... ## Copying Other Files (1 of 6): Embeddings ## Copying Other Files (2 of 6): IterativeLSI ## Copying Other Files (3 of 6): IterativeLSI2 ## Copying Other Files (4 of 6): IterativeLSI3 ## Copying Other Files (5 of 6): Plots ## Copying Other Files (6 of 6): RNAIntegration ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## "],["adding-pseudo-scrna-seq-profiles-for-each-scatac-seq-cell.html", "10.2 Adding Pseudo-scRNA-seq profiles for each scATAC-seq cell", " 10.2 Adding Pseudo-scRNA-seq profiles for each scATAC-seq cell Now that we are satisfied with the results of our scATAC-seq and scRNA-seq integration, we can re-run the integration with addToArrow = TRUE to add the linked gene expression data to each of the Arrow files. As described previously, we pass the groupList to constrain the integration and column names to nameCell, nameGroup, and nameScore for each of the metadata columns we will add to cellColData. Here, we create projHeme3 which will be carried forward in the tutorial. projHeme3 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = TRUE, force= TRUE, groupList = groupList, groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell&quot;, nameGroup = &quot;predictedGroup&quot;, nameScore = &quot;predictedScore&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-95dd80f34-Date-2025-02-06_Time-01-22-03.820929.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:22:03.97437 : Running Seurat&#39;s Integration Stuart* et al 2019, 0.003 mins elapsed. ## 2025-02-06 01:22:04.492682 : Checking ATAC Input, 0.011 mins elapsed. ## 2025-02-06 01:22:05.103631 : Checking RNA Input, 0.021 mins elapsed. ## 2025-02-06 01:22:14.847343 : Found 18601 overlapping gene names from gene scores and rna matrix!, 0.184 mins elapsed. ## 2025-02-06 01:22:14.854022 : Creating Integration Blocks, 0.184 mins elapsed. ## 2025-02-06 01:22:14.984647 : Prepping Interation Data, 0.186 mins elapsed. ## subThreading Disabled since ArchRLocking is TRUE see `addArchRLocking` ## 2025-02-06 01:22:15.768962 : Computing Integration in 2 Integration Blocks!, 0 mins elapsed. ## 2025-02-06 01:22:15.775256 : Block (1 of 2) : Computing Integration, 0 mins elapsed. ## 2025-02-06 01:22:17.119148 : Block (1 of 2) : Identifying Variable Genes, 0.023 mins elapsed. ## 2025-02-06 01:22:18.380874 : Block (1 of 2) : Getting GeneScoreMatrix, 0.044 mins elapsed. ## 2025-02-06 01:22:25.772727 : Block (1 of 2) : Imputing GeneScoreMatrix, 0.167 mins elapsed. ## Getting ImputeWeights ## 2025-02-06 01:22:30.937936 : Block (1 of 2) : Seurat FindTransferAnchors, 0.253 mins elapsed. ## 2025-02-06 01:23:37.036289 : Block (1 of 2) : Seurat TransferData Cell Group Labels, 1.354 mins elapsed. ## 2025-02-06 01:23:53.212624 : Block (1 of 2) : Seurat TransferData Cell Names Labels, 1.624 mins elapsed. ## 2025-02-06 01:24:12.982176 : Block (1 of 2) : Seurat TransferData GeneMatrix, 1.954 mins elapsed. ## 2025-02-06 01:24:30.25185 : Block (1 of 2) : Saving TransferAnchors Joint CCA, 2.241 mins elapsed. ## 2025-02-06 01:24:32.224822 : Block (1 of 2) : Transferring Paired RNA to Temp File, 2.274 mins elapsed. ## 2025-02-06 01:24:35.20627 : Block (1 of 2) : Completed Integration, 2.324 mins elapsed. ## 2025-02-06 01:24:36.931569 : Block (2 of 2) : Computing Integration, 2.353 mins elapsed. ## 2025-02-06 01:24:38.179617 : Block (2 of 2) : Identifying Variable Genes, 2.374 mins elapsed. ## 2025-02-06 01:24:40.020529 : Block (2 of 2) : Getting GeneScoreMatrix, 2.404 mins elapsed. ## 2025-02-06 01:24:50.25748 : Block (2 of 2) : Imputing GeneScoreMatrix, 2.575 mins elapsed. ## Getting ImputeWeights ## 2025-02-06 01:25:10.949585 : Block (2 of 2) : Seurat FindTransferAnchors, 2.92 mins elapsed. ## 2025-02-06 01:26:23.864048 : Block (2 of 2) : Seurat TransferData Cell Group Labels, 4.135 mins elapsed. ## 2025-02-06 01:26:40.437427 : Block (2 of 2) : Seurat TransferData Cell Names Labels, 4.411 mins elapsed. ## 2025-02-06 01:27:05.031954 : Block (2 of 2) : Seurat TransferData GeneMatrix, 4.821 mins elapsed. ## 2025-02-06 01:27:26.767575 : Block (2 of 2) : Saving TransferAnchors Joint CCA, 5.183 mins elapsed. ## 2025-02-06 01:27:28.982716 : Block (2 of 2) : Transferring Paired RNA to Temp File, 5.22 mins elapsed. ## 2025-02-06 01:27:37.764555 : Block (2 of 2) : Completed Integration, 5.367 mins elapsed. ## 2025-02-06 01:27:39.466188 : Block (1 of 2) : Plotting Joint UMAP, 5.395 mins elapsed. ## 2025-02-06 01:27:55.272158 : Block (2 of 2) : Plotting Joint UMAP, 5.658 mins elapsed. ## 2025-02-06 01:28:15.484101 : Transferring Data to ArrowFiles, 5.995 mins elapsed. ## 2025-02-06 01:28:15.526526 : scATAC_BMMC_R1 (1 of 3) Getting GeneIntegrationMatrix From TempFiles!, 5.996 mins elapsed. ## 2025-02-06 01:28:21.934368 : scATAC_BMMC_R1 (1 of 3) Adding GeneIntegrationMatrix to ArrowFile!, 6.103 mins elapsed. ## 2025-02-06 01:29:31.024427 : scATAC_CD34_BMMC_R1 (2 of 3) Getting GeneIntegrationMatrix From TempFiles!, 7.254 mins elapsed. ## 2025-02-06 01:29:36.136875 : scATAC_CD34_BMMC_R1 (2 of 3) Adding GeneIntegrationMatrix to ArrowFile!, 7.339 mins elapsed. ## 2025-02-06 01:30:40.029477 : scATAC_PBMC_R1 (3 of 3) Getting GeneIntegrationMatrix From TempFiles!, 8.404 mins elapsed. ## 2025-02-06 01:30:43.662016 : scATAC_PBMC_R1 (3 of 3) Adding GeneIntegrationMatrix to ArrowFile!, 8.465 mins elapsed. ## 2025-02-06 01:31:45.899053 : Completed Integration with RNA Matrix, 9.502 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-95dd80f34-Date-2025-02-06_Time-01-22-03.820929.log Now, when we check which matrices are available using getAvailableMatrices(), we see that the GeneIntegrationMatrix has been added to the Arrow files. getAvailableMatrices(projHeme3) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;TileMatrix&quot; With this new GeneIntegrationMatrix we can compare the linked gene expression with the inferred gene expression obtained through gene scores. First, lets make sure we have added impute weights to our project: projHeme3 &lt;- addImputeWeights(projHeme3) ## ArchR logging to : ArchRLogs/ArchR-addImputeWeights-96d4e8a34-Date-2025-02-06_Time-01-31-46.701253.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 01:31:47.085446 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. Now, lets make some UMAP plots overlayed with the gene expression values from our GeneIntegrationMatrix. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p1 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneIntegrationMatrix&quot;, name = markerGenes, continuousSet = &quot;horizonExtra&quot;, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-952ba38bc-Date-2025-02-06_Time-01-31-58.649191.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values... ## 2025-02-06 01:31:59.731046 : ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-952ba38bc-Date-2025-02-06_Time-01-31-58.649191.log We can make the same UMAP plots but overlay them with the gene score values from our GeneScoreMatrix p2 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneScoreMatrix&quot;, continuousSet = &quot;horizonExtra&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-97fd3fe9d-Date-2025-02-06_Time-01-32-09.527451.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 01:32:10.572266 : ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-97fd3fe9d-Date-2025-02-06_Time-01-32-09.527451.log To plot all marker genes we can use cowplot. First, lets organize our plots. p1c &lt;- lapply(p1, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) p2c &lt;- lapply(p2, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) This is what the gene expression looks like: do.call(cowplot::plot_grid, c(list(ncol = 3), p1c)) And this is what the gene score looks like: do.call(cowplot::plot_grid, c(list(ncol = 3), p2c)) As expected, the results from these two methods for inferring gene expression are similar but not identical. To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotList = p1, name = &quot;Plot-UMAP-Marker-Genes-RNA-W-Imputation.pdf&quot;, ArchRProj = projHeme3, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! "],["labeling-scatac-seq-clusters-with-scrna-seq-information.html", "10.3 Labeling scATAC-seq clusters with scRNA-seq information", " 10.3 Labeling scATAC-seq clusters with scRNA-seq information Now that we are confident in the alignment of our scATAC-seq and scRNA-seq, we can label our scATAC-seq clusters with the cell types from our scRNA-seq data. First, we will create a confusion matrix between our scATAC-seq clusters and the predictedGroup obtained from our integration analysis. cM &lt;- confusionMatrix(projHeme3$Clusters, projHeme3$predictedGroup) labelOld &lt;- rownames(cM) labelOld ## [1] &quot;C9&quot; &quot;C11&quot; &quot;C4&quot; &quot;C7&quot; &quot;C1&quot; &quot;C6&quot; &quot;C8&quot; &quot;C12&quot; &quot;C3&quot; &quot;C10&quot; &quot;C2&quot; &quot;C5&quot; Then, for each of our scATAC-seq clusters, we identify the cell type from predictedGroup which best defines that cluster. labelNew &lt;- colnames(cM)[apply(cM, 1, which.max)] labelNew ## [1] &quot;17_B&quot; &quot;21_CD4.N2&quot; &quot;16_Pre.B&quot; &quot;08_GMP.Neut&quot; ## [5] &quot;11_CD14.Mono.1&quot; &quot;02_Early.Eryth&quot; &quot;01_HSC&quot; &quot;22_CD4.M&quot; ## [9] &quot;09_pDC&quot; &quot;25_NK&quot; &quot;12_CD14.Mono.2&quot; &quot;15_CLP.2&quot; Next we need to reclassify these new cluster labels to make a simpler categorization system. For each scRNA-seq cluster, we will re-define its label to something easier to interpret. remapClust &lt;- c( &quot;01_HSC&quot; = &quot;Progenitor&quot;, &quot;02_Early.Eryth&quot; = &quot;Erythroid&quot;, &quot;03_Late.Eryth&quot; = &quot;Erythroid&quot;, &quot;04_Early.Baso&quot; = &quot;Basophil&quot;, &quot;05_CMP.LMPP&quot; = &quot;Progenitor&quot;, &quot;06_CLP.1&quot; = &quot;CLP&quot;, &quot;07_GMP&quot; = &quot;GMP&quot;, &quot;08_GMP.Neut&quot; = &quot;GMP&quot;, &quot;09_pDC&quot; = &quot;pDC&quot;, &quot;10_cDC&quot; = &quot;cDC&quot;, &quot;11_CD14.Mono.1&quot; = &quot;Mono&quot;, &quot;12_CD14.Mono.2&quot; = &quot;Mono&quot;, &quot;13_CD16.Mono&quot; = &quot;Mono&quot;, &quot;15_CLP.2&quot; = &quot;CLP&quot;, &quot;16_Pre.B&quot; = &quot;PreB&quot;, &quot;17_B&quot; = &quot;B&quot;, &quot;18_Plasma&quot; = &quot;Plasma&quot;, &quot;19_CD8.N&quot; = &quot;CD8.N&quot;, &quot;20_CD4.N1&quot; = &quot;CD4.N&quot;, &quot;21_CD4.N2&quot; = &quot;CD4.N&quot;, &quot;22_CD4.M&quot; = &quot;CD4.M&quot;, &quot;23_CD8.EM&quot; = &quot;CD8.EM&quot;, &quot;24_CD8.CM&quot; = &quot;CD8.CM&quot;, &quot;25_NK&quot; = &quot;NK&quot; ) remapClust &lt;- remapClust[names(remapClust) %in% labelNew] Then, using the mapLabels() function, we will convert our labels to this new simpler system. labelNew2 &lt;- mapLabels(labelNew, oldLabels = names(remapClust), newLabels = remapClust) labelNew2 ## [1] &quot;B&quot; &quot;CD4.N&quot; &quot;PreB&quot; &quot;GMP&quot; &quot;Mono&quot; ## [6] &quot;Erythroid&quot; &quot;Progenitor&quot; &quot;CD4.M&quot; &quot;pDC&quot; &quot;NK&quot; ## [11] &quot;Mono&quot; &quot;CLP&quot; Combining labelsOld and labelsNew2, we now can use the mapLabels() function again to create new cluster labels in cellColData. projHeme3$Clusters2 &lt;- mapLabels(projHeme3$Clusters, newLabels = labelNew2, oldLabels = labelOld) With these new labels in hand, we can plot a UMAP with the new cluster identities overlayed. p1 &lt;- plotEmbedding(projHeme3, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-919c1c4b5-Date-2025-02-06_Time-01-32-31.306041.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-919c1c4b5-Date-2025-02-06_Time-01-32-31.306041.log p1 This paradigm can be extremely helpful when analyzing scATAC-seq data from a cellular system where scRNA-seq data already exists. As mentioned previously, this integration of scATAC-seq with scRNA-seq also provides a beautiful framework for more complex gene regulation analyses that will be described in later chapters. To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(p1, name = &quot;Plot-UMAP-Remap-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! We can now save our original projHeme3 using saveArchRProject from ArchR. Here, we set load = TRUE to make sure that the projHeme3 object tracks with the project that we just saved. projHeme3 &lt;- saveArchRProject(ArchRProj = projHeme3, outputDirectory = &quot;Save-ProjHeme3&quot;, load = TRUE) ## Copying ArchRProject to new outputDirectory : /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme3 ## Copying Arrow Files... ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights... ## Copying Other Files... ## Copying Other Files (1 of 6): Embeddings ## Copying Other Files (2 of 6): IterativeLSI ## Copying Other Files (3 of 6): IterativeLSI2 ## Copying Other Files (4 of 6): IterativeLSI3 ## Copying Other Files (5 of 6): Plots ## Copying Other Files (6 of 6): RNAIntegration ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## "],["pseudo-bulk-replicates-in-archr.html", "Chapter 11 Pseudo-bulk Replicates in ArchR", " Chapter 11 Pseudo-bulk Replicates in ArchR Because scATAC-seq data is essentially binary - meaning any individual locus is either accessible or not accessible - we often find ourselves in the situation where we want to perform analyses that are just not possible on a single cell. Moreover, many of the analyses we would like to perform require replicates to obtain measurements of statistical significance. In single-cell data we get around these problems by creating pseudo-bulk replicates. The term pseudo-bulk refers to a grouping of single cells where the data from each single cell is combined into a single pseudo-sample that resembles a bulk ATAC-seq experiment. ArchR makes multiple such pseudo-bulk samples for each desired cell grouping, hence the term pseudo-bulk replicates. The underlying assumption in this process is that the single cells that are being grouped together are sufficiently similar that we do not care to understand the differences between them. These cell groupings are almost always derived from individual clusters or supersets of clusters that correspond to known cell types. This chapter describes the process by which ArchR generates these pseudo-bulk replicates. "],["how-does-archr-make-pseudo-bulk-replicates.html", "11.1 How Does ArchR Make Pseudo-bulk Replicates?", " 11.1 How Does ArchR Make Pseudo-bulk Replicates? To create pseudo-bulk replicates, ArchR employs a tiered priority approach. The user specifies (i) the minimum and maximum number of replicates desired, (ii) the minimum and maximum number of cells per replicate, and (iii) the sampling ratio to use if a particular grouping lacks sufficient cells to make the desired replicates. For example, a sampling ratio of 0.8 means that cells can be sampled without replacement up to 80% of the total number of cells for each replicate (this will result in sampling with replacement across replicates). In this case, multiple replicates may contain some of the same cells but this is a necessary sacrifice if you would like to generate pseudo-bulk replicates from a cell group that lacks sufficient cells. We process for pseudo-bulk replicate generation can be described by a decision tree as shown below. We outline some of the key considerations of this process in words here. First, the user identifies the cell groups to be used - this is often the clusters called by ArchR. Then for each cell grouping, ArchR attempts to create the desired pseudo-bulk replicates. The ideal pseudo-bulk replicate would consist of a sufficient number of cells from a single sample. This maintains sample diversity and biological variation between the replicates. This is what ArchR strives to obtain, but in reality there are 5 possible outcomes in this process, ranked below by preference in ArchR: Enough different samples (at least the max # replicates) each have more than the minimum number of cells to create pseudo-bulk replicates in a sample-aware fashion, combining only cells from the same sample into a single replicate. Some samples each have more than the minimum number of cells to create pseudo-bulk replicates in a sample-aware fashion. The remaing required replicates are created by combining cells without replacement from samples that are not already represented in the sample-aware pseudobulks. No samples have more than the minimum number of cells to create a sample-aware pseudo-bulk replicate but there are more cells than minCells * minReps. All required replicates are created by combining cells without replacement from in a sample-agnostic fashion. The total number of cells within a cell grouping is less than the minimum number of cells multiplied by the minimum number of replicates but greater than the minimum number of cells divided by the sampling ratio. Create the minimum number of replicates by sampling without replacement within a single replicate but with replacement across replicates while minimizing the number of cells present in multiple pseudo-bulk replicates. The total number of cells within a cell grouping is less than the minimum number of cells divided by the sampling ratio. This means that we must make replicates by sampling with replacement within a single replicate and across different replicates. This is the worst case scenario and users should be cautious about using these pseudo-bulk replicates downstream. This can be controled in various other ArchR functions using the minCells parameter. To illustrate this process, we will use the following example data set: Sample Cluster1 Cluster2 Cluster3 Cluster4 Cluster5 A 800 600 900 100 75 B 1000 50 400 150 25 C 600 900 100 200 50 D 1200 500 50 50 25 E 900 100 50 150 50 F 700 200 100 100 25 And we will set minRep = 3, maxRep = 5, minCells = 300, maxCells = 1000, and sampleRatio = 0.8. 11.1.1 Cluster1 For Cluster1, we have 6 samples (more than maxRep) that all have more than minCells cells (300 cells). This illustrates Option#1 above and we will make 5 pseudo-bulk replicates in a sample aware fashion like so: Rep1 = 800 cells from SampleA Rep2 = 1000 cells from SampleB Rep3 = 1000 cells from SampleD Rep4 = 900 cells from SampleE Rep5 = 700 cells from SampleF There are two things to note about these replicates: (i) SampleC was left out because we had more than enough samples to make maxRep sample-aware pseudo-bulk replicates and SampleC had the fewest number of cells. (ii) Only 1000 cells were used from SampleD because this is the maxCells value. 11.1.2 Cluster2 For Cluster2, we have 3 samples that all have more than minCells cells and a few additional samples that do not. This illustrates Option#2 above and we will make the following pseudo-bulk replicates: Rep1 = 600 cells from SampleA Rep2 = 900 cells from SampleC Rep3 = 500 cells from SampleD Rep4 = 350 cells [50 cells from SampleB + 100 from SampleE + 200 from SampleF] In this example, Rep4 gets created in a samaple agnostic fashion by sampling without replacement. 11.1.3 Cluster3 For Cluster3, we only have 2 samples that have more than minCells cells which is less than the required minReps. However, if we combine the cells from the remaining samples, we can make one additional replicate with more than minCells. This gives us a total of 3 pseudo-bulk replicates and represents the situation illustrated by Option#3 above. We will make the following replicates: Rep1 = 900 cells from SampleA Rep2 = 400 cells from SampleB Rep3 = 300 cells [100 cells from SampleC + 50 from SampleD + 50 from SampleE + 100 from SampleF] Similar to Cluster2 above, Cluster3 Rep3 is created in a sample agnostic fashion by sampling without replacement across multiple samples. 11.1.4 Cluster4 For Cluster4, the total number of cells is 750 which is less than minCells * minReps (900 cells). In this case, we do not have sufficient cells to make minReps with at least minCells without some form of sampling with replacement. However, the total cells is still greater than minCells / sampleRatio (375 cells) which means that we only have to sample with replacement across different pseudo-bulk replicates, not within a single replicate. This represents the situation illustrated in Option#4 above and we will therefore make the following replicates: Rep1 = 300 cells [250 unique cells + 25 cells overlapping Rep2 + 25 cells overlapping Rep3] Rep2 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep3] Rep3 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep2] In this case, ArchR will minimize the number of cells that overlap between any two pseudo-bulk replicates. 11.1.5 Cluster5 For Cluster5, the total number of cells is 250 which is less than minCells * minReps (900 cells) and less than minCells / sampleRatio (375 cells). This means that we we will have to sample with replacement within each sample and across different replicates to make pseudo-bulk replicates. This represents the least desirable situation illustrated in Option#5 above and we should therefore be cautious in using these pseudo-bulk replicates in downstream analyses. We will therefore make the following replicates: Rep1 = 300 cells [250 unique cells + 25 cells overlapping Rep2 + 25 cells overlapping Rep3] Rep2 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep3] Rep3 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep2] "],["making-pseudo-bulk-replicates.html", "11.2 Making Pseudo-bulk Replicates", " 11.2 Making Pseudo-bulk Replicates In ArchR, pseudo-bulk replicates are made using the addGroupCoverages() function. The key parameter here is groupBy which defines the groups for which pseudo-bulk replicates should be made. Here, we are using Clusters2 which was defined by labeling our clusters with cell types defined by scRNA-seq data in a previous chapter. projHeme4 &lt;- addGroupCoverages(ArchRProj = projHeme3, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-addGroupCoverages-964f05836-Date-2025-02-06_Time-01-33-51.280901.log ## If there is an issue, please report to github with logFile! ## B (1 of 11) : CellGroups N = 2 ## CD4.M (2 of 11) : CellGroups N = 2 ## CD4.N (3 of 11) : CellGroups N = 2 ## CLP (4 of 11) : CellGroups N = 2 ## Erythroid (5 of 11) : CellGroups N = 2 ## GMP (6 of 11) : CellGroups N = 2 ## Mono (7 of 11) : CellGroups N = 2 ## NK (8 of 11) : CellGroups N = 2 ## pDC (9 of 11) : CellGroups N = 2 ## PreB (10 of 11) : CellGroups N = 2 ## Progenitor (11 of 11) : CellGroups N = 2 ## 2025-02-06 01:33:55.148851 : Creating Coverage Files!, 0.064 mins elapsed. ## 2025-02-06 01:33:55.149982 : Batch Execution w/ safelapply!, 0.064 mins elapsed. ## 2025-02-06 01:33:55.158597 : Group B._.scATAC_BMMC_R1 (1 of 22) : Creating Group Coverage File : B._.scATAC_BMMC_R1.insertions.coverage.h5, 0.065 mins elapsed. ## Number of Cells = 254 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:34:50.760775 : Group B._.scATAC_PBMC_R1 (2 of 22) : Creating Group Coverage File : B._.scATAC_PBMC_R1.insertions.coverage.h5, 0.991 mins elapsed. ## Number of Cells = 162 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:35:43.707182 : Group CD4.M._.scATAC_PBMC_R1 (3 of 22) : Creating Group Coverage File : CD4.M._.scATAC_PBMC_R1.insertions.coverage.h5, 1.874 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:36:41.606504 : Group CD4.M._.scATAC_BMMC_R1 (4 of 22) : Creating Group Coverage File : CD4.M._.scATAC_BMMC_R1.insertions.coverage.h5, 2.839 mins elapsed. ## Number of Cells = 86 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:37:34.757879 : Group CD4.N._.scATAC_BMMC_R1 (5 of 22) : Creating Group Coverage File : CD4.N._.scATAC_BMMC_R1.insertions.coverage.h5, 3.725 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:38:29.43672 : Group CD4.N._.scATAC_PBMC_R1 (6 of 22) : Creating Group Coverage File : CD4.N._.scATAC_PBMC_R1.insertions.coverage.h5, 4.636 mins elapsed. ## Number of Cells = 48 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:39:22.12135 : Group CLP._.scATAC_CD34_BMMC_R1 (7 of 22) : Creating Group Coverage File : CLP._.scATAC_CD34_BMMC_R1.insertions.coverage.h5, 5.514 mins elapsed. ## Number of Cells = 298 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:40:16.300021 : Group CLP._.scATAC_BMMC_R1 (8 of 22) : Creating Group Coverage File : CLP._.scATAC_BMMC_R1.insertions.coverage.h5, 6.417 mins elapsed. ## Number of Cells = 88 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:41:09.215727 : Group Erythroid._.scATAC_CD34_BMMC_R1 (9 of 22) : Creating Group Coverage File : Erythroid._.scATAC_CD34_BMMC_R1.insertions.coverage.h5, 7.299 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:42:06.339707 : Group Erythroid._.scATAC_BMMC_R1 (10 of 22) : Creating Group Coverage File : Erythroid._.scATAC_BMMC_R1.insertions.coverage.h5, 8.251 mins elapsed. ## Number of Cells = 171 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:42:59.546889 : Group GMP._.scATAC_CD34_BMMC_R1 (11 of 22) : Creating Group Coverage File : GMP._.scATAC_CD34_BMMC_R1.insertions.coverage.h5, 9.138 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:43:56.516692 : Group GMP._.scATAC_BMMC_R1 (12 of 22) : Creating Group Coverage File : GMP._.scATAC_BMMC_R1.insertions.coverage.h5, 10.087 mins elapsed. ## Number of Cells = 310 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:44:53.315333 : Group Mono._.scATAC_PBMC_R1 (13 of 22) : Creating Group Coverage File : Mono._.scATAC_PBMC_R1.insertions.coverage.h5, 11.034 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:45:49.298475 : Group Mono._.scATAC_BMMC_R1 (14 of 22) : Creating Group Coverage File : Mono._.scATAC_BMMC_R1.insertions.coverage.h5, 11.967 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:46:46.450558 : Group NK._.scATAC_PBMC_R1 (15 of 22) : Creating Group Coverage File : NK._.scATAC_PBMC_R1.insertions.coverage.h5, 12.919 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:47:45.631898 : Group NK._.scATAC_BMMC_R1 (16 of 22) : Creating Group Coverage File : NK._.scATAC_BMMC_R1.insertions.coverage.h5, 13.906 mins elapsed. ## Number of Cells = 322 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:48:39.863301 : Group pDC._.scATAC_BMMC_R1 (17 of 22) : Creating Group Coverage File : pDC._.scATAC_BMMC_R1.insertions.coverage.h5, 14.81 mins elapsed. ## Number of Cells = 160 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:49:33.140777 : Group pDC._.scATAC_CD34_BMMC_R1 (18 of 22) : Creating Group Coverage File : pDC._.scATAC_CD34_BMMC_R1.insertions.coverage.h5, 15.698 mins elapsed. ## Number of Cells = 144 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:50:26.192653 : Group PreB._.Rep1 (19 of 22) : Creating Group Coverage File : PreB._.Rep1.insertions.coverage.h5, 16.582 mins elapsed. ## Number of Cells = 311 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:51:20.686608 : Group PreB._.Rep2 (20 of 22) : Creating Group Coverage File : PreB._.Rep2.insertions.coverage.h5, 17.49 mins elapsed. ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:52:15.22009 : Group Progenitor._.scATAC_CD34_BMMC_R1 (21 of 22) : Creating Group Coverage File : Progenitor._.scATAC_CD34_BMMC_R1.insertions.coverage.h5, 18.399 mins elapsed. ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:53:11.720643 : Group Progenitor._.scATAC_BMMC_R1 (22 of 22) : Creating Group Coverage File : Progenitor._.scATAC_BMMC_R1.insertions.coverage.h5, 19.341 mins elapsed. ## Number of Cells = 139 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 01:54:04.6391 : Adding Kmer Bias to Coverage Files!, 20.223 mins elapsed. ## Completed Kmer Bias Calculation ## Adding Kmer Bias (1 of 22) ## Adding Kmer Bias (2 of 22) ## Adding Kmer Bias (3 of 22) ## Adding Kmer Bias (4 of 22) ## Adding Kmer Bias (5 of 22) ## Adding Kmer Bias (6 of 22) ## Adding Kmer Bias (7 of 22) ## Adding Kmer Bias (8 of 22) ## Adding Kmer Bias (9 of 22) ## Adding Kmer Bias (10 of 22) ## Adding Kmer Bias (11 of 22) ## Adding Kmer Bias (12 of 22) ## Adding Kmer Bias (13 of 22) ## Adding Kmer Bias (14 of 22) ## Adding Kmer Bias (15 of 22) ## Adding Kmer Bias (16 of 22) ## Adding Kmer Bias (17 of 22) ## Adding Kmer Bias (18 of 22) ## Adding Kmer Bias (19 of 22) ## Adding Kmer Bias (20 of 22) ## Adding Kmer Bias (21 of 22) ## Adding Kmer Bias (22 of 22) ## 2025-02-06 01:56:27.555455 : Finished Creation of Coverage Files!, 22.605 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGroupCoverages-964f05836-Date-2025-02-06_Time-01-33-51.280901.log Once we have run addGroupCoverages(), this creates an entry in the project metadata of the ArchRProject, including a file path to the HDF5-format coverage object that is stored on disk. projHeme4@projectMetadata$GroupCoverages$Clusters2$coverageMetadata ## DataFrame with 22 rows and 5 columns ## Group Name File nCells ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;integer&gt; ## 1 B B._.scATAC_BMMC_R1 /workspace/ArchR/Arc.. 254 ## 2 B B._.scATAC_PBMC_R1 /workspace/ArchR/Arc.. 162 ## 3 CD4.M CD4.M._.scATAC_PBMC_R1 /workspace/ArchR/Arc.. 500 ## 4 CD4.M CD4.M._.scATAC_BMMC_R1 /workspace/ArchR/Arc.. 86 ## 5 CD4.N CD4.N._.scATAC_BMMC_R1 /workspace/ArchR/Arc.. 500 ## ... ... ... ... ... ## 18 pDC pDC._.scATAC_CD34_BM.. /workspace/ArchR/Arc.. 144 ## 19 PreB PreB._.Rep1 /workspace/ArchR/Arc.. 311 ## 20 PreB PreB._.Rep2 /workspace/ArchR/Arc.. 40 ## 21 Progenitor Progenitor._.scATAC_.. /workspace/ArchR/Arc.. 500 ## 22 Progenitor Progenitor._.scATAC_.. /workspace/ArchR/Arc.. 139 ## nInsertions ## &lt;numeric&gt; ## 1 1265606 ## 2 1054330 ## 3 4913052 ## 4 499060 ## 5 2156364 ## ... ... ## 18 1078804 ## 19 1985798 ## 20 203070 ## 21 3467572 ## 22 648132 We can also obtain the actual cell assignments for the pseudo-bulk replicates by calling addGroupCoverages() a second time using the returnGroups = TRUE. The returned object is a list of lists where each sub-list contains the replicates for a given cell group. groups &lt;- addGroupCoverages(ArchRProj = projHeme3, groupBy = &quot;Clusters2&quot;, returnGroups = TRUE) ## ArchR logging to : ArchRLogs/ArchR-addGroupCoverages-94018beea-Date-2025-02-06_Time-01-56-27.633734.log ## If there is an issue, please report to github with logFile! ## B (1 of 11) : CellGroups N = 2 ## CD4.M (2 of 11) : CellGroups N = 2 ## CD4.N (3 of 11) : CellGroups N = 2 ## CLP (4 of 11) : CellGroups N = 2 ## Erythroid (5 of 11) : CellGroups N = 2 ## GMP (6 of 11) : CellGroups N = 2 ## Mono (7 of 11) : CellGroups N = 2 ## NK (8 of 11) : CellGroups N = 2 ## pDC (9 of 11) : CellGroups N = 2 ## PreB (10 of 11) : CellGroups N = 2 ## Progenitor (11 of 11) : CellGroups N = 2 groups ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor If we looked at one of the sub-lists, we would see the cell names for each cell that was used to make up the given pseudo-bulk replicate. groups$B ## CharacterList of length 2 ## [[&quot;scATAC_BMMC_R1&quot;]] scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 ... ## [[&quot;scATAC_PBMC_R1&quot;]] scATAC_PBMC_R1#GCCCAGACATCGACCG-1 ... With these pseudo-bulk replicates generated, we can now call peaks in our data. As mentioned previously, we do not want to call peaks on the merged set of all single cells so having these more granular cell groups defined, either through clustering or otherwise, provides the ideal starting point for peak calling. "],["calling-peaks-with-archr.html", "Chapter 12 Calling Peaks with ArchR", " Chapter 12 Calling Peaks with ArchR Calling peaks is one of the most fundamental processes in ATAC-seq data analysis. Because per-cell scATAC-seq data is essentially binary (accessible or not accessible), we cannot call peaks on an individual cell basis. For this reason, we defined groups of cells, typically clusters, in a previous chapter. Moreover, we created pseudo-bulk replicates to allow us to assess the reproducibility of our peak calls. "],["the-iterative-overlap-peak-merging-procedure.html", "12.1 The Iterative Overlap Peak Merging Procedure", " 12.1 The Iterative Overlap Peak Merging Procedure We first introduced a strategy for iterative overlap peak merging in 2018. Other peak merging strategies suffer from a few key issues that we outline below. 12.1.1 Fixed-width vs Variable-width Peaks We use 501-bp fixed-width peaks because they make downstream computation easier as peak length does not need to be normalized. Moreover, the vast majority of peaks in ATAC-seq are less than 501-bp wide. Using variable-width peaks also makes it difficult to merge peak calls from multiple samples. In general, we do not feel that the potential benefit derived from using variable-width peaks outweighs the costs. More broadly, most analyses are stable with respect to the peak set or peak style used. Below, we use the same toy example of a few cell types with a few different peaks to illustrate the differences between these often used peak merging methods. 12.1.2 Raw Peak Overlap Using bedtools merge Raw peak overlap involves taking any peaks that overlap each other and merging these into a single larger peak. In this scheme, daisy-chaining becomes a large problem because peaks that dont directly overlap each other get included in the same larger peak because they are bridged by a shared internal peak. Another problem with this type of approach is that, if you want to keep track of peak summits, you are forced to either pick a single new summit for each new merged peak or keep track of all of the summits that apply to each new merged peak. Typically, this type of peak merging approach is implemented using the bedtools merge command. 12.1.3 Clustered Overlap Using bedtools cluster Clustered overlap takes peaks that cluster together and picks a single winner. This is often done by using the bedtools cluster command and then keeping the most significant peak in each cluster. In our experience, this ends up under-calling peaks and misses smaller peaks located nearby. 12.1.4 Iterative Overlap In ArchR Iterative overlap removal avoids the issues mentioned above. Peaks are first ranked by their significance. The most significant peak is retained and any peak that directly overlaps with the most significant peak is removed from further analysis. Then, of the remaining peaks, this process is repeated until no more peaks exist. This avoids daisy-chaining and still allows for use of fixed-width peaks. If you’ve come to this page looking to implement this iterative overlap peak merging procedure on bulk ATAC-seq data, this isn’t possible through ArchR but we host a separate repository that contains code to do this with bulk ATAC-seq. 12.1.5 Comparison of Peak Calling Methods Comparing the peak calls resulting from all of these methods directly shows clear differences in the final peak sets. It is our opinion that the iterative overlap peak merging process yields the best peak set with the fewest caveats. 12.1.6 So how does this all work in ArchR? The iterative overlap peak merging procedure is performed in a tiered fashion to optimally preserve cell type-specific peaks. Imagine a situation where you had 3 cell types, A, B, and C, and each cell type had 3 pseudo-bulk replicates. ArchR uses a function called addReproduciblePeakSet() to perform this iterative overlap peak merging procedure. First, ArchR would call peaks for each pseudo-bulk replicate individually. Then, ArchR would analyze all of the pseudo-bulk replicates from a single cell type together, performing the first iteration of iterative overlap removal. It is important to note that ArchR uses a normalized metric of significance for peaks to compare the significance of peaks called across different samples. This is because the reported MACS2 significance is proportional to the sequencing depth so peak significance is not immediately comparable across samples. After the first iteration of iterative overlap removal, ArchR checks to see the reproducibility of each peak across pseudo-bulk replicates and only keeps peaks that pass a threshold indicated by the reproducibility parameter. At the end of this process, we would have a single merged peak set for each of the 3 cell types, A, B, and C. Then, we would repeat this procedure to merge the A, B, and C peak sets. To do this, we re-normalize the peak significance across the different cell types, and perform the iterative overlap removal. The final result of this is a single merged peak set of fixed-width peaks. 12.1.7 What if I don’t like this iterative overlap peak merging process? The iterative overlap peak merging process is implemented by ArchR via addReproduciblePeakSet() but you can always use your own peak set via ArchRProj &lt;- addPeakSet(). "],["calling-peaks-w-macs2.html", "12.2 Calling Peaks w/ Macs2", " 12.2 Calling Peaks w/ Macs2 Prior to calling peaks in ArchR, you must run the addGroupCoverages() function! ArchR relies on these group coverage objects to perform peak calling. As mentioned above, we generate a reproducible peak set in ArchR using the addReproduciblePeakSet() function. By default ArchR attempts to call peaks using MACS2 and this is absolutely the recommended peak caller. ArchR also implements its own native peak caller but we do not recommend using it - this alternative peak calling method is described in the next section. To call peaks using MACS2, ArchR must be able to find the MACS2 executable. First, ArchR looks in your PATH environment variable. If this is unsuccessful, ArchR attempts to determine if you have installed MACS2 with either pip or pip3. If neither of these is successful, ArchR gives up and provides an error message. If you have MACS2 installed and ArchR cannot find it, you should provide the path to the addReproduciblePeakSet() function via the pathToMacs2 parameter. It is important to make sure that the MACS2 executable that ArchR is using is what you expect it to use. Some users have multiple instances of MACS2 installed and ArchR may not automatically select the one that you expect. pathToMacs2 &lt;- findMacs2() ## Searching For MACS2.. ## Found with $PATH at /usr/local/bin/macs2 You could, of course, manually designate the path to the MACS2 executable instead. This may be necessary on some computational environments. With the path to MACS2 identified, we can then create a reproducible merged peak set w/ MACS2 (5-10 minutes). To avoid bias from pseudo-bulk replicates that have very few cells, we can provide a cutoff for the upper limit of the number of peaks called per cell via the peaksPerCell parameter. This prevents clusters with very few cells from contributing lots of low quality peaks to the merged peak set. There are many other parameters that can be tweaked in addReproduciblePeakSet() - try ?addReproduciblePeakSet or check out the online function definition for more information. Of particular note, the reproducibility parameter defines what is meant by a “reproducible peak”. For example, reproducibility = \"2\" means at least 2 pseudo-bulk replicates must have a peak call at this locus and reproducibility = \"(n+1)/2\" means that the majority of pseudo-bulk replicates must have a peak call at this locus. projHeme4 &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters2&quot;, pathToMacs2 = pathToMacs2 ) ## ArchR logging to : ArchRLogs/ArchR-addReproduciblePeakSet-938fc9c7d-Date-2025-02-06_Time-01-57-22.608531.log ## If there is an issue, please report to github with logFile! ## Calling Peaks with Macs2 ## 2025-02-06 01:57:23.144445 : Peak Calling Parameters!, 0.009 mins elapsed. ## Group nCells nCellsUsed nReplicates nMin nMax maxPeaks ## B B 421 416 2 162 254 150000 ## CD4.M CD4.M 633 586 2 86 500 150000 ## CD4.N CD4.N 1250 548 2 48 500 150000 ## CLP CLP 386 386 2 88 298 150000 ## Erythroid Erythroid 702 671 2 171 500 150000 ## GMP GMP 1261 810 2 310 500 150000 ## Mono Mono 2652 1000 2 500 500 150000 ## NK NK 903 822 2 322 500 150000 ## pDC pDC 314 304 2 144 160 150000 ## PreB PreB 351 351 2 40 311 150000 ## Progenitor Progenitor 1377 639 2 139 500 150000 ## 2025-02-06 01:57:23.179426 : Batching Peak Calls!, 0.009 mins elapsed. ## 2025-02-06 01:57:23.321666 : Batch Execution w/ safelapply!, 0 mins elapsed. ## 2025-02-06 01:58:25.138741 : Identifying Reproducible Peaks!, 1.042 mins elapsed. ## ## .rds&quot; ## 2025-02-06 01:58:30.502697 : Creating Union Peak Set!, 1.132 mins elapsed. ## Converged after 9 iterations! ## Plotting Ggplot! ## 2025-02-06 01:58:38.413358 : Finished Creating Union Peak Set (147407)!, 1.263 mins elapsed. The iterative overlap procedure that ArchR uses to create this reproducible peak set occurs in two stages. During the first step of addReproduciblePeakSet(), a reproducible peak set is created for each group indicated by groupBy. Using the psuedobulk replicates generated by addGroupCoverages(), ArchR identifies peaks that are reproducible across the replicates for each group indicated by the groupBy argument. The score of those peak calls is stored in the score column and the quantile rank of that score for the individual pseudobulk replicate that it was identified in is stored in replicateScoreQuantile. It is this quantile normalization that accounts for differences in number of fragments per group etc. that affect peak calling. For each of these groups, ArchR saves the group-specific peak set as a GRanges object in the PeakCalls subdirectory of the ArchRProject. Additionally, ArchR saves a a GRanges object that contains the summit calls for each pseudobulk replicate within the ./PeakCalls/ReplicateCalls directory. list.files(path=paste0(getOutputDirectory(ArchRProj = projHeme4),&quot;/PeakCalls&quot;)) ## [1] &quot;B-reproduciblePeaks.gr.rds&quot; &quot;CD4.M-reproduciblePeaks.gr.rds&quot; ## [3] &quot;CD4.N-reproduciblePeaks.gr.rds&quot; &quot;CLP-reproduciblePeaks.gr.rds&quot; ## [5] &quot;Clusters2&quot; &quot;Erythroid-reproduciblePeaks.gr.rds&quot; ## [7] &quot;GMP-reproduciblePeaks.gr.rds&quot; &quot;Mono-reproduciblePeaks.gr.rds&quot; ## [9] &quot;NK-reproduciblePeaks.gr.rds&quot; &quot;pDC-reproduciblePeaks.gr.rds&quot; ## [11] &quot;PreB-reproduciblePeaks.gr.rds&quot; &quot;Progenitor-reproduciblePeaks.gr.rds&quot; During the second step of addReproduciblePeakSet(), ArchR merges these group-specific peak sets into a single union peak set. The quantile rank of the peak score across the group is stored in groupScoreQuantile and the group it comes from is stored in GroupReplicate. GroupReplicate is an annotation for the group from which each peak originated during the process of iterative overlap peak merging. It is important to note that these annotations do not inherently mean that the given peak was only called in that cell group, rather that the annotated group had the highest normalized significance for that peak call. Each ArchRProject object can only contain a single peak set at a time. As such, we assign the output of addReproduciblePeakSet() to our desired ArchRProject. If you would like to experiment with different peak sets, you have two options. Option #1 - you can save multiple copies of your ArchRProject using saveArchRProject(). Option #2 - you can create multiple peak sets, store them as GenomicRanges objects, and change your peak set using the addPeakSet() function. The addPeakSet() function can be used to set any arbitrary peak set as the peak set for your ArchRProject. To retrieve the peak set stored in your ArchRProject as a GRanges object, we use the getPeakSet() function. getPeakSet(projHeme4) ## GRanges object with 147407 ranges and 13 metadata columns: ## seqnames ranges strand | score ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; ## Mono chr1 752503-753003 * | 41.29950 ## B chr1 762688-763188 * | 46.92020 ## GMP chr1 773648-774148 * | 6.32548 ## CD4.M chr1 779906-780406 * | 8.42088 ## B chr1 801002-801502 * | 11.64360 ## ... ... ... ... . ... ## NK chrX 154807254-154807754 * | 4.70336 ## PreB chrX 154840939-154841439 * | 1.45332 ## PreB chrX 154841881-154842381 * | 4.49383 ## NK chrX 154842390-154842890 * | 19.94720 ## Progenitor chrX 154862036-154862536 * | 13.05070 ## replicateScoreQuantile groupScoreQuantile Reproducibility ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## Mono 0.855 0.733 2 ## B 0.936 0.860 2 ## GMP 0.585 0.242 2 ## CD4.M 0.394 0.130 2 ## B 0.608 0.318 2 ## ... ... ... ... ## NK 0.399 0.131 2 ## PreB 0.242 0.052 2 ## PreB 0.441 0.108 2 ## NK 0.770 0.603 2 ## Progenitor 0.710 0.256 2 ## GroupReplicate distToGeneStart nearestGene peakType ## &lt;character&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; ## Mono Mono._.scATAC_BMMC_R1 10148 LINC00115 Distal ## B B._.scATAC_PBMC_R1 32 LINC01128 Promoter ## GMP GMP._.scATAC_CD34_BM.. 10926 LINC01128 Intronic ## CD4.M CD4.M._.scATAC_PBMC_R1 17184 LINC01128 Intronic ## B B._.scATAC_PBMC_R1 10929 FAM41C Distal ## ... ... ... ... ... ## NK NK._.scATAC_BMMC_R1 35117 TMLHE Intronic ## PreB PreB._.Rep2 1432 TMLHE Intronic ## PreB PreB._.Rep1 490 TMLHE Intronic ## NK NK._.scATAC_BMMC_R1 17 TMLHE Promoter ## Progenitor Progenitor._.scATAC_.. 19663 TMLHE Distal ## distToTSS nearestTSS GC idx N ## &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt; ## Mono 10148 uc010nxx.2 0.4830 1 0 ## B 32 uc031pjj.1 0.6966 2 0 ## GMP 10719 uc031pjk.1 0.4571 3 0 ## CD4.M 16977 uc031pjk.1 0.4850 4 0 ## B 10929 uc001abt.4 0.4371 5 0 ## ... ... ... ... ... ... ## NK 35117 uc004fnn.3 0.4990 3538 0 ## PreB 1432 uc004fnn.3 0.4271 3539 0 ## PreB 490 uc004fnn.3 0.5729 3540 0 ## NK 17 uc004fnn.3 0.6008 3541 0 ## Progenitor 19663 uc004fnn.3 0.4251 3542 0 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths The peak sets from addReproduciblePeakSet() are annotated with lots of metadata about each peak region. The score represents the normalized -log10(pval) returned by MACS2. There are other annotations such as distToGeneStart and distToTSS which are determined based on the contents of getGeneAnnotation(ArchRProj)$genes and getGeneAnnotation(ArchRProj)$TSS respectively. While it may seem like these should be identical, a single gene can have multiple TSSs and ArchR needs to deal with this multi-mapping issue, which we have done by including both annotations. For example, in ArchR’s default hg38 geneAnnotation, there are 23,274 genes and 49,052 TSSs. One confusing piece of information annotated in the peak set is the idx column which does not correspond to a unique peak identifier. Instead the idx column is actually only unique per-chromosome, so for a peak located on “chr1” with and idx of “5”, this means that this is the 5th peak in sequential order on “chr1” (but there would also be a peak with idx of “5” on “chr2”). "],["calling-peaks-w-tilematrix.html", "12.3 Calling Peaks w/ TileMatrix", " 12.3 Calling Peaks w/ TileMatrix As mentioned previously, ArchR also implements its own native peak caller but we do not recommend using it. While we have benchmarked this peak caller against MACS2 and note very similar performances, we do not recommend using this native peak caller unless absolutely necessary. It is no longer actively supported in the ArchR code base. The ArchR native peak caller calls peaks on the 500-bp TileMatrix and we indicate to addReproduciblePeakSet() that we want to use this peak caller via the peakMethod parameter. Note that we are not storing the output into the projHeme4 object because we do not intend to keep this peak set and this analysis is only for illustrative purposes. Storage into the ArchRProject object would overwrite the previous reproducible peak set already stored in projHeme4. projHemeTmp &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters2&quot;, peakMethod = &quot;Tiles&quot;, method = &quot;p&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addReproduciblePeakSet-9286e8c5f-Date-2025-02-06_Time-01-58-48.55566.log ## If there is an issue, please report to github with logFile! ## Calling Peaks with TileMatrix. We recommend using the Macs2 Version. ## This method is still under development. ## Group Coverages Already Computed Returning Groups, Set force = TRUE to Recompute! ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor ## 2025-02-06 01:58:49.348169 : Peak Calling Parameters!, 0.013 mins elapsed. ## Group nCells nCellsUsed nReplicates nMin nMax maxPeaks ## B B 421 416 2 162 254 150000 ## CD4.M CD4.M 633 586 2 86 500 150000 ## CD4.N CD4.N 1250 548 2 48 500 150000 ## CLP CLP 386 386 2 88 298 150000 ## Erythroid Erythroid 702 671 2 171 500 150000 ## GMP GMP 1261 810 2 310 500 150000 ## Mono Mono 2652 1000 2 500 500 150000 ## NK NK 903 822 2 322 500 150000 ## pDC pDC 314 304 2 144 160 150000 ## PreB PreB 351 351 2 40 311 150000 ## Progenitor Progenitor 1377 639 2 139 500 150000 ## 2025-02-06 01:58:53.23755 : Computing Total Accessibility Across All Features, 0.078 mins elapsed. ## 2025-02-06 01:58:56.607124 : Computing Pseudo-Grouped Tile Matrix, 0.134 mins elapsed. ## 2025-02-06 01:59:26.047958 : Created Pseudo-Grouped Tile Matrix (0.471 GB), 0.625 mins elapsed. ## colSums = 825382colSums = 660560colSums = 3022271colSums = 323151colSums = 1406092colSums = 153415colSums = 1096638colSums = 276220colSums = 2290759colSums = 670817colSums = 2221092colSums = 2253776colSums = 2111952colSums = 2471475colSums = 3602112colSums = 1148728colSums = 772246colSums = 640088colSums = 1295679colSums = 131806colSums = 2058797colSums = 430702 ## nTiles = 6072620 ## Expectation = 0.13591859856207Expectation = 0.10877677180525Expectation = 0.497688147784646Expectation = 0.0532144280392977Expectation = 0.231546185995501Expectation = 0.0252633953713554Expectation = 0.180587291811442Expectation = 0.0454861328388735Expectation = 0.377227457011965Expectation = 0.11046582858799Expectation = 0.365755143578884Expectation = 0.371137334461896Expectation = 0.347782670412441Expectation = 0.406986605452012Expectation = 0.593172633887844Expectation = 0.189165137947048Expectation = 0.127168503874769Expectation = 0.10540557452961Expectation = 0.213364083377521Expectation = 0.0217049642493685Expectation = 0.339029446927356Expectation = 0.0709252349068442 ## 2025-02-06 01:59:47.694666 : Creating Group Peak Sets with Annotations!, 0.986 mins elapsed. ## 2025-02-06 01:59:55.344699 : Creating Union Peak Set with Annotations!, 1.113 mins elapsed. ## Annotating Peaks : Nearest Gene ## Annotating Peaks : Gene ## Annotating Peaks : TSS ## Annotating Peaks : GC ## Plotting Ggplot! ## 2025-02-06 02:00:09.962552 : Finished Creating Union Peak Set (263147)!, 1.357 mins elapsed. We can similarly examine this merged peak set. getPeakSet(projHemeTmp) ## GRanges object with 263147 ranges and 10 metadata columns: ## seqnames ranges strand | mlog10p Group ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;Rle&gt; ## [1] chr1 752500-752999 * | 6.311 Mono ## [2] chr1 757500-757999 * | 3.426 CD4.N ## [3] chr1 758500-758999 * | 1.177 NK ## [4] chr1 762000-762499 * | 1.479 NK ## [5] chr1 762500-762999 * | 25.802 NK ## ... ... ... ... . ... ... ## [263143] chrX 154842000-154842499 * | 6.554 CLP ## [263144] chrX 154842500-154842999 * | 5.993 PreB ## [263145] chrX 154862000-154862499 * | 3.312 Progenitor ## [263146] chrX 154862500-154862999 * | 1.262 NK ## [263147] chrX 154997000-154997499 * | 2.034 Progenitor ## distToGeneStart nearestGene peakType distToTSS nearestTSS ## &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;integer&gt; &lt;character&gt; ## [1] 10152 LINC00115 Distal 10152 uc010nxx.2 ## [2] 5152 LINC00115 Distal 5152 uc010nxx.2 ## [3] 4152 LINC00115 Distal 4152 uc010nxx.2 ## [4] 652 LINC00115 Promoter 652 uc010nxx.2 ## [5] 152 LINC00115 Promoter 152 uc010nxx.2 ## ... ... ... ... ... ... ## [263143] 372 TMLHE Intronic 372 uc004fnn.3 ## [263144] 126 TMLHE Promoter 126 uc004fnn.3 ## [263145] 19626 TMLHE Distal 19626 uc004fnn.3 ## [263146] 20126 TMLHE Distal 20126 uc004fnn.3 ## [263147] 154626 TMLHE Distal 201 uc004fnq.1 ## GC idx N ## &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt; ## [1] 0.484 1 0 ## [2] 0.552 2 0 ## [3] 0.560 3 0 ## [4] 0.574 4 0 ## [5] 0.684 5 0 ## ... ... ... ... ## [263143] 0.612 6175 0 ## [263144] 0.554 6176 0 ## [263145] 0.430 6177 0 ## [263146] 0.420 6178 0 ## [263147] 0.542 6179 0 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths 12.3.1 Comparing the two peak calling methods To compare the merged peak set generated using MACS2 vs the merged peak set generated using the ArchR native TileMatrix peak caller, we can check the perfecent of overlapping peaks etc. First, we check the percent of MACS2-called peaks that are overlapped by the TileMatrix-called peaks. length(subsetByOverlaps(getPeakSet(projHeme4), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) ## [1] 0.9565828 Then, we check the converse - the percent of TileMatrix-called peaks that are overlapped by MACS2-called peaks. You can see that this overlap is not as strong. length(subsetByOverlaps(getPeakSet(projHemeTmp), getPeakSet(projHeme4))) / length(getPeakSet(projHemeTmp)) ## [1] 0.7852683 If we increase the margins of the peaks to be wider (1000-bp peaks instead of 500-bp peaks), the percent of MACS2-called peaks that are overlapped does not change much. length(subsetByOverlaps(resize(getPeakSet(projHeme4), 1000, &quot;center&quot;), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) ## [1] 0.9619421 But the percent of TileMatrix-called peaks overlapped by MACS2 does increase. length(subsetByOverlaps(getPeakSet(projHemeTmp), resize(getPeakSet(projHeme4), 1000, &quot;center&quot;))) / length(getPeakSet(projHemeTmp)) ## [1] 0.8581781 "],["adding-a-peak-matrix.html", "12.4 Adding a Peak Matrix", " 12.4 Adding a Peak Matrix We can now save our original projHeme4 using the saveArchRProject() function. This ArchRProject contains the MACS2-derived merged peak set. Here, we set load = TRUE to make sure that the projHeme4 object tracks with the project that we just saved. projHeme4 &lt;- saveArchRProject(ArchRProj = projHeme4, outputDirectory = &quot;Save-ProjHeme4&quot;, load = TRUE) ## Copying ArchRProject to new outputDirectory : /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4 ## Copying Arrow Files... ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## Copying Other Files... ## Copying Other Files (1 of 8): Embeddings ## Copying Other Files (2 of 8): GroupCoverages ## Copying Other Files (3 of 8): IterativeLSI ## Copying Other Files (4 of 8): IterativeLSI2 ## Copying Other Files (5 of 8): IterativeLSI3 ## Copying Other Files (6 of 8): PeakCalls ## Copying Other Files (7 of 8): Plots ## Copying Other Files (8 of 8): RNAIntegration ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## To prepare for downstream analyses, we can create a new ArchRProject called projHeme5 and add a new matrix to it containing insertion counts within our new merged peak set. projHeme5 &lt;- addPeakMatrix(projHeme4) ## ArchR logging to : ArchRLogs/ArchR-addPeakMatrix-934274db9-Date-2025-02-06_Time-02-00-47.157951.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:00:47.409308 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeakMatrix-934274db9-Date-2025-02-06_Time-02-00-47.157951.log One important salient point in the above operation is that the R object projHeme5 is actually still pointing to the directory corresponding to projHeme4. Hopefully this illustrates the nuance of saving and loading ArchR projects and the difference between the R ArchRProject object and the objects saved on disk. The output directory for projHeme5 will not be set until we save this object using saveArchRProject() and set the outputDirectory. Until then, anything that we do to projHeme5 will update the contents in the “Save-ProjHeme4” directory. getOutputDirectory(ArchRProj = projHeme5) ## [1] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4&quot; Within projHeme5, we can now see that a new matrix has been added called “PeakMatrix”. This is another reserved-name matrix similar to GeneScoreMatrix and TileMatrix. As mentioned previously, each ArchRProject object can only have one peak set and one PeakMatrix. You can, of course, create an unlimited number of custom feature matrices of different names but PeakMatrix is reserved for the matrix of insertion counts derived from the peak set stored in the ArchRProject. getAvailableMatrices(projHeme5) ## [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;PeakMatrix&quot; ## [4] &quot;TileMatrix&quot; "],["identifying-marker-peaks.html", "Chapter 13 Identifying Marker Peaks", " Chapter 13 Identifying Marker Peaks We have introduced the identification of marker features previously in the chapter discussing gene scores. The same function (getMarkerFeatures()) can be used to identify marker features from any matrix stored in an ArchRProject. Marker features are features that are unique to a specific cell grouping. These can be very useful in understanding cluster- or cell type-specific biology. In this chapter, we will discuss how to use this function to identify marker peaks. "],["identifying-marker-peaks-with-archr.html", "13.1 Identifying Marker Peaks with ArchR", " 13.1 Identifying Marker Peaks with ArchR Often times, we are interested to know which peaks are unique to an individual cluster or a small group of clusters. We can do this in an unsupervised fashion in ArchR using the addMarkerFeatures() function in combination with useMatrix = \"PeakMatrix\". First, lets remind ourselves of the cell types that we are working with in projHeme5 and their relative proportions. table(projHeme5$Clusters2) ## ## B CD4.M CD4.N CLP Erythroid GMP Mono ## 421 633 1250 386 702 1261 2652 ## NK pDC PreB Progenitor ## 903 314 351 1377 Now, we are ready to identify marker peaks by calling the addMarkerFeatures() function with useMatrix = \"PeakMatrix\". Additionally, we tell ArchR to account for differences in data quality amongst the cell groups by setting the bias parameter to account for TSS enrichment and the number of unique fragments per cell. markerPeaks &lt;- getMarkerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-96be4b233-Date-2025-02-06_Time-02-03-45.434572.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Integer.Matrix ## 2025-02-06 02:03:46.394397 : Matching Known Biases, 0.005 mins elapsed. ## ########### ## 2025-02-06 02:05:55.075573 : Completed Pairwise Tests, 2.15 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-96be4b233-Date-2025-02-06_Time-02-03-45.434572.log The object returned by the getMarkerFeatures() function is a SummarizedExperiment that contains a few different assays. markerPeaks ## class: SummarizedExperiment ## dim: 147407 11 ## metadata(2): MatchInfo Params ## assays(7): Log2FC Mean ... AUC MeanBGD ## rownames(147407): 1 2 ... 147406 147407 ## rowData names(4): seqnames idx start end ## colnames(11): B CD4.M ... PreB Progenitor ## colData names(0): We can use the getMarkers() function to retrieve particular slices of this SummarizedExperiment that we are interested in. The default behavior of this function is to return a list of DataFrame objects, one for each cell group. markerList &lt;- getMarkers(markerPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;) markerList ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor If we are interested in the marker peaks for a specific cell group, we can access this from the list via the $ accessor. markerList$Erythroid ## DataFrame with 2871 rows and 7 columns ## seqnames idx start end Log2FC FDR MeanDiff ## &lt;Rle&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 91169 chr22 1297 30129829 30130329 4.56041 3.24640e-16 1.090454 ## 45636 chr15 1214 50552646 50553146 4.33461 6.58297e-14 0.882263 ## 127421 chr7 3093 65392660 65393160 8.98553 3.73382e-13 1.017888 ## 8954 chr1 8954 156864638 156865138 6.58465 3.83815e-13 0.978842 ## 7130 chr1 7130 110407020 110407520 4.23204 4.88410e-13 0.859836 ## ... ... ... ... ... ... ... ... ## 139717 chr9 2044 86957967 86958467 6.22430 0.0099907 0.148421 ## 141515 chr9 3842 119117633 119118133 6.59935 0.0099907 0.193083 ## 143169 chr9 5496 136544169 136544669 6.08502 0.0099907 0.134577 ## 146831 chrX 2966 133937841 133938341 6.17985 0.0099907 0.143857 ## 146835 chrX 2970 133999808 134000308 6.15916 0.0099907 0.141780 Instead of a list of DataFrame objects, we can use getMarkers() to return a GRangesList object by setting returnGR = TRUE. markerList &lt;- getMarkers(markerPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE) markerList ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor This GRangesList object can similarly be subset to a GRanges object for a particular cell group using the $ accessor. markerList$Erythroid ## GRanges object with 2871 ranges and 3 metadata columns: ## seqnames ranges strand | Log2FC FDR MeanDiff ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] chr22 30129829-30130329 * | 4.56041 3.24640e-16 1.090454 ## [2] chr15 50552646-50553146 * | 4.33461 6.58297e-14 0.882263 ## [3] chr7 65392660-65393160 * | 8.98553 3.73382e-13 1.017888 ## [4] chr1 156864638-156865138 * | 6.58465 3.83815e-13 0.978842 ## [5] chr1 110407020-110407520 * | 4.23204 4.88410e-13 0.859836 ## ... ... ... ... . ... ... ... ## [2867] chr9 86957967-86958467 * | 6.22430 0.0099907 0.148421 ## [2868] chr9 119117633-119118133 * | 6.59935 0.0099907 0.193083 ## [2869] chr9 136544169-136544669 * | 6.08502 0.0099907 0.134577 ## [2870] chrX 133937841-133938341 * | 6.17985 0.0099907 0.143857 ## [2871] chrX 133999808-134000308 * | 6.15916 0.0099907 0.141780 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths "],["plotting-marker-peaks-in-archr.html", "13.2 Plotting Marker Peaks in ArchR", " 13.2 Plotting Marker Peaks in ArchR ArchR provides multiple plotting functions to interact with the SummarizedExperiment objects returned by getMarkerFeatures(). 13.2.1 Marker Peak Heatmaps We can visualize these marker peaks (or any features output by getMarkerFeatures()) as a heatmap using the markerHeatmap() function. heatmapPeaks &lt;- markerHeatmap( seMarker = markerPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot;, transpose = TRUE ) ## Warning in markerHeatmap(seMarker = markerPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot;, : &#39;markerHeatmap&#39; is deprecated. ## Use &#39;plotMarkerHeatmap&#39; instead. ## See help(&quot;Deprecated&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotMarkerHeatmap-94919e099-Date-2025-02-06_Time-02-05-58.302956.log ## If there is an issue, please report to github with logFile! ## Identified 39750 markers! ## [1] &quot;chr1:801002-801502&quot; &quot;chr1:3582765-3583265&quot; ## [3] &quot;chr1:4067046-4067546&quot; &quot;chr1:4067547-4068047&quot; ## [5] &quot;chr1:4087539-4088039&quot; &quot;chr1:8484558-8485058&quot; ## [7] &quot;chr1:8689823-8690323&quot; &quot;chr1:8703539-8704039&quot; ## [9] &quot;chr1:10555108-10555608&quot; &quot;chr1:15898189-15898689&quot; ## [11] &quot;chr1:16023323-16023823&quot; &quot;chr1:21619451-21619951&quot; ## [13] &quot;chr1:25068767-25069267&quot; &quot;chr1:25075151-25075651&quot; ## [15] &quot;chr1:31226442-31226942&quot; &quot;chr1:894948-895448&quot; ## [17] &quot;chr1:1003989-1004489&quot; &quot;chr1:1004514-1005014&quot; ## [19] &quot;chr1:1186236-1186736&quot; &quot;chr1:1307365-1307865&quot; ## [21] &quot;chr1:1564144-1564644&quot; &quot;chr1:1624355-1624855&quot; ## [23] &quot;chr1:1709691-1710191&quot; &quot;chr1:1850076-1850576&quot; ## [25] &quot;chr1:2125990-2126490&quot; &quot;chr1:2163258-2163758&quot; ## [27] &quot;chr1:2190376-2190876&quot; &quot;chr1:2219656-2220156&quot; ## [29] &quot;chr1:2456986-2457486&quot; &quot;chr1:2478190-2478690&quot; ## [31] &quot;chr1:1034082-1034582&quot; &quot;chr1:2084331-2084831&quot; ## [33] &quot;chr1:3541219-3541719&quot; &quot;chr1:6425064-6425564&quot; ## [35] &quot;chr1:9353416-9353916&quot; &quot;chr1:9777575-9778075&quot; ## [37] &quot;chr1:24741889-24742389&quot; &quot;chr1:24862920-24863420&quot; ## [39] &quot;chr1:25256670-25257170&quot; &quot;chr1:26453043-26453543&quot; ## [41] &quot;chr1:26560290-26560790&quot; &quot;chr1:26560899-26561399&quot; ## [43] &quot;chr1:26644119-26644619&quot; &quot;chr1:28157016-28157516&quot; ## [45] &quot;chr1:29241862-29242362&quot; &quot;chr1:1114597-1115097&quot; ## [47] &quot;chr1:1827293-1827793&quot; &quot;chr1:5777263-5777763&quot; ## [49] &quot;chr1:6640958-6641458&quot; &quot;chr1:8908019-8908519&quot; ## [51] &quot;chr1:9483076-9483576&quot; &quot;chr1:11435901-11436401&quot; ## [53] &quot;chr1:11467280-11467780&quot; &quot;chr1:11741206-11741706&quot; ## [55] &quot;chr1:15033099-15033599&quot; &quot;chr1:20539344-20539844&quot; ## [57] &quot;chr1:21840612-21841112&quot; &quot;chr1:23242764-23243264&quot; ## [59] &quot;chr1:23938407-23938907&quot; &quot;chr1:25983661-25984161&quot; ## [61] &quot;chr1:901237-901737&quot; &quot;chr1:940307-940807&quot; ## [63] &quot;chr1:1343009-1343509&quot; &quot;chr1:1790050-1790550&quot; ## [65] &quot;chr1:2253303-2253803&quot; &quot;chr1:3087565-3088065&quot; ## [67] &quot;chr1:3244618-3245118&quot; &quot;chr1:3309996-3310496&quot; ## [69] &quot;chr1:3458494-3458994&quot; &quot;chr1:3535461-3535961&quot; ## [71] &quot;chr1:3691326-3691826&quot; &quot;chr1:3709928-3710428&quot; ## [73] &quot;chr1:3797614-3798114&quot; &quot;chr1:3827259-3827759&quot; ## [75] &quot;chr1:4388440-4388940&quot; &quot;chr1:974855-975355&quot; ## [77] &quot;chr1:2718089-2718589&quot; &quot;chr1:6230804-6231304&quot; ## [79] &quot;chr1:9256149-9256649&quot; &quot;chr1:33001674-33002174&quot; ## [81] &quot;chr1:41326368-41326868&quot; &quot;chr1:41740351-41740851&quot; ## [83] &quot;chr1:46879252-46879752&quot; &quot;chr1:55012580-55013080&quot; ## [85] &quot;chr1:58717033-58717533&quot; &quot;chr1:65211889-65212389&quot; ## [87] &quot;chr1:95007225-95007725&quot; &quot;chr1:153463131-153463631&quot; ## [89] &quot;chr1:154164635-154165135&quot; &quot;chr1:164629628-164630128&quot; ## [91] &quot;chr1:752503-753003&quot; &quot;chr1:1695617-1696117&quot; ## [93] &quot;chr1:2082662-2083162&quot; &quot;chr1:2177471-2177971&quot; ## [95] &quot;chr1:3594066-3594566&quot; &quot;chr1:3817707-3818207&quot; ## [97] &quot;chr1:6116567-6117067&quot; &quot;chr1:6461667-6462167&quot; ## [99] &quot;chr1:6662810-6663310&quot; &quot;chr1:7812853-7813353&quot; ## [101] &quot;chr1:7830467-7830967&quot; &quot;chr1:8157406-8157906&quot; ## [103] &quot;chr1:8166808-8167308&quot; &quot;chr1:8187085-8187585&quot; ## [105] &quot;chr1:8264317-8264817&quot; &quot;chr1:762688-763188&quot; ## [107] &quot;chr1:936020-936520&quot; &quot;chr1:937143-937643&quot; ## [109] &quot;chr1:975963-976463&quot; &quot;chr1:1151699-1152199&quot; ## [111] &quot;chr1:1152426-1152926&quot; &quot;chr1:1154919-1155419&quot; ## [113] &quot;chr1:1157229-1157729&quot; &quot;chr1:1550542-1551042&quot; ## [115] &quot;chr1:1564670-1565170&quot; &quot;chr1:1566009-1566509&quot; ## [117] &quot;chr1:1566556-1567056&quot; &quot;chr1:1623712-1624212&quot; ## [119] &quot;chr1:2130583-2131083&quot; &quot;chr1:2159937-2160437&quot; ## [121] &quot;chr1:1144252-1144752&quot; &quot;chr1:1148692-1149192&quot; ## [123] &quot;chr1:1779297-1779797&quot; &quot;chr1:8030215-8030715&quot; ## [125] &quot;chr1:8487539-8488039&quot; &quot;chr1:12270564-12271064&quot; ## [127] &quot;chr1:13820452-13820952&quot; &quot;chr1:16416449-16416949&quot; ## [129] &quot;chr1:17340271-17340771&quot; &quot;chr1:17349561-17350061&quot; ## [131] &quot;chr1:19732550-19733050&quot; &quot;chr1:20404699-20405199&quot; ## [133] &quot;chr1:22198382-22198882&quot; &quot;chr1:24515858-24516358&quot; ## [135] &quot;chr1:24884301-24884801&quot; &quot;chr1:1710193-1710693&quot; ## [137] &quot;chr1:1774220-1774720&quot; &quot;chr1:2431340-2431840&quot; ## [139] &quot;chr1:6550424-6550924&quot; &quot;chr1:6647419-6647919&quot; ## [141] &quot;chr1:9473097-9473597&quot; &quot;chr1:9909588-9910088&quot; ## [143] &quot;chr1:11751400-11751900&quot; &quot;chr1:21620771-21621271&quot; ## [145] &quot;chr1:25876088-25876588&quot; &quot;chr1:26614813-26615313&quot; ## [147] &quot;chr1:26867944-26868444&quot; &quot;chr1:31228531-31229031&quot; ## [149] &quot;chr1:31949772-31950272&quot; &quot;chr1:33523825-33524325&quot; ## [151] &quot;chr1:845326-845826&quot; &quot;chr1:856366-856866&quot; ## [153] &quot;chr1:1079376-1079876&quot; &quot;chr1:1831052-1831552&quot; ## [155] &quot;chr1:2058527-2059027&quot; &quot;chr1:2210498-2210998&quot; ## [157] &quot;chr1:2221973-2222473&quot; &quot;chr1:2225956-2226456&quot; ## [159] &quot;chr1:2487416-2487916&quot; &quot;chr1:2762418-2762918&quot; ## [161] &quot;chr1:2804983-2805483&quot; &quot;chr1:2829132-2829632&quot; ## [163] &quot;chr1:3010359-3010859&quot; &quot;chr1:3098465-3098965&quot; ## [165] &quot;chr1:3138712-3139212&quot; ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotMarkerHeatmap-94919e099-Date-2025-02-06_Time-02-05-58.302956.log We can plot this heatmap using draw(). draw(heatmapPeaks, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(heatmapPeaks, name = &quot;Peak-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting ComplexHeatmap! 13.2.2 Marker Peak MA and Volcano Plots Instead of plotting a heatmap, we can also plot an MA or Volcano plot for any individual cell group. To do this, we use the plotMarkers() function. For an MA plot we specify plotAs = \"MA\". Here we specify the “Erythroid” cell group via the name parameter. pma &lt;- plotMarkers(seMarker = markerPeaks, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma ## Warning: Removed 48 rows containing missing values or values outside the scale ## range (`geom_point_rast()`). Similarly, for a Volcano plot, we specify plotAs = \"Volcano\". pv &lt;- plotMarkers(seMarker = markerPeaks, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv ## Warning: Removed 48 rows containing missing values or values outside the scale ## range (`geom_point_rast()`). To save an editable vectorized version of these plots, we use the plotPDF() function. plotPDF(pma, pv, name = &quot;Erythroid-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! ## Plotting Ggplot! 13.2.3 Marker Peaks in Browser Tracks Additionally we can see these peak regions overlayed on our browser tracks by passing the relevant peak regions to the features parameterin the plotBrowserTrack() function. This will add an additional BED-style track of marker peak regions to the bottom of our ArchR track plot. Here we specify plotting the GATA1 gene via the geneSymbol parameter. p &lt;- plotBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = c(&quot;GATA1&quot;), features = getMarkers(markerPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE)[&quot;Erythroid&quot;], upstream = 50000, downstream = 50000 ) ## ArchR logging to : ArchRLogs/ArchR-plotBrowserTrack-976def688-Date-2025-02-06_Time-02-06-34.627336.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:06:35.265565 : Validating Region, 0.011 mins elapsed. ## GRanges object with 1 range and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chrX 48644982-48652717 + | 2623 GATA1 ## ------- ## seqinfo: 24 sequences from hg19 genome ## 2025-02-06 02:06:35.32695 : Adding Bulk Tracks (1 of 1), 0.012 mins elapsed. ## 2025-02-06 02:06:37.026374 : Adding Feature Tracks (1 of 1), 0.04 mins elapsed. ## 2025-02-06 02:06:37.106577 : Adding Gene Tracks (1 of 1), 0.041 mins elapsed. ## 2025-02-06 02:06:37.432544 : Plotting, 0.047 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-plotBrowserTrack-976def688-Date-2025-02-06_Time-02-06-34.627336.log We can plot this using grid::grid.draw(). grid::grid.newpage() grid::grid.draw(p$GATA1) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(p, name = &quot;Plot-Tracks-With-Features&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Gtable! ## NULL "],["pairwise-testing-between-groups.html", "13.3 Pairwise Testing Between Groups", " 13.3 Pairwise Testing Between Groups Marker feature identification is a very specific type of differential test. However, ArchR also enables standard differential testing using the same getMarkerFeatures() function. The trick is to set useGroups to one of the two cell groups and bgdGroups to the other cell group. This performs a differential test between the two provided groups. To be explicitly clear, the cell groups here are user-defined. They can be anything that fits your application. All you need to do is add a new column to cellColData that defines the groups that you would like to compare. In all differential tests, the peaks that are higher in the group passed to useGroups will have positive fold change values while the peaks that are higher in the group passed to bgdGroups will have negative fold change values. Here we perform a pairwise test between the “Erythroid” cell group and the “Progenitor” cell group. markerTest &lt;- getMarkerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, testMethod = &quot;wilcoxon&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), useGroups = &quot;Erythroid&quot;, bgdGroups = &quot;Progenitor&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-95d9ff6a-Date-2025-02-06_Time-02-06-40.904042.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Integer.Matrix ## 2025-02-06 02:06:41.854939 : Matching Known Biases, 0.005 mins elapsed. ## 2025-02-06 02:06:45.587969 : Computing Pairwise Tests (1 of 1), 0.067 mins elapsed. ## Pairwise Test Erythroid : Seqnames chr1 ## Pairwise Test Erythroid : Seqnames chr10 ## Pairwise Test Erythroid : Seqnames chr11 ## Pairwise Test Erythroid : Seqnames chr12 ## Pairwise Test Erythroid : Seqnames chr13 ## Pairwise Test Erythroid : Seqnames chr14 ## Pairwise Test Erythroid : Seqnames chr15 ## Pairwise Test Erythroid : Seqnames chr16 ## Pairwise Test Erythroid : Seqnames chr17 ## Pairwise Test Erythroid : Seqnames chr18 ## Pairwise Test Erythroid : Seqnames chr19 ## Pairwise Test Erythroid : Seqnames chr2 ## Pairwise Test Erythroid : Seqnames chr20 ## Pairwise Test Erythroid : Seqnames chr21 ## Pairwise Test Erythroid : Seqnames chr22 ## Pairwise Test Erythroid : Seqnames chr3 ## Pairwise Test Erythroid : Seqnames chr4 ## Pairwise Test Erythroid : Seqnames chr5 ## Pairwise Test Erythroid : Seqnames chr6 ## Pairwise Test Erythroid : Seqnames chr7 ## Pairwise Test Erythroid : Seqnames chr8 ## Pairwise Test Erythroid : Seqnames chr9 ## Pairwise Test Erythroid : Seqnames chrX ## ########### ## 2025-02-06 02:07:55.862192 : Completed Pairwise Tests, 1.238 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-95d9ff6a-Date-2025-02-06_Time-02-06-40.904042.log We can then plot an MA or Volcano plot using the plotMarkers() function. We indicate an MA plot using plotAs = \"MA\". pma &lt;- plotMarkers(seMarker = markerTest, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma ## Warning: Removed 64 rows containing missing values or values outside the scale ## range (`geom_point_rast()`). Similarly, we plot a volvano plot using plotAs = \"Volcano\". pv &lt;- plotMarkers(seMarker = markerTest, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv ## Warning: Removed 64 rows containing missing values or values outside the scale ## range (`geom_point_rast()`). To save an editable vectorized version of these plots, we use the plotPDF() function. plotPDF(pma, pv, name = &quot;Erythroid-vs-Progenitor-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! ## Plotting Ggplot! We will continue this differential analysis in the next chapter by looking for motif enrichments in our differentially accessible peaks. "],["motif-and-feature-enrichment-with-archr.html", "Chapter 14 Motif and Feature Enrichment with ArchR", " Chapter 14 Motif and Feature Enrichment with ArchR After identification of a robust peak set, we often want to predict what transcription factors may be mediating the binding events that create those accessible chromatin sites. This can be helpful in assessing marker peaks or differential peaks to understand if these groups of peaks are enriched for binding sites of specific transcription factors. For example, we often find enrichment of key lineage-defining TFs in cell type-specific accessible chromatin regions. In a similar fashion, we might want to test various groups of peaks for enrichment of other known features. For example, we might want to know if cell type-specific ATAC-seq peaks for cell type A are enriched for another set of genomic regions such as ChIP-seq peaks. This chapter details how these enrichments are performed in ArchR. "],["motif-enrichment.html", "14.1 Motif Enrichment", " 14.1 Motif Enrichment Continuing our analysis of differential peaks from the previous chapter, we can look for motifs that are enriched in peaks that are up or down in various cell types. To do this, we must first add these motif annotations to our ArchRProject. This effectively creates a binary matrix where the presence of a motif in each peak is indicated numerically. We do this using the addMotifAnnotations() function which determines motif presence in the peak set stored in the ArchRProject. This function allows you to use motif sets that have been curated from repositories such as JASPAR or CIS-BP. For JASPAR, ArchR retrieves these motif sets using the TFBSTools::getMatrixSet() function. For CIS-BP, ArchR retrieves motifs using the chromVARmotifs package. Because of this, certain species may or may not be available for any given motif set and you should familiarize yourself with the addMotifAnnotations() function docs if you are using anything other than human or mouse. To provide maximal flexibility, we allow users to provide their own motif set as a PWMatrixList object to the motifPWMs parameter. If you need to construct your own PWMatrixList object, check out the universalmotif package which provides for simplified conversion between various motif file formats (e.g. meme) and the PWMatrixList format from the TFBSTools package. projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) ## ArchR logging to : ArchRLogs/ArchR-addMotifAnnotations-9f737cfa-Date-2025-02-06_Time-02-09-43.525428.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:09:47.467309 : Getting Motif Set, Species : Homo sapiens, 0.005 mins elapsed. ## Using version 2 motifs! ## 2025-02-06 02:09:56.001564 : Finding Motif Positions with motifmatchr!, 0.148 mins elapsed. ## 2025-02-06 02:11:45.32699 : All Motifs Overlap at least 1 peak!, 1.97 mins elapsed. ## 2025-02-06 02:11:45.333087 : Creating Motif Overlap Matrix, 1.97 mins elapsed. ## 2025-02-06 02:11:49.277269 : Finished Getting Motif Info!, 2.035 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addMotifAnnotations-9f737cfa-Date-2025-02-06_Time-02-09-43.525428.log The motifSet used should be chosen carefully because annotations may not be available for your species. 14.1.1 Which motifs are found in a given peak? Before diving into how to perform various motif enrichment analyses, we’ll take a slight detour to discuss how to figure out which motifs are present in a given peak. Lets say we are interested in understanding which TF motifs are present within the promoter peak of the CEBPA gene, located at chr19:33792929-33794030. First, we extract the peak set from our ArchRProject and create names for each peak based on the chromosome, start, and end positions. pSet &lt;- getPeakSet(ArchRProj = projHeme5) pSet$name &lt;- paste(seqnames(pSet), start(pSet), end(pSet), sep = &quot;_&quot;) Then, we extract a RangedSummarizedExperiment object containing the per-peak motif matches, create analogous names for that object, and then sort the matches object to ensure that the peaks are listed in the same order as the peaks from the peak set. matches &lt;- getMatches(ArchRProj = projHeme5, name = &quot;Motif&quot;) rownames(matches) &lt;- paste(seqnames(matches), start(matches), end(matches), sep = &quot;_&quot;) matches &lt;- matches[pSet$name] Now, we just need to find the index of the CEBPA promoter peak of interest and find which motifs are present in that peak. Note that the below code only works when a single peak is being analyzed. First, we make a GRanges object corresponding to the CEBPA promoter. gr &lt;- GRanges(seqnames = c(&quot;chr19&quot;), ranges = IRanges(start = c(33792929), end = c(33794030))) Then we find peaks from our peak set that overlap this region. queryHits &lt;- queryHits(findOverlaps(query = pSet, subject = gr, type = &quot;within&quot;)) Then we get the TFs that have motif matches in that peak. colnames(matches)[which(assay(matches[queryHits,]))] ## [1] &quot;TFAP2D_2&quot; &quot;HIF1A_24&quot; &quot;TCFL5_25&quot; &quot;HES1_34&quot; &quot;TCF15_46&quot; ## [6] &quot;ATOH8_71&quot; &quot;SCXB_93&quot; &quot;HES4_95&quot; &quot;SCXA_96&quot; &quot;ZFX_158&quot; ## [11] &quot;KLF6_165&quot; &quot;ZFY_166&quot; &quot;KLF5_175&quot; &quot;ZNF423_176&quot; &quot;CTCF_177&quot; ## [16] &quot;SP4_180&quot; &quot;KLF7_189&quot; &quot;PLAGL1_190&quot; &quot;EGR1_195&quot; &quot;EGR2_196&quot; ## [21] &quot;CTCFL_198&quot; &quot;SNAI1_199&quot; &quot;GLIS2_201&quot; &quot;KLF16_205&quot; &quot;EGR4_207&quot; ## [26] &quot;ZNF148_222&quot; &quot;SP8_226&quot; &quot;ZNF219_229&quot; &quot;ZNF143_231&quot; &quot;SP2_232&quot; ## [31] &quot;SP7_241&quot; &quot;SP3_247&quot; &quot;GLIS1_250&quot; &quot;ZBTB7A_258&quot; &quot;ZBTB7C_265&quot; ## [36] &quot;WT1_266&quot; &quot;SP1_267&quot; &quot;SP6_275&quot; &quot;SP5_279&quot; &quot;SP9_283&quot; ## [41] &quot;DNMT1_301&quot; &quot;ELF4_323&quot; &quot;SPDEF_330&quot; &quot;EHF_333&quot; &quot;MBD2_644&quot; ## [46] &quot;MECP2_645&quot; &quot;TBP_793&quot; &quot;EP300_804&quot; &quot;NRF1_805&quot; &quot;KLF2_846&quot; ## [51] &quot;ZFP161_850&quot; &quot;TFCP2L1_858&quot; &quot;SMAD5_866&quot; The same type of workflow could be used in conjunction with peak-to-gene links or co-accessibility, which will come up in later chapters, to identify TF motifs present in other sets of peaks. The key is matching peaks based on the chromosome, start and end positions as shown above. 14.1.2 Motif Enrichment in Differential Peaks We can then use the differential testing SummarizedExperiment object markerTest which was generated in the previous chapter to define the set of significantly differential peaks that we are interested in testing for motif enrichment. In this case, we are looking for peaks that have an FDR &lt;= 0.1 and a Log2FC &gt;= 0.5. In the context of the differential comparison made in markerTest, these represnt peaks that are more accessible in “Erythroid” cells than “Progenitor” cells. We can test these differentially accessible peaks for enrichment of various motifs using the peakAnnoEnrichment() function. This function is a generalizable function that can be used for many different enrichment tests as we will demonstrate throughout this chapter. motifsUp &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## ArchR logging to : ArchRLogs/ArchR-peakAnnoEnrichment-9142f6284-Date-2025-02-06_Time-02-11-58.541016.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:12:02.76828 : Computing Enrichments 1 of 1, 0.07 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-peakAnnoEnrichment-9142f6284-Date-2025-02-06_Time-02-11-58.541016.log The output of peakAnnoEnrichment() is a SummarizedExperiment object containing multiple assays that store the results of enrichment testing with the hypergeometric test. motifsUp ## class: SummarizedExperiment ## dim: 870 1 ## metadata(0): ## assays(10): mlog10Padj mlog10p ... CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 ... TBX18_869 TBX22_870 ## rowData names(0): ## colnames(1): Erythroid ## colData names(0): To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank. df &lt;- data.frame(TF = rownames(motifsUp), mlog10Padj = assay(motifsUp)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) As expected, the most enriched motifs in the peaks that are more accessible in “Erythroid” cells correspond to GATA transcription factors, consistent with the well-studied role of GATA1 in erythroid differentiation. head(df) ## TF mlog10Padj rank ## 384 GATA3_384 632.8126 1 ## 383 GATA1_383 624.3005 2 ## 388 GATA2_388 607.9140 3 ## 385 GATA5_385 482.6431 4 ## 386 GATA4_386 378.5250 5 ## 387 GATA6_387 267.0503 6 Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif. ggUp &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(P-adj) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggUp ## Warning: ggrepel: 23 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps We can perform the same analyses for the peaks that are more accessible in the “Progenitor” cells by using peaks with Log2FC &lt;= -0.5. motifsDo &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &lt;= -0.5&quot; ) ## ArchR logging to : ArchRLogs/ArchR-peakAnnoEnrichment-91c67d69f-Date-2025-02-06_Time-02-12-01.413406.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:12:05.858421 : Computing Enrichments 1 of 1, 0.074 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-peakAnnoEnrichment-91c67d69f-Date-2025-02-06_Time-02-12-01.413406.log motifsDo ## class: SummarizedExperiment ## dim: 870 1 ## metadata(0): ## assays(10): mlog10Padj mlog10p ... CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 ... TBX18_869 TBX22_870 ## rowData names(0): ## colnames(1): Erythroid ## colData names(0): df &lt;- data.frame(TF = rownames(motifsDo), mlog10Padj = assay(motifsDo)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) In this case, the most enriched motifs in the peaks that are more accessible in “Progenitor” cells correspond to RUNX, ELF, and CBFB motifs. head(df) ## TF mlog10Padj rank ## 326 ELF2_326 105.93186 1 ## 56 TCF12_56 83.78656 2 ## 733 RUNX1_733 75.74706 3 ## 336 SPIB_336 73.51366 4 ## 801 CBFB_801 64.57766 5 ## 322 SPI1_322 60.43296 6 ggDo &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(FDR) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggDo ## Warning: ggrepel: 21 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps To save an editable vectorized version of these plots, we use the plotPDF() function. plotPDF(ggUp, ggDo, name = &quot;Erythroid-vs-Progenitor-Markers-Motifs-Enriched&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! ## Plotting Ggplot! 14.1.3 Motif Enrichment in Marker Peaks Similar to the motif enrichment analyses performed on the differential peaks in the previous section, we can also perform motif enrichment on our marker peaks identified using getMarkerFeatures(). To do this, we pass our marker peak SummarizedExperiment (markerPeaks, created previously) to the peakAnnotationEnrichment() function. enrichMotifs &lt;- peakAnnoEnrichment( seMarker = markerPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## ArchR logging to : ArchRLogs/ArchR-peakAnnoEnrichment-929371b44-Date-2025-02-06_Time-02-12-09.431126.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:12:13.524822 : Computing Enrichments 1 of 11, 0.068 mins elapsed. ## 2025-02-06 02:12:13.624036 : Computing Enrichments 2 of 11, 0.07 mins elapsed. ## 2025-02-06 02:12:13.718923 : Computing Enrichments 3 of 11, 0.071 mins elapsed. ## 2025-02-06 02:12:13.81476 : Computing Enrichments 4 of 11, 0.073 mins elapsed. ## 2025-02-06 02:12:13.91034 : Computing Enrichments 5 of 11, 0.075 mins elapsed. ## 2025-02-06 02:12:14.002949 : Computing Enrichments 6 of 11, 0.076 mins elapsed. ## 2025-02-06 02:12:14.093421 : Computing Enrichments 7 of 11, 0.078 mins elapsed. ## 2025-02-06 02:12:14.191154 : Computing Enrichments 8 of 11, 0.079 mins elapsed. ## 2025-02-06 02:12:14.282939 : Computing Enrichments 9 of 11, 0.081 mins elapsed. ## 2025-02-06 02:12:14.378932 : Computing Enrichments 10 of 11, 0.082 mins elapsed. ## 2025-02-06 02:12:14.472336 : Computing Enrichments 11 of 11, 0.084 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-peakAnnoEnrichment-929371b44-Date-2025-02-06_Time-02-12-09.431126.log The output of peakAnnoEnrichment() is a SummarizedExperiment object containing multiple assays that store the results of enrichment testing with the hypergeometric test. enrichMotifs ## class: SummarizedExperiment ## dim: 870 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p ... CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 ... TBX18_869 TBX22_870 ## rowData names(0): ## colnames(11): B CD4.M ... PreB Progenitor ## colData names(0): We can directly plot these motif enrichments across all cell groups using the plotEnrichHeatmap() function. In this function, we limit the total number of motifs shown per cell group using the n parameter. heatmapEM &lt;- plotEnrichHeatmap(enrichMotifs, n = 7, transpose = TRUE) ## ArchR logging to : ArchRLogs/ArchR-plotEnrichHeatmap-93b971111-Date-2025-02-06_Time-02-12-14.711342.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. We can diplay this plot using ComplexHeatmap::draw(). ComplexHeatmap::draw(heatmapEM, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(heatmapEM, name = &quot;Motifs-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting ComplexHeatmap! 14.1.4 Motif enrichment in arbitrary regions It is also possible to perform the same motif enrichment analyses using the hypergeometric test in an arbitrary user-defined set of regions. To do this, we would use the customEnrichment() function. The most important things to note about this custom enrichment is that the user-defined set of regions must overlap with the peakset of the project and a peakAnnotation matches object must already have been added to the ArchRProject via addMotifAnnotations(), addArchRAnnotations(), or addPeakAnnotations(). 14.1.5 Plotting motif logos Because different motif annotations will use different position weight matrices (PWMs), it’s often useful to plot the sequence logo of the exact motif being used. Multiple tools exist to do this but the one we prefer is ggseqlogo To do this, we must first extract the relevant motif information as a PWMatrix object. pwm &lt;- getPeakAnnotation(projHeme5, &quot;Motif&quot;)$motifs[[&quot;SOX6_868&quot;]] pwm ## An object of class PWMatrix ## ID: ENSG00000110693_LINE19574_SOX6_I_N7 ## Name: SOX6 ## Matrix Class: Unknown ## strand: * ## Pseudocounts: ## Tags: ## $ensembl ## [1] &quot;ENSG00000110693&quot; ## ## Background: ## A C G T ## 0.25 0.25 0.25 0.25 ## Matrix: ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## A 0.2856363 1.236986 1.297203 -2.131381 1.340070 1.259222 -1.224160 ## C -0.6196693 -2.173286 -3.473518 1.257839 -3.473518 -1.259465 -1.366327 ## G -0.4525775 -1.628926 -1.447733 -1.817039 -2.592395 -1.817039 -3.473518 ## T 0.4023151 -1.407137 -2.592395 -1.604399 -2.592395 -3.473518 1.229625 ## [,8] ## A 0.4500618 ## C -0.4283456 ## G 0.2154626 ## T -0.6169845 Then, we convert that object to a position probability matrix. We do this with a function, which could be used in an lapply statement if you wanted to do this for many PWMatrix objects or a PWMatrixList. PWMatrixToProbMatrix &lt;- function(x){ if (class(x) != &quot;PWMatrix&quot;) stop(&quot;x must be a TFBSTools::PWMatrix object&quot;) m &lt;- (exp(as(x, &quot;matrix&quot;))) * TFBSTools::bg(x)/sum(TFBSTools::bg(x)) m &lt;- t(t(m)/colSums(m)) m } ppm &lt;- PWMatrixToProbMatrix(pwm) ppm ## [,1] [,2] [,3] [,4] [,5] [,6] ## A 0.3326521 0.86130341 0.914762277 0.02966834 0.954827787 0.880670100 ## C 0.1345306 0.02845076 0.007751938 0.87945252 0.007751938 0.070951425 ## G 0.1589967 0.04903503 0.058775647 0.04062654 0.018710138 0.040626537 ## T 0.3738206 0.06121080 0.018710138 0.05025260 0.018710138 0.007751938 ## [,7] [,8] ## A 0.073501136 0.3921023 ## C 0.063760514 0.1628965 ## G 0.007751938 0.3101089 ## T 0.854986412 0.1348923 This Position Probability Matrix (PPM), has column sums that add to 1. colSums(ppm) %&gt;% range ## [1] 1 1 We can then pass this PPM to the ggseqlogo() function for plotting. We can plot as a PWM using method = \"bits\". Note that you need to have the ggseqlogo package installed for this to work. library(ggseqlogo) ggseqlogo(ppm, method = &quot;bits&quot;) Or we can plot as a PPM using method = \"prob\". ggseqlogo(ppm, method = &quot;prob&quot;) "],["archr-enrichment.html", "14.2 ArchR Enrichment", " 14.2 ArchR Enrichment In addition to testing peaks for enrichment of motifs, ArchR also enables the determination of more customizable enrichments. To facilitate this level of data exploration, we have curated a few different feature sets that can be easily tested for enrichment in your peak regions of interest. We describe each of those curated feature sets below. This type of analysis was originally inspired by LOLA. 14.2.1 Encode TF Binding Sites The ENCODE consortium has mapped TF binding sites (TFBSs) across a wide array of cell types and factors. We can use these TFBS collections to better understand our clusters. For example, in the context of truly unknown cell types, these enrichments could help to elucidate cell identity. To enable analyses with these ENCODE TFBS feature sets, we simply call the addArchRAnnotations() function with collection = \"EncodeTFBS\". Similar to what happens when using addPeakAnnotations(), this creates a binarized representation of the overlap between all marker peaks and all ENCODE TFBS. projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) ## ArchR logging to : ArchRLogs/ArchR-addArchRAnnotations-917905f15-Date-2025-02-06_Time-02-12-19.230764.log ## If there is an issue, please report to github with logFile! ## Annotation ArchR-Hg19-v1.Anno does not exist! Downloading.. ## Annotating Chromosomes ## 2025-02-06 02:12:23.450598 : ## Annotating Chr: chr1 ## 2025-02-06 02:12:23.45558 : ## Annotating Chr: chr2 ## 2025-02-06 02:12:23.683719 : ## Annotating Chr: chr3 ## 2025-02-06 02:12:23.852107 : ## Annotating Chr: chr4 ## 2025-02-06 02:12:23.993586 : ## Annotating Chr: chr5 ## 2025-02-06 02:12:24.100873 : ## Annotating Chr: chr6 ## 2025-02-06 02:12:24.224218 : ## Annotating Chr: chr7 ## 2025-02-06 02:12:24.373781 : ## Annotating Chr: chr8 ## 2025-02-06 02:12:24.505743 : ## Annotating Chr: chr9 ## 2025-02-06 02:12:24.619775 : ## Annotating Chr: chr10 ## 2025-02-06 02:12:24.730418 : ## Annotating Chr: chr11 ## 2025-02-06 02:12:24.850021 : ## Annotating Chr: chr12 ## 2025-02-06 02:12:25.0099 : ## Annotating Chr: chr13 ## 2025-02-06 02:12:25.170325 : ## Annotating Chr: chr14 ## 2025-02-06 02:12:25.256685 : ## Annotating Chr: chr15 ## 2025-02-06 02:12:25.367161 : ## Annotating Chr: chr16 ## 2025-02-06 02:12:25.482679 : ## Annotating Chr: chr17 ## 2025-02-06 02:12:25.611102 : ## Annotating Chr: chr18 ## 2025-02-06 02:12:25.864134 : ## Annotating Chr: chr19 ## 2025-02-06 02:12:25.941038 : ## Annotating Chr: chr20 ## 2025-02-06 02:12:26.069982 : ## Annotating Chr: chr21 ## 2025-02-06 02:12:26.168135 : ## Annotating Chr: chr22 ## 2025-02-06 02:12:26.235897 : ## Annotating Chr: chrX ## 2025-02-06 02:12:26.315668 : ## 2025-02-06 02:12:28.295146 : All Regions Overlap at least 1 peak!, 0.151 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addArchRAnnotations-917905f15-Date-2025-02-06_Time-02-12-19.230764.log We can then test for enrichment of these ENCODE TFBSs with our peak set using the peakAnnoEnrichment() function. enrichEncode &lt;- peakAnnoEnrichment( seMarker = markerPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## ArchR logging to : ArchRLogs/ArchR-peakAnnoEnrichment-9435e37c9-Date-2025-02-06_Time-02-12-30.285966.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:12:33.503953 : Computing Enrichments 1 of 11, 0.054 mins elapsed. ## 2025-02-06 02:12:33.582179 : Computing Enrichments 2 of 11, 0.055 mins elapsed. ## 2025-02-06 02:12:33.666145 : Computing Enrichments 3 of 11, 0.056 mins elapsed. ## 2025-02-06 02:12:33.749031 : Computing Enrichments 4 of 11, 0.058 mins elapsed. ## 2025-02-06 02:12:33.829075 : Computing Enrichments 5 of 11, 0.059 mins elapsed. ## 2025-02-06 02:12:33.91125 : Computing Enrichments 6 of 11, 0.06 mins elapsed. ## 2025-02-06 02:12:33.987118 : Computing Enrichments 7 of 11, 0.062 mins elapsed. ## 2025-02-06 02:12:34.066629 : Computing Enrichments 8 of 11, 0.063 mins elapsed. ## 2025-02-06 02:12:34.149615 : Computing Enrichments 9 of 11, 0.064 mins elapsed. ## 2025-02-06 02:12:34.227038 : Computing Enrichments 10 of 11, 0.066 mins elapsed. ## 2025-02-06 02:12:34.309604 : Computing Enrichments 11 of 11, 0.067 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-peakAnnoEnrichment-9435e37c9-Date-2025-02-06_Time-02-12-30.285966.log As previously, this function returns a SummarizedExperiment object. enrichEncode ## class: SummarizedExperiment ## dim: 689 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p ... CompareFrequency feature ## rownames(689): 1.CTCF-Dnd41... 2.EZH2_39-Dnd41... ... ## 688.CTCF-WERI_Rb_1... 689.CTCF-WI_38... ## rowData names(0): ## colnames(11): B CD4.M ... PreB Progenitor ## colData names(0): We can create a heatmap from these enrichment results using the plotEnrichHeatmap() function. heatmapEncode &lt;- plotEnrichHeatmap(enrichEncode, n = 7, transpose = TRUE) ## ArchR logging to : ArchRLogs/ArchR-plotEnrichHeatmap-94f7a8b86-Date-2025-02-06_Time-02-12-34.515397.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. And then plot this heatmap using ComplexHeatmap::draw(). ComplexHeatmap::draw(heatmapEncode, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(heatmapEncode, name = &quot;EncodeTFBS-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting ComplexHeatmap! 14.2.2 Bulk ATAC-seq Similar to the curated set of ENCODE TF binding sites, we have also curated peak calls from bulk ATAC-seq experiments that can be used for overlap enrichment testing. We access these bulk ATAC-seq peak sets by setting collection = \"ATAC\". projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) ## ArchR logging to : ArchRLogs/ArchR-addArchRAnnotations-9619b4756-Date-2025-02-06_Time-02-12-38.58154.log ## If there is an issue, please report to github with logFile! ## Annotating Chromosomes ## 2025-02-06 02:12:38.84977 : ## Annotating Chr: chr1 ## 2025-02-06 02:12:38.854547 : ## Annotating Chr: chr2 ## 2025-02-06 02:12:38.968705 : ## Annotating Chr: chr3 ## 2025-02-06 02:12:39.069345 : ## Annotating Chr: chr4 ## 2025-02-06 02:12:39.161145 : ## Annotating Chr: chr5 ## 2025-02-06 02:12:39.249762 : ## Annotating Chr: chr6 ## 2025-02-06 02:12:39.333078 : ## Annotating Chr: chr7 ## 2025-02-06 02:12:39.42061 : ## Annotating Chr: chr8 ## 2025-02-06 02:12:39.500039 : ## Annotating Chr: chr9 ## 2025-02-06 02:12:39.580578 : ## Annotating Chr: chr10 ## 2025-02-06 02:12:39.657583 : ## Annotating Chr: chr11 ## 2025-02-06 02:12:39.73432 : ## Annotating Chr: chr12 ## 2025-02-06 02:12:39.818257 : ## Annotating Chr: chr13 ## 2025-02-06 02:12:39.898198 : ## Annotating Chr: chr14 ## 2025-02-06 02:12:39.95936 : ## Annotating Chr: chr15 ## 2025-02-06 02:12:40.031763 : ## Annotating Chr: chr16 ## 2025-02-06 02:12:40.105844 : ## Annotating Chr: chr17 ## 2025-02-06 02:12:40.17736 : ## Annotating Chr: chr18 ## 2025-02-06 02:12:40.262019 : ## Annotating Chr: chr19 ## 2025-02-06 02:12:40.326714 : ## Annotating Chr: chr20 ## 2025-02-06 02:12:40.41167 : ## Annotating Chr: chr21 ## 2025-02-06 02:12:40.484403 : ## Annotating Chr: chr22 ## 2025-02-06 02:12:40.543997 : ## Annotating Chr: chrX ## 2025-02-06 02:12:40.609008 : ## 2025-02-06 02:12:41.59324 : All Regions Overlap at least 1 peak!, 0.05 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addArchRAnnotations-9619b4756-Date-2025-02-06_Time-02-12-38.58154.log We then test our marker peaks for enrichment of these bulk ATAC-seq peaks by setting peakAnnotation = \"ATAC\". enrichATAC &lt;- peakAnnoEnrichment( seMarker = markerPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## ArchR logging to : ArchRLogs/ArchR-peakAnnoEnrichment-94cfd4317-Date-2025-02-06_Time-02-12-43.632264.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:12:47.515811 : Computing Enrichments 1 of 11, 0.065 mins elapsed. ## 2025-02-06 02:12:47.562992 : Computing Enrichments 2 of 11, 0.065 mins elapsed. ## 2025-02-06 02:12:47.607953 : Computing Enrichments 3 of 11, 0.066 mins elapsed. ## 2025-02-06 02:12:47.653693 : Computing Enrichments 4 of 11, 0.067 mins elapsed. ## 2025-02-06 02:12:47.699384 : Computing Enrichments 5 of 11, 0.068 mins elapsed. ## 2025-02-06 02:12:47.748599 : Computing Enrichments 6 of 11, 0.069 mins elapsed. ## 2025-02-06 02:12:47.795038 : Computing Enrichments 7 of 11, 0.069 mins elapsed. ## 2025-02-06 02:12:47.84374 : Computing Enrichments 8 of 11, 0.07 mins elapsed. ## 2025-02-06 02:12:47.892506 : Computing Enrichments 9 of 11, 0.071 mins elapsed. ## 2025-02-06 02:12:47.939472 : Computing Enrichments 10 of 11, 0.072 mins elapsed. ## 2025-02-06 02:12:47.986307 : Computing Enrichments 11 of 11, 0.073 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-peakAnnoEnrichment-94cfd4317-Date-2025-02-06_Time-02-12-43.632264.log As before, the output of this is a SummarizedExperiment object with information on the enrichment results. enrichATAC ## class: SummarizedExperiment ## dim: 96 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p ... CompareFrequency feature ## rownames(96): Brain_Astrocytes Brain_Excitatory_neurons ... Heme_MPP ## Heme_NK ## rowData names(0): ## colnames(11): B CD4.M ... PreB Progenitor ## colData names(0): We can create an enrichment heatmap from this SummarizedExperiment using plotEnrichHeatmap(). heatmapATAC &lt;- plotEnrichHeatmap(enrichATAC, n = 7, transpose = TRUE) ## ArchR logging to : ArchRLogs/ArchR-plotEnrichHeatmap-976a252e6-Date-2025-02-06_Time-02-12-48.157383.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. And plot this heatmap using ComplexHeatmap::draw() ComplexHeatmap::draw(heatmapATAC, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(heatmapATAC, name = &quot;ATAC-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting ComplexHeatmap! 14.2.3 Codex TFBS The same type of analyses can be performed for CODEX TFBSs by setting collection = \"Codex\". projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;Codex&quot;) ## ArchR logging to : ArchRLogs/ArchR-addArchRAnnotations-94096281b-Date-2025-02-06_Time-02-12-52.267269.log ## If there is an issue, please report to github with logFile! ## Annotating Chromosomes ## 2025-02-06 02:12:52.536008 : ## Annotating Chr: chr1 ## 2025-02-06 02:12:52.540543 : ## Annotating Chr: chr2 ## 2025-02-06 02:12:52.619001 : ## Annotating Chr: chr3 ## 2025-02-06 02:12:52.696476 : ## Annotating Chr: chr4 ## 2025-02-06 02:12:52.774483 : ## Annotating Chr: chr5 ## 2025-02-06 02:12:52.840419 : ## Annotating Chr: chr6 ## 2025-02-06 02:12:52.906912 : ## Annotating Chr: chr7 ## 2025-02-06 02:12:52.975936 : ## Annotating Chr: chr8 ## 2025-02-06 02:12:53.044106 : ## Annotating Chr: chr9 ## 2025-02-06 02:12:53.116323 : ## Annotating Chr: chr10 ## 2025-02-06 02:12:53.185412 : ## Annotating Chr: chr11 ## 2025-02-06 02:12:53.253278 : ## Annotating Chr: chr12 ## 2025-02-06 02:12:53.322582 : ## Annotating Chr: chr13 ## 2025-02-06 02:12:53.391308 : ## Annotating Chr: chr14 ## 2025-02-06 02:12:53.450126 : ## Annotating Chr: chr15 ## 2025-02-06 02:12:53.513028 : ## Annotating Chr: chr16 ## 2025-02-06 02:12:53.574894 : ## Annotating Chr: chr17 ## 2025-02-06 02:12:53.63786 : ## Annotating Chr: chr18 ## 2025-02-06 02:12:53.707179 : ## Annotating Chr: chr19 ## 2025-02-06 02:12:53.764299 : ## Annotating Chr: chr20 ## 2025-02-06 02:12:53.838341 : ## Annotating Chr: chr21 ## 2025-02-06 02:12:53.9003 : ## Annotating Chr: chr22 ## 2025-02-06 02:12:53.954982 : ## Annotating Chr: chrX ## 2025-02-06 02:12:54.012035 : ## 2025-02-06 02:12:54.747732 : All Regions Overlap at least 1 peak!, 0.041 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addArchRAnnotations-94096281b-Date-2025-02-06_Time-02-12-52.267269.log enrichCodex &lt;- peakAnnoEnrichment( seMarker = markerPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Codex&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## ArchR logging to : ArchRLogs/ArchR-peakAnnoEnrichment-91010b3a1-Date-2025-02-06_Time-02-12-56.416156.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:12:58.098723 : Computing Enrichments 1 of 11, 0.028 mins elapsed. ## 2025-02-06 02:12:58.132984 : Computing Enrichments 2 of 11, 0.029 mins elapsed. ## 2025-02-06 02:12:58.167791 : Computing Enrichments 3 of 11, 0.029 mins elapsed. ## 2025-02-06 02:12:58.201671 : Computing Enrichments 4 of 11, 0.03 mins elapsed. ## 2025-02-06 02:12:58.235424 : Computing Enrichments 5 of 11, 0.03 mins elapsed. ## 2025-02-06 02:12:58.269162 : Computing Enrichments 6 of 11, 0.031 mins elapsed. ## 2025-02-06 02:12:58.303835 : Computing Enrichments 7 of 11, 0.031 mins elapsed. ## 2025-02-06 02:12:58.338797 : Computing Enrichments 8 of 11, 0.032 mins elapsed. ## 2025-02-06 02:12:58.373664 : Computing Enrichments 9 of 11, 0.033 mins elapsed. ## 2025-02-06 02:12:58.408577 : Computing Enrichments 10 of 11, 0.033 mins elapsed. ## 2025-02-06 02:12:58.443187 : Computing Enrichments 11 of 11, 0.034 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-peakAnnoEnrichment-91010b3a1-Date-2025-02-06_Time-02-12-56.416156.log enrichCodex ## class: SummarizedExperiment ## dim: 189 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p ... CompareFrequency feature ## rownames(189): 1.STAT5-No_drug_(DMSO)... 2.RUNX3-GM12878_cell_fr... ... ## 188.TP53-codex_Embryonic... 189.TP53-codex_Embryonic... ## rowData names(0): ## colnames(11): B CD4.M ... PreB Progenitor ## colData names(0): heatmapCodex &lt;- plotEnrichHeatmap(enrichCodex, n = 7, transpose = TRUE) ## ArchR logging to : ArchRLogs/ArchR-plotEnrichHeatmap-92b42ed9b-Date-2025-02-06_Time-02-12-58.594438.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ComplexHeatmap::draw(heatmapCodex, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapCodex, name = &quot;Codex-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting ComplexHeatmap! "],["custom-enrichment.html", "14.3 Custom Enrichment", " 14.3 Custom Enrichment In addition to all of these curated annotation sets, ArchR is also capable of accepting user-defined annotations to perform custom enrichments. In the below example, we illustrate how to create a custom annotation based on select ENCODE ChIP-seq experiments. First, we will define the datasets that will be used and provide links for their download. Local files could be used in the same way. EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) We then add a custom annotation to our ArchRProject using the addPeakAnnotation() function. Here, we call our custom annotation “ChIP”. projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) ## ArchR logging to : ArchRLogs/ArchR-addPeakAnnotations-975f91f16-Date-2025-02-06_Time-02-13-02.630154.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:13:06.471801 : Creating Peak Overlap Matrix, 0.064 mins elapsed. ## 2025-02-06 02:13:06.610289 : All Regions Overlap at least 1 peak!, 0.066 mins elapsed. As before, we use this custom annotation to perform the peak annotation enrichment using peakAnnoEnrichment() and follow the same steps to create our annotation heatmap. enrichRegions &lt;- peakAnnoEnrichment( seMarker = markerPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## ArchR logging to : ArchRLogs/ArchR-peakAnnoEnrichment-95e7694d4-Date-2025-02-06_Time-02-13-07.999931.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:13:11.317168 : Computing Enrichments 1 of 11, 0.055 mins elapsed. ## 2025-02-06 02:13:11.337248 : Computing Enrichments 2 of 11, 0.056 mins elapsed. ## 2025-02-06 02:13:11.355956 : Computing Enrichments 3 of 11, 0.056 mins elapsed. ## 2025-02-06 02:13:11.374193 : Computing Enrichments 4 of 11, 0.056 mins elapsed. ## 2025-02-06 02:13:11.391767 : Computing Enrichments 5 of 11, 0.057 mins elapsed. ## 2025-02-06 02:13:11.410138 : Computing Enrichments 6 of 11, 0.057 mins elapsed. ## 2025-02-06 02:13:11.427705 : Computing Enrichments 7 of 11, 0.057 mins elapsed. ## 2025-02-06 02:13:11.446458 : Computing Enrichments 8 of 11, 0.057 mins elapsed. ## 2025-02-06 02:13:11.467138 : Computing Enrichments 9 of 11, 0.058 mins elapsed. ## 2025-02-06 02:13:11.485943 : Computing Enrichments 10 of 11, 0.058 mins elapsed. ## 2025-02-06 02:13:11.504303 : Computing Enrichments 11 of 11, 0.058 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-peakAnnoEnrichment-95e7694d4-Date-2025-02-06_Time-02-13-07.999931.log enrichRegions ## class: SummarizedExperiment ## dim: 4 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p ... CompareFrequency feature ## rownames(4): Encode_K562_GATA1 Encode_GM12878_CEBPB Encode_K562_Ebf1 ## Encode_K562_Pax5 ## rowData names(0): ## colnames(11): B CD4.M ... PreB Progenitor ## colData names(0): heatmapRegions &lt;- plotEnrichHeatmap(enrichRegions, n = 7, transpose = TRUE) ## ArchR logging to : ArchRLogs/ArchR-plotEnrichHeatmap-96c5b6fa9-Date-2025-02-06_Time-02-13-11.636966.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ComplexHeatmap::draw(heatmapRegions, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(heatmapRegions, name = &quot;Regions-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting ComplexHeatmap! "],["chromvar-deviatons-enrichment-with-archr.html", "Chapter 15 ChromVAR Deviatons Enrichment with ArchR", " Chapter 15 ChromVAR Deviatons Enrichment with ArchR As shown in previous chapters, TF motif enrichments can help us predict which regulatory factors are most active in our cell type of interest. These enrichments, however, are not calculated on a per-cell basis and they do not take into account the insertion sequence bias of the Tn5 transposase. chromVAR, an R package from the Greenleaf Lab, was created to account for these issues. chromVAR is designed for predicting enrichment of TF activity on a per-cell basis from sparse chromatin accessibility data. The two primary outputs of chromVAR are: “deviations” - A deviation is a bias-corrected measurement of how far the per-cell accessibility of a given feature (i.e motif) deviates from the expected accessibility based on the average of all cells or samples. Deviations are computed per-cell and independent of the sample. “z-score” - The z-score, also confusingly known as a “deviation score” is the z-score for each bias-corrected deviation across all cells. The absolute value of the deviation score is correlated with the per-cell read depth. This is because, with more reads, you have higher confidence that the difference in per-cell accessibility of the given feature (i.e. motif) from the expectation is greater than would occur by chance. One of the primary limitations of chromVAR is that it was designed during the early era of scATAC-seq data generation when an experiment consisted of a few hundred of cells. At this experimental scale, chromVAR could easily read the entire cell-by-peak matrix into memory to quickly compute TF deviations. However, current experimental approaches use tens to hundreds of thousands of cells, generating cell-by-peak matrices that are much more difficult to read into memory. This leads to dramatic increases in run time and memory usage for even moderately sized datasets of 50,000 cells. To circumvent these limitations, ArchR implements the same chromVAR analysis workflow by analyzing sample sub-matrices independently. Additionally, as of release_1.0.3 ArchR also includes a re-implementation of some of the core chromVAR functionality in C++ using Rcpp. Together, this enables application of chromVAR to very large datasets. First, ArchR reads in the global accessibility per peak across all cells in each sub-sample. Second, for each peak, ArchR identifies a set of background peaks that are matched by GC-content and accessibility. Third, ArchR uses this background set of peaks and global accessibility to compute bias-corrected deviations with chromVAR for each sample independently. This implementation requires data from only 5,000-10,000 cells to be loaded into memory at any given time, minimizing the memory requirements, enabling scalable analysis with chromVAR, and improving run-time performance. "],["motif-deviations.html", "15.1 Motif Deviations", " 15.1 Motif Deviations First, lets make sure we have added motif annotations to our ArchRProject. if(&quot;Motif&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) } We also need to add a set of background peaks which are used in computing deviations. Background peaks are chosen using the chromVAR::getBackgroundPeaks() function which samples peaks based on similarity in GC-content and number of fragments across all samples using the Mahalanobis distance. projHeme5 &lt;- addBgdPeaks(projHeme5) ## Identifying Background Peaks! We are now ready to compute per-cell deviations accross all of our motif annotations using the addDeviationsMatrix() function. This function has an optional parameter called matrixName that allows us to define the name of the deviations matrix that will be stored in the Arrow files. If we do not provide a value to this parameter, as in the example below, this function creates a matrix name by adding the word “Matrix” to the name of the peakAnnotation. The example below creates a deviations matrix in each of our Arrow files called “MotifMatrix”. projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-945abde0c-Date-2025-02-06_Time-02-14-59.781655.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:15:07.011044 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2025-02-06 02:20:56.583871 : Completed Computing Deviations!, 5.947 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-945abde0c-Date-2025-02-06_Time-02-14-59.781655.log To access these deviations, we use the getVarDeviations() function. If we want this function to return a ggplot object, we set plot = TRUE otherwise, this function would return the DataFrame object. The head of that DataFrame object is displayed by default when the function is run. plotVarDev &lt;- getVarDeviations(projHeme5, name = &quot;MotifMatrix&quot;, plot = TRUE) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars combinedMeans rank ## &lt;Rle&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; ## f336 z 336 SPIB_336 13.9954 -0.0810304 1 ## f155 z 155 CEBPA_155 11.9525 -0.1800011 2 ## f140 z 140 CEBPB_140 10.4502 -0.1199047 3 ## f384 z 384 GATA3_384 10.3798 -0.0476146 4 ## f388 z 388 GATA2_388 10.2313 -0.0428557 5 ## f383 z 383 GATA1_383 10.1460 -0.0430076 6 From the above snapshot of the DataFrame, you can see that the seqnames of the MotifMatrix are not chromosomes. Typically, in matrices like the TileMatrix, PeakMatrix, and GeneScoreMatrix, we store the chromosome information in seqnames. The MotifMatrix does not have any corresponding position information but, instead, stores both the “devations” and “z-scores” from chromVAR into the same matrix using two different seqnames - deviations and z. This becomes important later on if you try to use the MotifMatrix (which is of class Sparse.Assays.Matrix) in functions such as getMarkerFeatures(). In these types of operations, ArchR will expect you to subset MotifMatrix to one of the two seqnames (i.e. select either z-scores or deviations to perform calculations). We can then plot these variable deviations. plotVarDev ## Warning: ggrepel: 15 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotVarDev, name = &quot;Variable-Motif-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! What if we want to extract a subset of motifs for downstream analysis? We can do this using the getFeatures() function. The paste(motifs, collapse=\"|\") statement below creates a concatenated or statement that enables selection of all of the motifs. motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) markerMotifs &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;MotifMatrix&quot;) markerMotifs ## [1] &quot;z:TBX21_780&quot; &quot;z:PAX5_709&quot; &quot;z:IRF4_632&quot; ## [4] &quot;z:GATA1_383&quot; &quot;z:CEBPA_155&quot; &quot;z:EBF1_67&quot; ## [7] &quot;z:SREBF1_22&quot; &quot;deviations:TBX21_780&quot; &quot;deviations:PAX5_709&quot; ## [10] &quot;deviations:IRF4_632&quot; &quot;deviations:GATA1_383&quot; &quot;deviations:CEBPA_155&quot; ## [13] &quot;deviations:EBF1_67&quot; &quot;deviations:SREBF1_22&quot; As mentioned above, MotifMatrix contains seqnames for both z-scores and deviations, shown above by “z:” and “deviations:”. To get just the features corresponding to z-scores, we can use grep. Unfortunately, in the example motifs shown above, you can see that in addition to “EBF1”, we also selected “SREBF1” which we do not want to analyze. Because of this, we remove it below using the %ni% expression which is an ArchR helper function that provides the opposite of %in% from base R. markerMotifs &lt;- grep(&quot;z:&quot;, markerMotifs, value = TRUE) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;z:SREBF1_22&quot;] markerMotifs ## [1] &quot;z:TBX21_780&quot; &quot;z:PAX5_709&quot; &quot;z:IRF4_632&quot; &quot;z:GATA1_383&quot; &quot;z:CEBPA_155&quot; ## [6] &quot;z:EBF1_67&quot; Now that we have the names of the features that we are interested in, we can plot the distribution of chromVAR deviation scores for each cluster. Notice that we supply the impute weights that we calculated previously during our gene score analyses. As a reminder, these impute weights allow us to smooth the signal across nearby cells which is helpful in the context of our sparse scATAC-seq data. p &lt;- plotGroups(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, colorBy = &quot;MotifMatrix&quot;, name = markerMotifs, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## Getting Matrix Values... ## 2025-02-06 02:21:05.135753 : ## ## 1 2 3 4 5 6 We can use cowplot to plot the distributions of all of these motifs in a single plot. p2 &lt;- lapply(seq_along(p), function(x){ if(x != 1){ p[[x]] + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) }else{ p[[x]] + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) } }) do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2, rep(1, length(p2) - 1))),p2)) ## Picking joint bandwidth of 0.248 ## Picking joint bandwidth of 0.259 ## Picking joint bandwidth of 0.294 ## Picking joint bandwidth of 0.339 ## Picking joint bandwidth of 0.315 ## Picking joint bandwidth of 0.281 To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(p, name = &quot;Plot-Groups-Deviations-w-Imputation&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! ## Picking joint bandwidth of 0.248 ## Picking joint bandwidth of 0.248 ## Plotting Ggplot! ## Picking joint bandwidth of 0.259 ## Picking joint bandwidth of 0.259 ## Plotting Ggplot! ## Picking joint bandwidth of 0.294 ## Picking joint bandwidth of 0.294 ## Plotting Ggplot! ## Picking joint bandwidth of 0.339 ## Picking joint bandwidth of 0.339 ## Plotting Ggplot! ## Picking joint bandwidth of 0.315 ## Picking joint bandwidth of 0.315 ## Plotting Ggplot! ## Picking joint bandwidth of 0.281 ## Picking joint bandwidth of 0.281 Instead of looking at the distributions of these z-scores, we can overlay the z-scores on our UMAP embedding as we’ve done previously for gene scores. p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;MotifMatrix&quot;, name = sort(markerMotifs), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9409e4810-Date-2025-02-06_Time-02-21-15.83702.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = MotifMatrix ## Getting Matrix Values... ## 2025-02-06 02:21:17.125601 : ## ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9409e4810-Date-2025-02-06_Time-02-21-15.83702.log We can plot all of these motif UMAPs using cowplot. p2 &lt;- lapply(p, function(x){ x + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To see how these TF deviation z-scores compare to the inferred gene expression via gene scores of the corresponding TF genes, we can overlay the gene scores for each of these TFs on the UMAP embedding. markerGS &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneScoreMatrix&quot;) markerGS &lt;- markerGS[markerGS %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerGS ## [1] &quot;TBX21&quot; &quot;CEBPA&quot; &quot;EBF1&quot; &quot;IRF4&quot; &quot;PAX5&quot; &quot;GATA1&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneScoreMatrix&quot;, name = sort(markerGS), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9740e407f-Date-2025-02-06_Time-02-21-24.516978.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 02:21:25.818279 : ## ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9740e407f-Date-2025-02-06_Time-02-21-24.516978.log p2 &lt;- lapply(p, function(x){ x + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) Similarly, because we previously linked our scATAC-seq data with corresponding scRNA-seq data, we can plot the linked gene expression for each of these TFs on the UMAP embedding. markerRNA &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneIntegrationMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA ## [1] &quot;TBX21&quot; &quot;CEBPA&quot; &quot;EBF1&quot; &quot;IRF4&quot; &quot;PAX5&quot; &quot;GATA1&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneIntegrationMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, continuousSet = &quot;blueYellow&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9594b3859-Date-2025-02-06_Time-02-21-35.228827.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values... ## 2025-02-06 02:21:36.506366 : ## ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9594b3859-Date-2025-02-06_Time-02-21-35.228827.log p2 &lt;- lapply(p, function(x){ x + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) In addition to the analyses shown above, you may want to plot heatmaps of motif deviations, for example using the plotMarkerHeatmap() function based on the output of getMarkerFeatures(). It is important to remember not to filter for marker features (via cutoff) using the the log2(fold change) of deviations on these heatmaps because this is not relevant for deviations which are not a counts-based measure. Instead, marker features can be identified using MeanDiff (for ex. MeanDiff &gt;= 0.1). Similarly, plotLog2FC should be FALSE. "],["archr-and-custom-deviations.html", "15.2 ArchR and Custom Deviations", " 15.2 ArchR and Custom Deviations In the chapter on Peak Annotation Enrichment, we introduced how to create peak annotations for any set of genomic regions. This encluded (i) ArchR-supported region sets such as curated TF binding sites from ENCODE and peak sets from bulk ATAC-seq and (ii) custom user-supplied region sets. If you have not read this section, we recommend doing so to better understand how peak annotations work. These peak annotations can be used in deviation calculations in the same way as motifs. Here we provide examples of how to run these analyses but note that the downstream analyses are identical to what was shown in the previous section for motifs and thus we do not provide extensive details on each step of the code. Once you create a deviations matrix in your Arrow files, the rest is the same. 15.2.1 Encode TFBS In case you have not added an annotations matrix for the “EncodeTFBS” region set, lets do that now. if(&quot;EncodeTFBS&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) } Then, we create a deviations matrix, providing this peak annotation to the peakAnnotation parameter. projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-92d4b5c23-Date-2025-02-06_Time-02-21-47.301582.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:21:52.694577 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2025-02-06 02:31:20.104834 : Completed Computing Deviations!, 9.547 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-92d4b5c23-Date-2025-02-06_Time-02-21-47.301582.log We can create a dot plot of the ranked deviations. plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;EncodeTFBSMatrix&quot;) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## &lt;Rle&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; ## f222 z 222 222.GATA2_S-K562... 22.2115 -0.015532856 ## f542 z 542 542.TAL1_SC-K562... 19.4159 0.000522449 ## f498 z 498 498.GATA_2-K562... 16.5423 -0.012099706 ## f584 z 584 584.GATA_1-PBDEFetal.. 15.3413 0.006277432 ## f497 z 497 497.GATA_1-K562... 12.9395 0.005494656 ## f591 z 591 591.eGFP_GA-K562... 12.7095 -0.004418393 ## rank ## &lt;integer&gt; ## f222 1 ## f542 2 ## f498 3 ## f584 4 ## f497 5 ## f591 6 plotVarDev ## Warning: Removed 6 rows containing missing values or values outside the scale ## range (`geom_point()`). ## Warning: ggrepel: 15 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotVarDev, name = &quot;Variable-EncodeTFBS-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! Or we can subset these TF binding sites to particular motifs we are interested in and then plot their deviation z-scores per-cell on our UMAP embedding. tfs &lt;- c(&quot;GATA_1&quot;, &quot;CEBPB&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) ## [1] &quot;z:584.GATA_1-PBDEFetal...&quot; &quot;z:582.GATA_1-PBDE...&quot; ## [3] &quot;z:497.GATA_1-K562...&quot; &quot;z:477.CEBPB-K562...&quot; ## [5] &quot;z:462.CEBPB-IMR90...&quot; &quot;z:427.CEBPB-HepG2...&quot; ## [7] &quot;z:426.CEBPB-HepG2...&quot; &quot;z:379.CEBPB-HeLa_S3...&quot; ## [9] &quot;z:344.CEBPB-H1_hESC...&quot; &quot;z:293.EBF1_SC-GM12878...&quot; ## [11] &quot;z:278.CEBPB-A549...&quot; &quot;z:213.CEBPB_S-K562...&quot; ## [13] &quot;z:173.CEBPB_S-HepG2...&quot; &quot;z:130.PAX5_C2-GM12892...&quot; ## [15] &quot;z:123.PAX5_C2-GM12891...&quot; &quot;z:102.PAX5_N1-GM12878...&quot; ## [17] &quot;z:101.PAX5_C2-GM12878...&quot; &quot;z:93.IRF4_SC-GM12878...&quot; ## [19] &quot;z:87.EBF1_SC-GM12878...&quot; &quot;z:86.CEBPB_S-GM12878...&quot; ## [21] &quot;deviations:584.GATA_1-PBDEFetal...&quot; &quot;deviations:582.GATA_1-PBDE...&quot; ## [23] &quot;deviations:497.GATA_1-K562...&quot; &quot;deviations:477.CEBPB-K562...&quot; ## [25] &quot;deviations:462.CEBPB-IMR90...&quot; &quot;deviations:427.CEBPB-HepG2...&quot; ## [27] &quot;deviations:426.CEBPB-HepG2...&quot; &quot;deviations:379.CEBPB-HeLa_S3...&quot; ## [29] &quot;deviations:344.CEBPB-H1_hESC...&quot; &quot;deviations:293.EBF1_SC-GM12878...&quot; ## [31] &quot;deviations:278.CEBPB-A549...&quot; &quot;deviations:213.CEBPB_S-K562...&quot; ## [33] &quot;deviations:173.CEBPB_S-HepG2...&quot; &quot;deviations:130.PAX5_C2-GM12892...&quot; ## [35] &quot;deviations:123.PAX5_C2-GM12891...&quot; &quot;deviations:102.PAX5_N1-GM12878...&quot; ## [37] &quot;deviations:101.PAX5_C2-GM12878...&quot; &quot;deviations:93.IRF4_SC-GM12878...&quot; ## [39] &quot;deviations:87.EBF1_SC-GM12878...&quot; &quot;deviations:86.CEBPB_S-GM12878...&quot; markerTFs &lt;- getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) markerTFs &lt;- sort(grep(&quot;z:&quot;, markerTFs, value = TRUE)) TFnames &lt;- stringr::str_split(stringr::str_split(markerTFs, pattern = &quot;\\\\.&quot;, simplify=TRUE)[,2], pattern = &quot;-&quot;, simplify = TRUE)[,1] markerTFs &lt;- markerTFs[!duplicated(TFnames)] markerTFs ## [1] &quot;z:101.PAX5_C2-GM12878...&quot; &quot;z:102.PAX5_N1-GM12878...&quot; ## [3] &quot;z:173.CEBPB_S-HepG2...&quot; &quot;z:278.CEBPB-A549...&quot; ## [5] &quot;z:293.EBF1_SC-GM12878...&quot; &quot;z:497.GATA_1-K562...&quot; ## [7] &quot;z:93.IRF4_SC-GM12878...&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;EncodeTFBSMatrix&quot;, name = markerTFs, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9487b3971-Date-2025-02-06_Time-02-31-28.473973.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = EncodeTFBSMatrix ## Getting Matrix Values... ## 2025-02-06 02:31:29.881668 : ## ## Plotting Embedding ## 1 2 3 4 5 6 7 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9487b3971-Date-2025-02-06_Time-02-31-28.473973.log p2 &lt;- lapply(p, function(x){ x + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) 15.2.2 Bulk ATAC-seq Similarly, we can use ArchR-curated bulk ATAC-seq peak sets for our motif deviation calculations.If you have not added motif annotations In case you have not added an annotations matrix for the “EncodeTFBS” region set, lets do that now. if(&quot;ATAC&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) } Then, we create a deviations matrix, providing this peak annotation to the peakAnnotation parameter. projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-9598edbd3-Date-2025-02-06_Time-02-31-39.996216.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:31:44.928769 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2025-02-06 02:37:09.143985 : Completed Computing Deviations!, 5.486 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-9598edbd3-Date-2025-02-06_Time-02-31-39.996216.log We can create a dot plot of the ranked deviations. plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ATACMatrix&quot;) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## &lt;Rle&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; ## f22 z 22 IAtlas_T_CD8posCenMem 15.0345 -0.182932 ## f24 z 24 IAtlas_T_FollicHelper 14.6922 -0.152309 ## f21 z 21 IAtlas_T_CD8pos 14.5186 -0.173237 ## f19 z 19 IAtlas_T_CD4posEffec.. 14.4562 -0.158722 ## f26 z 26 IAtlas_T_MemoryTeff 14.3618 -0.166626 ## f33 z 33 IAtlas_T_Th1Precursor 14.2731 -0.168414 ## rank ## &lt;integer&gt; ## f22 1 ## f24 2 ## f21 3 ## f19 4 ## f26 5 ## f33 6 plotVarDev ## Warning: ggrepel: 17 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotVarDev, name = &quot;Variable-ATAC-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! Or we can plot the deviation z-scores for each of these peak sets per-cell on our UMAP embedding. ATACPeaks &lt;- c(&quot;Heme_HSC&quot;, &quot;Heme_LMPP&quot;, &quot;Heme_Ery&quot;, &quot;Heme_Mono&quot;, &quot;Heme_CD4&quot;, &quot;Heme_CD8&quot;, &quot;Heme_B&quot;, &quot;Heme_NK&quot;, &quot;IAtlas_DC_Plasmacytoid&quot;) markerATAC &lt;- getFeatures(projHeme5, select = paste(ATACPeaks, collapse=&quot;|&quot;), useMatrix = &quot;ATACMatrix&quot;) markerATAC &lt;- sort(grep(&quot;z:&quot;, markerATAC, value = TRUE)) markerATAC ## [1] &quot;z:Heme_B&quot; &quot;z:Heme_CD4&quot; ## [3] &quot;z:Heme_CD8&quot; &quot;z:Heme_Ery&quot; ## [5] &quot;z:Heme_HSC&quot; &quot;z:Heme_LMPP&quot; ## [7] &quot;z:Heme_Mono&quot; &quot;z:Heme_NK&quot; ## [9] &quot;z:IAtlas_DC_Plasmacytoid&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ATACMatrix&quot;, name = markerATAC, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-975cf5d51-Date-2025-02-06_Time-02-37-16.995515.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = ATACMatrix ## Getting Matrix Values... ## 2025-02-06 02:37:18.387709 : ## ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-975cf5d51-Date-2025-02-06_Time-02-37-16.995515.log p2 &lt;- lapply(p, function(x){ x + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) 15.2.3 Custom Deviations Instead of using the ArchR-curated region sets described above, we can provide our own custom region sets as a peak annotation. These custom annotations can be used in exactly the same way as the ArchR-curated annotations. First, in case you haven’t already created this “EncodePeaks” annotation in a previous chapter, lets create it by downloading some ENCODE peak sets and calling addPeakAnnotations(). EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) if(&quot;ChIP&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) } Then, we make a deviations matrix from this peak annotation. projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-913bca476-Date-2025-02-06_Time-02-37-27.670093.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:37:34.307498 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2025-02-06 02:37:56.862068 : Completed Computing Deviations!, 0.487 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-913bca476-Date-2025-02-06_Time-02-37-27.670093.log The rest of the analysis workflow is the same as what has now been presented multiple times above. We can plot the ranked deviations. plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ChIPMatrix&quot;) ## DataFrame with 4 rows and 6 columns ## seqnames idx name combinedVars combinedMeans rank ## &lt;Rle&gt; &lt;integer&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; ## f1 z 1 Encode_K562_GATA1 11.81450 -0.00284038 1 ## f3 z 3 Encode_K562_Ebf1 4.87639 0.04424422 2 ## f4 z 4 Encode_K562_Pax5 2.76798 -0.01397631 3 ## f2 z 2 Encode_GM12878_CEBPB 1.38978 -0.00600790 4 plotVarDev ## Warning: Removed 21 rows containing missing values or values outside the scale ## range (`geom_label_repel()`). To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotVarDev, name = &quot;Variable-ChIP-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## Plotting Ggplot! And we can plot the deviation z-scores overlayed on our UMAP embedding. markerChIP &lt;- getFeatures(projHeme5, useMatrix = &quot;ChIPMatrix&quot;) markerChIP &lt;- sort(grep(&quot;z:&quot;, markerChIP, value = TRUE)) markerChIP ## [1] &quot;z:Encode_GM12878_CEBPB&quot; &quot;z:Encode_K562_Ebf1&quot; &quot;z:Encode_K562_GATA1&quot; ## [4] &quot;z:Encode_K562_Pax5&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ChIPMatrix&quot;, name = markerChIP, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9a35a137-Date-2025-02-06_Time-02-38-04.777479.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = ChIPMatrix ## Getting Matrix Values... ## 2025-02-06 02:38:06.196386 : ## ## Plotting Embedding ## 1 2 3 4 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9a35a137-Date-2025-02-06_Time-02-38-04.777479.log p2 &lt;- lapply(p, function(x){ x + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 2),p2)) "],["footprinting-with-archr.html", "Chapter 16 Footprinting with ArchR", " Chapter 16 Footprinting with ArchR Transcription factor (TF) footprinting allows for the prediction of the precise binding location of a TF at a particular locus. This is because the DNA bases that are directly bound by the TF are actually protected from transposition while the DNA bases immediately adjacent to TF binding are accessible. Ideally, TF footprinting is performed at a single site to determine the precise binding location of the TF. However, in practice, this requires very high sequencing depth, often much higher depth than what most users would obtain from either bulk or single-cell ATAC-seq. To get around this problem, we can combine Tn5 insertion locations across many instances of predicted TF binding. For example, we can take all peaks that harbor a CTCF motif and make an aggregate TF footprint for CTCF across the whole genome. It is important to understand the difference between single-site footprinting and “meta footprinting”, which is really what ArchR is doing. The accuracy of this footprint relies on generating a reliable curated list of predicted binding sites for the TF of interest. ArchR does this in a naive way via the addMotifAnnotations() functions by searching the peak regions for any DNA sequence matching a motif. Depending on the degeneracy of the motif of interest, this may or may not be sufficient. These motif annotations get added to the ArchRProject as a binary representation on a per peak basis (0 = no motif, 1 = motif present). Once you have these motif annotations, ArchR performs footprinting using the getFootprints() function which takes as input an ArchRProject object and a GenomicRanges object that contains the positions of the motifs. These positions can be accessed from the ArchRProject via the getPositions() function. These footprints can then be plotted using the plotFootprints() function. Perhaps most importantly, the footprinting analyses in ArchR account for known Tn5 insertion sequence bias. To do this, ArchR uses a matrix of hexamer position frequencies and a matrix of k-mer frequencies at Tn5 insertion sites: All put together, this workflow generates footprint plots that take into account Tn5 insertion bias. ArchR supports motif footprinting and custom footprinting of user-supplied features, both of which are discussed in this chapter. "],["motif-footprinting.html", "16.1 Motif Footprinting", " 16.1 Motif Footprinting Importantly, the footprints generated from this tutorial data are not as clean as would be desired but this is because of the small size of the tutorial dataset. Footprints generated from larger datasets would be expected to show even less variation. When footprinting, the first thing we need to do is obtain the positions of the relevant motifs. To do this, we call the getPositions() function. This function has an optional parameter called name which can accept the name of the peakAnnotation object from which we would like to obtain the positions. If name = NULL, then ArchR will use the first entry in the peakAnnotation slot. In the example shown below, we do not specify name and ArchR uses the first entry which is our CIS-BP motifs. motifPositions &lt;- getPositions(projHeme5) This creates a GRangesList object where each TF motif is represented by a separate GRanges object. motifPositions ## GRangesList object of length 870: ## $TFAP2B_1 ## GRanges object with 17409 ranges and 1 metadata column: ## seqnames ranges strand | score ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; ## [1] chr1 852468-852479 + | 8.17077 ## [2] chr1 873916-873927 + | 8.31842 ## [3] chr1 873916-873927 - | 8.31842 ## [4] chr1 896671-896682 + | 9.95541 ## [5] chr1 896671-896682 - | 8.91854 ## ... ... ... ... . ... ## [17405] chrX 154004258-154004269 - | 9.05749 ## [17406] chrX 154299568-154299579 + | 8.89420 ## [17407] chrX 154664929-154664940 - | 8.15963 ## [17408] chrX 154807684-154807695 + | 9.57083 ## [17409] chrX 154807684-154807695 - | 10.60491 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths ## ## ... ## &lt;869 more elements&gt; We can subset this GRangesList to a few TF motifs that we are interested in. Because the SREBF1 TF comes up when we search for “EBF1”, we explicitly remove it from the downstream analyses below using the %ni% helper function which provides the opposite functionality of %in% from base R. motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) markerMotifs &lt;- unlist(lapply(motifs, function(x) grep(x, names(motifPositions), value = TRUE))) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;SREBF1_22&quot;] markerMotifs ## [1] &quot;GATA1_383&quot; &quot;CEBPA_155&quot; &quot;EBF1_67&quot; &quot;IRF4_632&quot; &quot;TBX21_780&quot; &quot;PAX5_709&quot; To accurately profile TF footprints, a large number of reads are required. Therefore, cells are grouped to create pseudo-bulk ATAC-seq profiles that can be then used for TF footprinting. These pseudo-bulk profiles are stored as group coverage files which we originally created in a previous chapter to perform peak calling. If you haven’t already added group coverages to your ArchRProject, lets do that now. if(is.null(projHeme5@projectMetadata$GroupCoverages$Clusters2)){ projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) } With group coverages calculated, we can now compute footprints for the subset of marker motifs that we previously selected using the getFootprints() function. Even though ArchR implements a highly optimized footprinting workflow, it is recommended to perform footprinting on a subset of motifs rather than all motifs. As such, we provide the subset of motifs to footprint via the positions parameter. seFoot &lt;- getFootprints( ArchRProj = projHeme5, positions = motifPositions[markerMotifs], groupBy = &quot;Clusters2&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getFootprints-91455ab47-Date-2025-02-06_Time-02-39-53.799919.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:39:54.353679 : Computing Kmer Bias Table, 0.009 mins elapsed. ## 2025-02-06 02:40:00.975188 : Finished Computing Kmer Tables, 0.11 mins elapsed. ## 2025-02-06 02:40:00.976127 : Computing Footprints, 0.12 mins elapsed. ## 2025-02-06 02:40:17.403599 : Computing Footprints Bias, 0.393 mins elapsed. ## 2025-02-06 02:40:32.376185 : Summarizing Footprints, 0.643 mins elapsed. Once we have retrieved these footprints, we can plot them using the plotFootprints() function. This function can simultaneously normalize the footprints in various ways. This normalization and the actual plotting of the footprints is discussed in the next section. "],["normalization-of-footprints-for-tn5-bias.html", "16.2 Normalization of Footprints for Tn5 Bias", " 16.2 Normalization of Footprints for Tn5 Bias One major challenge with TF footprinting using ATAC-seq data is the insertion sequence bias of the Tn5 transposase which can lead to misclassification of TF footprints. To account for Tn5 insertion bias, ArchR identifies the k-mer (user-defined length, default length 6) sequences surrounding each Tn5 insertion site. To do this analysis, ArchR identifies single-base resolution Tn5 insertion sites for each pseudo-bulk, resizes these 1-bp sites to k-bp windows (-k/2 and + (k/2 - 1) bp from insertion), and then creates a k-mer frequency table using the oligonucleotidefrequency(w=k, simplify.as=\"collapse\") function from the Biostrings package. ArchR then calculates the expected k-mers genome-wide using the same function with the BSgenome-associated genome file. To calculate the insertion bias for a pseudo-bulk footprint, ArchR creates a k-mer frequency matrix that is represented as all possible k-mers across a window +/- N bp (user-defined, default 250 bp) from the motif center. Then, iterating over each motif site, ArchR fills in the positioned k-mers into the k-mer frequency matrix. This is then calculated for each motif position genome-wide. Using the sample’s k-mer frequency table, ArchR can then compute the expected Tn5 insertions by multiplying the k-mer position frequency table by the observed/expected Tn5 k-mer frequency. All of this happens under the hood within the plotFootprints() function. 16.2.1 Subtracting the Tn5 Bias One normalization method subtracts the Tn5 bias from the footprinting signal. This normalization is performed by setting normMethod = \"Subtract\" when calling plotFootprints(). plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;Subtract&quot;, plotName = &quot;Footprints-Subtract-Bias&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-95a9a2bd7-Date-2025-02-06_Time-02-40-35.7012.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:40:35.874202 : Plotting Footprint : GATA1_383 (1 of 6), 0.003 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2025-02-06 02:40:36.930625 : Plotting Footprint : CEBPA_155 (2 of 6), 0.02 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2025-02-06 02:40:38.149221 : Plotting Footprint : EBF1_67 (3 of 6), 0.041 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2025-02-06 02:40:37.414356 : Plotting Footprint : IRF4_632 (4 of 6), 0.029 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2025-02-06 02:40:38.625704 : Plotting Footprint : TBX21_780 (5 of 6), 0.049 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2025-02-06 02:40:39.683537 : Plotting Footprint : PAX5_709 (6 of 6), 0.066 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-95a9a2bd7-Date-2025-02-06_Time-02-40-35.7012.log By default, these plots will be saved in the outputDirectory of the ArchRProject. If you requested to plot all motifs and returned this as a ggplot object, this ggplot object would be extremely large. An example of motif footprints from bias-subtracted analyses are shown below. 16.2.2 Dividing by the Tn5 Bias A second strategy for normalization divides the footprinting signal by the Tn5 bias signal. This normalization is performed by setting normMethod = \"Divide\" when calling plotFootprints(). plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;Divide&quot;, plotName = &quot;Footprints-Divide-Bias&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-93d04dc5-Date-2025-02-06_Time-02-40-44.012551.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:40:44.186213 : Plotting Footprint : GATA1_383 (1 of 6), 0.003 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2025-02-06 02:40:45.351897 : Plotting Footprint : CEBPA_155 (2 of 6), 0.022 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2025-02-06 02:40:46.601008 : Plotting Footprint : EBF1_67 (3 of 6), 0.043 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2025-02-06 02:40:47.846978 : Plotting Footprint : IRF4_632 (4 of 6), 0.064 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2025-02-06 02:40:49.30056 : Plotting Footprint : TBX21_780 (5 of 6), 0.088 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2025-02-06 02:40:50.731304 : Plotting Footprint : PAX5_709 (6 of 6), 0.112 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-93d04dc5-Date-2025-02-06_Time-02-40-44.012551.log An example of motif footprints from bias-divided analyses are shown below. 16.2.3 Footprinting Without Normalization for Tn5 Bias While we highly recommend normalizing footprints for Tn5 sequence insertion bias, it is possible to perform footprinting without normalization by setting normMethod = \"None\" in the plotFootprints() function. plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;None&quot;, plotName = &quot;Footprints-No-Normalization&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-94f0ac140-Date-2025-02-06_Time-02-40-54.965769.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:40:55.146243 : Plotting Footprint : GATA1_383 (1 of 6), 0.003 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2025-02-06 02:40:56.203805 : Plotting Footprint : CEBPA_155 (2 of 6), 0.021 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2025-02-06 02:40:57.43399 : Plotting Footprint : EBF1_67 (3 of 6), 0.041 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2025-02-06 02:40:58.622308 : Plotting Footprint : IRF4_632 (4 of 6), 0.061 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2025-02-06 02:40:59.826235 : Plotting Footprint : TBX21_780 (5 of 6), 0.081 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2025-02-06 02:41:00.904494 : Plotting Footprint : PAX5_709 (6 of 6), 0.099 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-94f0ac140-Date-2025-02-06_Time-02-40-54.965769.log An example of motif footprints without normalization are shown below. "],["feature-footprinting.html", "16.3 Feature Footprinting", " 16.3 Feature Footprinting In addition to footprinting motifs, ArchR enables footprinting of any user-defined feature set. To illustrate this capability, we will use the plotFootprints() function to create a TSS insertion profile (introduced previously during the section on data quality control). A TSS insertion profile is just a specialized sub-case of footprinting. As discussed in the previous section, footprinting is performed using group coverage files which are derived from pseudo-bulk replicates. We originally created these in a previous chapter to perform peak calling. If you haven’t already added group coverages to your ArchRProject, lets do that now. if(is.null(projHeme5@projectMetadata$GroupCoverages$Clusters2)){ projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) } We create TSS insertion profiles without normalization for Tn5 bias. The main difference from our previous analyses is that we specify flank = 2000 to extend these footprints 2000 bp on either side of each TSS. seTSS &lt;- getFootprints( ArchRProj = projHeme5, positions = GRangesList(TSS = getTSS(projHeme5)), groupBy = &quot;Clusters2&quot;, flank = 2000 ) ## ArchR logging to : ArchRLogs/ArchR-getFootprints-91f663143-Date-2025-02-06_Time-02-41-05.083804.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:41:05.603735 : Computing Kmer Bias Table, 0.009 mins elapsed. ## 2025-02-06 02:41:18.234618 : Finished Computing Kmer Tables, 0.21 mins elapsed. ## 2025-02-06 02:41:18.23562 : Computing Footprints, 0.219 mins elapsed. ## 2025-02-06 02:41:37.331191 : Computing Footprints Bias, 0.537 mins elapsed. ## 2025-02-06 02:41:53.403908 : Summarizing Footprints, 0.805 mins elapsed. We can then plot the TSS insertion profiles for each cell group using plotFootprints(). plotFootprints( seFoot = seTSS, ArchRProj = projHeme5, normMethod = &quot;None&quot;, plotName = &quot;TSS-No-Normalization&quot;, addDOC = FALSE, flank = 2000, flankNorm = 100 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-92fa2b418-Date-2025-02-06_Time-02-41-56.734039.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:41:56.918339 : Plotting Footprint : TSS (1 of 1), 0.003 mins elapsed. ## Normalizing by flanking regions ## NormMethod = None ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-92fa2b418-Date-2025-02-06_Time-02-41-56.734039.log "],["integrative-analysis-with-archr.html", "Chapter 17 Integrative Analysis with ArchR", " Chapter 17 Integrative Analysis with ArchR One of the main strengths of ArchR is its ability to integrate multiple levels of information to provide novel insights. This can take the form of ATAC-seq-only analyses such as identifying peak co-accessibility to predict regulatory interactions, or analyses that integrate scRNA-seq data such as prediction of enhancer activity through peak-to-gene linkage analysis. In either case, ArchR makes it easy to garner deeper insights from your scATAC-seq data. "],["creating-low-overlapping-aggregates-of-cells.html", "17.1 Creating Low-Overlapping Aggregates of Cells", " 17.1 Creating Low-Overlapping Aggregates of Cells ArchR facilitates many integrative analyses that involve correlation of features. Performing these calculations with sparse single-cell data can lead to substantial noise in these correlative analyses. To circumvent this challenge, we adopted an approach introduced by Cicero to create low-overlapping aggregates of single cells prior to these analyses. We filter aggregates with greater than 80% overlap with any other aggregate in order to reduce bias. To improve the speed of this approach, we developed an implementation of an optimized iterative overlap checking routine and a implementation of fast feature correlations in C++ using the “Rcpp” package. These optimized methods are used in ArchR for calculating peak co-accessibility, peak-to-gene linkage, and for other linkage analyses. The use of these low-overlapping aggregates happens under the hood but we mention it here for clarity. "],["co-accessibility-with-archr.html", "17.2 Co-accessibility with ArchR", " 17.2 Co-accessibility with ArchR Co-accessibility is a correlation in accessibility between two peaks across many single cells. Said another way, when Peak A is accessible in a single cell, Peak B is often also accessible. We illustrate this concept visually below, showing that Enhancer E3 is often co-accessible with Promoter P. One thing to note about co-accessibility analysis is that it often identified cell type-specific peaks as being co-accessibile. This is because these peaks are often all accessible together within a single cell type and often all not accessible in all other cell types. This drives a strong correlation but does not necessarily mean that there is a regulatory relationship between these peaks. To calculate co-accessibility in ArchR, we use the addCoAccessibility() function which stores peak co-accessibility information in the ArchRProject. projHeme5 &lt;- addCoAccessibility( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addCoAccessibility-95f3509d5-Date-2025-02-06_Time-02-43-51.08169.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:43:51.485349 : Computing KNN, 0.007 mins elapsed. ## 2025-02-06 02:43:51.577353 : Identifying Non-Overlapping KNN pairs, 0.008 mins elapsed. ## 2025-02-06 02:43:53.188808 : Identified 493 Groupings!, 0.035 mins elapsed. ## 2025-02-06 02:43:59.113994 : Computing Co-Accessibility chr1 (1 of 23), 0.134 mins elapsed. ## 2025-02-06 02:44:08.313653 : Computing Co-Accessibility chr2 (2 of 23), 0.287 mins elapsed. ## 2025-02-06 02:44:16.727436 : Computing Co-Accessibility chr3 (3 of 23), 0.427 mins elapsed. ## 2025-02-06 02:44:22.750216 : Computing Co-Accessibility chr4 (4 of 23), 0.528 mins elapsed. ## 2025-02-06 02:44:30.307904 : Computing Co-Accessibility chr5 (5 of 23), 0.654 mins elapsed. ## 2025-02-06 02:44:38.259914 : Computing Co-Accessibility chr6 (6 of 23), 0.786 mins elapsed. ## 2025-02-06 02:44:46.356375 : Computing Co-Accessibility chr7 (7 of 23), 0.921 mins elapsed. ## 2025-02-06 02:44:52.348607 : Computing Co-Accessibility chr8 (8 of 23), 1.021 mins elapsed. ## 2025-02-06 02:45:00.122384 : Computing Co-Accessibility chr9 (9 of 23), 1.151 mins elapsed. ## 2025-02-06 02:45:07.99718 : Computing Co-Accessibility chr10 (10 of 23), 1.282 mins elapsed. ## 2025-02-06 02:45:15.911764 : Computing Co-Accessibility chr11 (11 of 23), 1.414 mins elapsed. ## 2025-02-06 02:45:21.912721 : Computing Co-Accessibility chr12 (12 of 23), 1.514 mins elapsed. ## 2025-02-06 02:45:29.983331 : Computing Co-Accessibility chr13 (13 of 23), 1.648 mins elapsed. ## 2025-02-06 02:45:37.448417 : Computing Co-Accessibility chr14 (14 of 23), 1.773 mins elapsed. ## 2025-02-06 02:45:45.167054 : Computing Co-Accessibility chr15 (15 of 23), 1.901 mins elapsed. ## 2025-02-06 02:45:50.757761 : Computing Co-Accessibility chr16 (16 of 23), 1.995 mins elapsed. ## 2025-02-06 02:45:58.610244 : Computing Co-Accessibility chr17 (17 of 23), 2.125 mins elapsed. ## 2025-02-06 02:46:06.855097 : Computing Co-Accessibility chr18 (18 of 23), 2.263 mins elapsed. ## 2025-02-06 02:46:14.226 : Computing Co-Accessibility chr19 (19 of 23), 2.386 mins elapsed. ## 2025-02-06 02:46:20.553265 : Computing Co-Accessibility chr20 (20 of 23), 2.491 mins elapsed. ## 2025-02-06 02:46:28.219289 : Computing Co-Accessibility chr21 (21 of 23), 2.619 mins elapsed. ## 2025-02-06 02:46:35.541425 : Computing Co-Accessibility chr22 (22 of 23), 2.741 mins elapsed. ## 2025-02-06 02:46:43.061872 : Computing Co-Accessibility chrX (23 of 23), 2.866 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addCoAccessibility-95f3509d5-Date-2025-02-06_Time-02-43-51.08169.log If you aim to only perform co-accessibility analyses on a subset of cells in your project, you can specify which cells should be analyzed using the cellsToUse parameter. There are other important parameters to keep in mind depending on the precise composition of your own data. For example, the k parameter designates how many cells should be included in the low-overlapping cell groups for correlation analysis. If your dataset is very small, you may need to adjust this parameter accordingly (and other parameters like overlapCutoff) to ensure that you do not have high duplication rates with the same cells participating in many of the cell groupings. These same considerations apply to the getPeak2GeneLinks() function described below. We can retrieve this co-accessibility information from the ArchRProject via the getCoAccessibility() function which returns a DataFrame object if returnLoops = FALSE. cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = FALSE ) The DataFrame contains a few important pieces of information. The queryHits and subjectHits columns denote the index of the two peaks that were found to be correlated. The correlation column gives the numeric correlation of the accessibility between those two peaks. cA ## DataFrame with 100410 rows and 11 columns ## queryHits subjectHits seqnames correlation Variability1 Variability2 ## &lt;integer&gt; &lt;integer&gt; &lt;Rle&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 7 13 chr1 0.637747 0.00514607 0.03098155 ## 2 13 7 chr1 0.637747 0.03098155 0.00514607 ## 3 13 29 chr1 0.599347 0.03098155 0.00440347 ## 4 13 38 chr1 0.608207 0.03098155 0.01377298 ## 5 25 26 chr1 0.517674 0.02334748 0.00771205 ## ... ... ... ... ... ... ... ## 100406 147344 147339 chrX 0.511756 0.00978620 0.01293699 ## 100407 147367 147368 chrX 0.563453 0.00169568 0.00155184 ## 100408 147368 147367 chrX 0.563453 0.00155184 0.00169568 ## 100409 147373 147374 chrX 0.609453 0.01068828 0.00233270 ## 100410 147374 147373 chrX 0.609453 0.00233270 0.01068828 ## TStat Pval FDR VarQuantile1 VarQuantile2 ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 18.3468 1.21697e-57 1.56304e-55 0.555473 0.929311 ## 2 18.3468 1.21697e-57 1.56304e-55 0.929311 0.555473 ## 3 16.5906 2.11145e-49 1.84225e-47 0.929311 0.510818 ## 4 16.9783 3.33373e-51 3.17421e-49 0.929311 0.792828 ## 5 13.4072 3.79464e-35 1.55997e-33 0.884673 0.664324 ## ... ... ... ... ... ... ## 100406 13.1991 2.93656e-34 1.14815e-32 0.722281 0.780591 ## 100407 15.1126 1.19929e-42 7.42944e-41 0.238637 0.216621 ## 100408 15.1126 1.19929e-42 7.42944e-41 0.216621 0.238637 ## 100409 17.0336 1.84100e-51 1.77552e-49 0.741567 0.324191 ## 100410 17.0336 1.84100e-51 1.77552e-49 0.324191 0.741567 This co-accessibility DataFrame also has a metadata component containing a GRanges object of the relevant peaks. The indexes of queryHits and subjectHits mentioned above apply to this GRanges object. metadata(cA)[[1]] ## GRanges object with 147407 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## Mono chr1 752503-753003 * ## B chr1 762688-763188 * ## GMP chr1 773648-774148 * ## CD4.M chr1 779906-780406 * ## B chr1 801002-801502 * ## ... ... ... ... ## NK chrX 154807254-154807754 * ## PreB chrX 154840939-154841439 * ## PreB chrX 154841881-154842381 * ## NK chrX 154842390-154842890 * ## Progenitor chrX 154862036-154862536 * ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths If we set returnLoops = TRUE, then getCoAccessibility() will instead return the co-accessibility information in the form a loop track. In this GRanges object, the start and end of the IRanges map to the two different co-accessible peaks for each interaction. The resolution parameter sets the base-pair resolution of these loops. When resolution = 1, this creates loops that connect the center of each peak. cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = TRUE ) We can compare this GRanges object to the DataFrame object generated above. cA[[1]] ## GRanges object with 50205 ranges and 9 metadata columns: ## seqnames ranges strand | correlation Variability1 ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 845576-856616 * | 0.637747 0.00514607 ## [2] chr1 856616-901487 * | 0.599347 0.03098155 ## [3] chr1 856616-940557 * | 0.608207 0.03098155 ## [4] chr1 894693-895198 * | 0.517674 0.02334748 ## [5] chr1 901487-940557 * | 0.579194 0.01377298 ## ... ... ... ... . ... ... ## [50201] chrX 153529407-153597283 * | 0.514473 0.00259139 ## [50202] chrX 153597283-153637642 * | 0.517474 0.09252559 ## [50203] chrX 153686257-153715023 * | 0.511756 0.01293699 ## [50204] chrX 153959653-153960340 * | 0.563453 0.00169568 ## [50205] chrX 153980210-153990364 * | 0.609453 0.01068828 ## Variability2 TStat Pval FDR VarQuantile1 ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.03098155 18.3468 1.21697e-57 1.56304e-55 0.555473 ## [2] 0.00440347 16.5906 2.11145e-49 1.84225e-47 0.929311 ## [3] 0.01377298 16.9783 3.33373e-51 3.17421e-49 0.929311 ## [4] 0.00771205 13.4072 3.79464e-35 1.55997e-33 0.884673 ## [5] 0.00440347 15.7437 1.65808e-45 1.18689e-43 0.792828 ## ... ... ... ... ... ... ## [50201] 0.09252559 13.2943 1.15337e-34 4.61541e-33 0.354323 ## [50202] 0.02734691 13.4001 4.06966e-35 1.67015e-33 0.997672 ## [50203] 0.00978620 13.1991 2.93656e-34 1.14815e-32 0.780591 ## [50204] 0.00155184 15.1126 1.19929e-42 7.42944e-41 0.238637 ## [50205] 0.00233270 17.0336 1.84100e-51 1.77552e-49 0.741567 ## VarQuantile2 value ## &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.929311 0.637747 ## [2] 0.510818 0.599347 ## [3] 0.792828 0.608207 ## [4] 0.664324 0.517674 ## [5] 0.510818 0.579194 ## ... ... ... ## [50201] 0.997672 0.514473 ## [50202] 0.910198 0.517474 ## [50203] 0.722281 0.511756 ## [50204] 0.216621 0.563453 ## [50205] 0.324191 0.609453 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths This object contains a lot of information that can be helpful in further filtering the returned loops. In addition to filtering based on the correlation between peaks (via the corCutOff parameter), we have found it helpful to limit these analyses to stronger peaks (based on FDR) or loops that show more variability (i.e. higher values for VarQuantile1 and VarQuantile2). For example: cALoops &lt;- cA[[1]] cALoops &lt;- cALoops[cALoops$FDR &lt; 10^-10] cALoops &lt;- cALoops[rowMins(cbind(cALoops$VarQuantile1,cALoops$VarQuantile2)) &gt; 0.35] cALoops ## GRanges object with 37760 ranges and 9 metadata columns: ## seqnames ranges strand | correlation Variability1 ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 845576-856616 * | 0.637747 0.00514607 ## [2] chr1 856616-901487 * | 0.599347 0.03098155 ## [3] chr1 856616-940557 * | 0.608207 0.03098155 ## [4] chr1 894693-895198 * | 0.517674 0.02334748 ## [5] chr1 901487-940557 * | 0.579194 0.01377298 ## ... ... ... ... . ... ... ## [37756] chrX 153248873-153306007 * | 0.586708 0.00836791 ## [37757] chrX 153276018-153306007 * | 0.647290 0.01478763 ## [37758] chrX 153529407-153597283 * | 0.514473 0.00259139 ## [37759] chrX 153597283-153637642 * | 0.517474 0.09252559 ## [37760] chrX 153686257-153715023 * | 0.511756 0.01293699 ## Variability2 TStat Pval FDR VarQuantile1 ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.03098155 18.3468 1.21697e-57 1.56304e-55 0.555473 ## [2] 0.00440347 16.5906 2.11145e-49 1.84225e-47 0.929311 ## [3] 0.01377298 16.9783 3.33373e-51 3.17421e-49 0.929311 ## [4] 0.00771205 13.4072 3.79464e-35 1.55997e-33 0.884673 ## [5] 0.00440347 15.7437 1.65808e-45 1.18689e-43 0.792828 ## ... ... ... ... ... ... ## [37756] 0.0117999 16.0541 6.29899e-47 4.84649e-45 0.685606 ## [37757] 0.0117999 18.8168 7.11135e-60 1.01334e-57 0.805730 ## [37758] 0.0925256 13.2943 1.15337e-34 4.61541e-33 0.354323 ## [37759] 0.0273469 13.4001 4.06966e-35 1.67015e-33 0.997672 ## [37760] 0.0097862 13.1991 2.93656e-34 1.14815e-32 0.780591 ## VarQuantile2 value ## &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.929311 0.637747 ## [2] 0.510818 0.599347 ## [3] 0.792828 0.608207 ## [4] 0.664324 0.517674 ## [5] 0.510818 0.579194 ## ... ... ... ## [37756] 0.762503 0.586708 ## [37757] 0.762503 0.647290 ## [37758] 0.997672 0.514473 ## [37759] 0.910198 0.517474 ## [37760] 0.722281 0.511756 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths To help with over-plotting of co-accessibility interactions we can decrease the resolution of our loops to resolution = 1000. Below, we see that there are fewer total entries in our GRanges object than above. cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1000, returnLoops = TRUE ) cA[[1]] ## GRanges object with 48198 ranges and 9 metadata columns: ## seqnames ranges strand | correlation Variability1 ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 845500-856500 * | 0.637747 0.00514607 ## [2] chr1 856500-901500 * | 0.599347 0.03098155 ## [3] chr1 856500-940500 * | 0.608207 0.03098155 ## [4] chr1 894500-895500 * | 0.517674 0.02334748 ## [5] chr1 901500-940500 * | 0.579194 0.01377298 ## ... ... ... ... . ... ... ## [48194] chrX 153529500-153597500 * | 0.514473 0.00259139 ## [48195] chrX 153597500-153637500 * | 0.517474 0.09252559 ## [48196] chrX 153686500-153715500 * | 0.511756 0.01293699 ## [48197] chrX 153959500-153960500 * | 0.563453 0.00169568 ## [48198] chrX 153980500-153990500 * | 0.609453 0.01068828 ## Variability2 TStat Pval FDR VarQuantile1 ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.03098155 18.3468 1.21697e-57 1.56304e-55 0.555473 ## [2] 0.00440347 16.5906 2.11145e-49 1.84225e-47 0.929311 ## [3] 0.01377298 16.9783 3.33373e-51 3.17421e-49 0.929311 ## [4] 0.00771205 13.4072 3.79464e-35 1.55997e-33 0.884673 ## [5] 0.00440347 15.7437 1.65808e-45 1.18689e-43 0.792828 ## ... ... ... ... ... ... ## [48194] 0.09252559 13.2943 1.15337e-34 4.61541e-33 0.354323 ## [48195] 0.02734691 13.4001 4.06966e-35 1.67015e-33 0.997672 ## [48196] 0.00978620 13.1991 2.93656e-34 1.14815e-32 0.780591 ## [48197] 0.00155184 15.1126 1.19929e-42 7.42944e-41 0.238637 ## [48198] 0.00233270 17.0336 1.84100e-51 1.77552e-49 0.741567 ## VarQuantile2 value ## &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.929311 0.637747 ## [2] 0.510818 0.599347 ## [3] 0.792828 0.608207 ## [4] 0.664324 0.517674 ## [5] 0.510818 0.579194 ## ... ... ... ## [48194] 0.997672 0.514473 ## [48195] 0.910198 0.517474 ## [48196] 0.722281 0.511756 ## [48197] 0.216621 0.563453 ## [48198] 0.324191 0.609453 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Similarly, if we decrease the resolution even further with resolution = 10000, we identify even fewer co-accessibility interactions. cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 10000, returnLoops = TRUE ) cA[[1]] ## GRanges object with 33744 ranges and 9 metadata columns: ## seqnames ranges strand | correlation Variability1 ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 845000-855000 * | 0.637747 0.00514607 ## [2] chr1 855000-905000 * | 0.599347 0.03098155 ## [3] chr1 855000-945000 * | 0.608207 0.03098155 ## [4] chr1 895000 * | 0.517674 0.02334748 ## [5] chr1 905000-945000 * | 0.579194 0.01377298 ## ... ... ... ... . ... ... ## [33740] chrX 153525000-153595000 * | 0.514473 0.00259139 ## [33741] chrX 153595000-153635000 * | 0.517474 0.09252559 ## [33742] chrX 153685000-153715000 * | 0.511756 0.01293699 ## [33743] chrX 153955000-153965000 * | 0.563453 0.00169568 ## [33744] chrX 153985000-153995000 * | 0.609453 0.01068828 ## Variability2 TStat Pval FDR VarQuantile1 ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.03098155 18.3468 1.21697e-57 1.56304e-55 0.555473 ## [2] 0.00440347 16.5906 2.11145e-49 1.84225e-47 0.929311 ## [3] 0.01377298 16.9783 3.33373e-51 3.17421e-49 0.929311 ## [4] 0.00771205 13.4072 3.79464e-35 1.55997e-33 0.884673 ## [5] 0.00440347 15.7437 1.65808e-45 1.18689e-43 0.792828 ## ... ... ... ... ... ... ## [33740] 0.09252559 13.2943 1.15337e-34 4.61541e-33 0.354323 ## [33741] 0.02734691 13.4001 4.06966e-35 1.67015e-33 0.997672 ## [33742] 0.00978620 13.1991 2.93656e-34 1.14815e-32 0.780591 ## [33743] 0.00155184 15.1126 1.19929e-42 7.42944e-41 0.238637 ## [33744] 0.00233270 17.0336 1.84100e-51 1.77552e-49 0.741567 ## VarQuantile2 value ## &lt;numeric&gt; &lt;numeric&gt; ## [1] 0.929311 0.637747 ## [2] 0.510818 0.599347 ## [3] 0.792828 0.608207 ## [4] 0.664324 0.517674 ## [5] 0.510818 0.579194 ## ... ... ... ## [33740] 0.997672 0.514473 ## [33741] 0.910198 0.517474 ## [33742] 0.722281 0.511756 ## [33743] 0.216621 0.563453 ## [33744] 0.324191 0.609453 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths 17.2.1 Plotting browser tracks of Co-accessibility Once we have added co-accessibility informtation to our ArchRProject we can use this as a loop track when plotting browser tracks. We do this via the loops parameter to the plotBrowserTrack() function. Here, we are using the default parameters for getCoAccessibility() which include corCutOff = 0.5, resolution = 1000, and returnLoops = TRUE. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000, loops = getCoAccessibility(projHeme5) ) ## ArchR logging to : ArchRLogs/ArchR-plotBrowserTrack-934c920d5-Date-2025-02-06_Time-02-46-52.415133.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:46:53.022687 : Validating Region, 0.01 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ------- ## seqinfo: 24 sequences from hg19 genome ## 2025-02-06 02:46:53.094381 : Adding Bulk Tracks (1 of 9), 0.011 mins elapsed. ## 2025-02-06 02:46:55.176209 : Adding Feature Tracks (1 of 9), 0.046 mins elapsed. ## 2025-02-06 02:46:55.25984 : Adding Loop Tracks (1 of 9), 0.047 mins elapsed. ## 2025-02-06 02:46:55.399196 : Adding Gene Tracks (1 of 9), 0.05 mins elapsed. ## 2025-02-06 02:46:55.742377 : Plotting, 0.055 mins elapsed. ## 2025-02-06 02:46:56.541037 : Adding Bulk Tracks (2 of 9), 0.069 mins elapsed. ## 2025-02-06 02:46:58.3216 : Adding Feature Tracks (2 of 9), 0.098 mins elapsed. ## 2025-02-06 02:46:58.405199 : Adding Loop Tracks (2 of 9), 0.1 mins elapsed. ## 2025-02-06 02:46:58.591959 : Adding Gene Tracks (2 of 9), 0.103 mins elapsed. ## 2025-02-06 02:46:58.796852 : Plotting, 0.106 mins elapsed. ## 2025-02-06 02:46:59.689016 : Adding Bulk Tracks (3 of 9), 0.121 mins elapsed. ## 2025-02-06 02:47:01.491356 : Adding Feature Tracks (3 of 9), 0.151 mins elapsed. ## 2025-02-06 02:47:01.577291 : Adding Loop Tracks (3 of 9), 0.153 mins elapsed. ## 2025-02-06 02:47:02.074779 : Adding Gene Tracks (3 of 9), 0.161 mins elapsed. ## 2025-02-06 02:47:02.274246 : Plotting, 0.164 mins elapsed. ## 2025-02-06 02:47:03.255812 : Adding Bulk Tracks (4 of 9), 0.181 mins elapsed. ## 2025-02-06 02:47:05.0556 : Adding Feature Tracks (4 of 9), 0.211 mins elapsed. ## 2025-02-06 02:47:05.139917 : Adding Loop Tracks (4 of 9), 0.212 mins elapsed. ## 2025-02-06 02:47:05.404111 : Adding Gene Tracks (4 of 9), 0.217 mins elapsed. ## 2025-02-06 02:47:05.605285 : Plotting, 0.22 mins elapsed. ## 2025-02-06 02:47:06.370167 : Adding Bulk Tracks (5 of 9), 0.233 mins elapsed. ## 2025-02-06 02:47:08.110441 : Adding Feature Tracks (5 of 9), 0.262 mins elapsed. ## 2025-02-06 02:47:08.194293 : Adding Loop Tracks (5 of 9), 0.263 mins elapsed. ## 2025-02-06 02:47:08.608782 : Adding Gene Tracks (5 of 9), 0.27 mins elapsed. ## 2025-02-06 02:47:08.812891 : Plotting, 0.273 mins elapsed. ## 2025-02-06 02:47:09.633111 : Adding Bulk Tracks (6 of 9), 0.287 mins elapsed. ## 2025-02-06 02:47:09.581985 : Adding Feature Tracks (6 of 9), 0.286 mins elapsed. ## 2025-02-06 02:47:09.659093 : Adding Loop Tracks (6 of 9), 0.287 mins elapsed. ## 2025-02-06 02:47:10.1937 : Adding Gene Tracks (6 of 9), 0.296 mins elapsed. ## 2025-02-06 02:47:10.388781 : Plotting, 0.3 mins elapsed. ## 2025-02-06 02:47:11.182084 : Adding Bulk Tracks (7 of 9), 0.313 mins elapsed. ## 2025-02-06 02:47:13.100951 : Adding Feature Tracks (7 of 9), 0.345 mins elapsed. ## 2025-02-06 02:47:13.180962 : Adding Loop Tracks (7 of 9), 0.346 mins elapsed. ## 2025-02-06 02:47:13.970203 : Adding Gene Tracks (7 of 9), 0.359 mins elapsed. ## 2025-02-06 02:47:14.175013 : Plotting, 0.363 mins elapsed. ## 2025-02-06 02:47:15.095396 : Adding Bulk Tracks (8 of 9), 0.378 mins elapsed. ## 2025-02-06 02:47:16.848731 : Adding Feature Tracks (8 of 9), 0.407 mins elapsed. ## 2025-02-06 02:47:16.929622 : Adding Loop Tracks (8 of 9), 0.409 mins elapsed. ## 2025-02-06 02:47:17.552829 : Adding Gene Tracks (8 of 9), 0.419 mins elapsed. ## 2025-02-06 02:47:17.765846 : Plotting, 0.423 mins elapsed. ## 2025-02-06 02:47:18.767357 : Adding Bulk Tracks (9 of 9), 0.439 mins elapsed. ## 2025-02-06 02:47:20.563891 : Adding Feature Tracks (9 of 9), 0.469 mins elapsed. ## 2025-02-06 02:47:20.645648 : Adding Loop Tracks (9 of 9), 0.471 mins elapsed. ## 2025-02-06 02:47:21.197408 : Adding Gene Tracks (9 of 9), 0.48 mins elapsed. ## 2025-02-06 02:47:21.391975 : Plotting, 0.483 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-plotBrowserTrack-934c920d5-Date-2025-02-06_Time-02-46-52.415133.log To plot our browser track we use the grid.draw function and select a specific marker gene by name using the $ accessor. grid::grid.newpage() grid::grid.draw(p$CD14) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes-with-CoAccessibility.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL "],["peak2genelinkage-with-archr.html", "17.3 Peak2GeneLinkage with ArchR", " 17.3 Peak2GeneLinkage with ArchR Similar to co-accessibility, ArchR can also identify so-called “peak-to-gene links”. The primary differences between peak-to-gene links and co-accessibility is that co-accessibility is an ATAC-seq-only analysis that looks for correlations in accessibility between two peaks while peak-to-gene linkage leverages integrated scRNA-seq data to look for correlations between peak accessibility and gene expression. These represent orthogonal approaches to a similar problem. However, because peak-to-gene linkage correlates scATAC-seq and scRNA-seq data, we often think of these links as more relevant to gene regulatory interactions. To identify peak-to-gene links in ArchR, we use the addPeak2GeneLinks() function. projHeme5 &lt;- addPeak2GeneLinks( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addPeak2GeneLinks-9711a92c1-Date-2025-02-06_Time-02-47-26.96776.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:47:27.421921 : Getting Available Matrices, 0.008 mins elapsed. ## 2025-02-06 02:47:28.973197 : Filtered Low Prediction Score Cells (1719 of 10250, 0.168), 0.008 mins elapsed. ## 2025-02-06 02:47:29.599043 : Computing KNN, 0.019 mins elapsed. ## 2025-02-06 02:47:29.694643 : Identifying Non-Overlapping KNN pairs, 0.02 mins elapsed. ## 2025-02-06 02:47:31.214207 : Identified 493 Groupings!, 0.046 mins elapsed. ## 2025-02-06 02:47:31.244854 : Getting Group RNA Matrix, 0.046 mins elapsed. ## 2025-02-06 02:48:04.61646 : Getting Group ATAC Matrix, 0.602 mins elapsed. ## 2025-02-06 02:48:40.540854 : Normalizing Group Matrices, 1.201 mins elapsed. ## 2025-02-06 02:48:45.903532 : Finding Peak Gene Pairings, 1.29 mins elapsed. ## 2025-02-06 02:48:46.204627 : Computing Correlations, 1.295 mins elapsed. ## 2025-02-06 02:49:02.312747 : Completed Peak2Gene Correlations!, 1.564 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeak2GeneLinks-9711a92c1-Date-2025-02-06_Time-02-47-26.96776.log We can then retrieve these peak-to-gene links in a similar fashion to how we retrieved co-accessibility interactions by using the getPeak2GeneLinks() function. As we saw previously, this function allows for a user-specified cutoff for correlation and resolution for linkages. p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1, returnLoops = FALSE ) When returnLoops is set to false, this function returns a DataFrame object anaolgous to the DataFrame object returned by getCoAccessibility(). The primary difference is that the indexes for the scATAC-seq peaks are stored in a column called idxATAC and the indexes for the scRNA-seq gene are stored in a column called idxRNA. p2g ## DataFrame with 43706 rows and 6 columns ## idxATAC idxRNA Correlation FDR VarQATAC VarQRNA ## &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 5 2 0.595121 6.46022e-47 0.351537 0.480619 ## 2 50 4 0.481528 9.74742e-29 0.740901 0.309768 ## 3 51 4 0.523227 1.30350e-34 0.652344 0.309768 ## 4 91 5 0.577011 1.60106e-43 0.875806 0.687221 ## 5 2 6 0.462365 2.66174e-26 0.904862 0.481049 ## ... ... ... ... ... ... ... ## 43702 147359 18589 0.464330 1.52289e-26 0.692552 0.736896 ## 43703 147358 18590 0.474616 7.68618e-28 0.355919 0.957045 ## 43704 147359 18590 0.521417 2.44218e-34 0.692552 0.957045 ## 43705 147373 18590 0.599431 9.35259e-48 0.769238 0.957045 ## 43706 147373 18591 0.511117 8.04962e-33 0.769238 0.960594 Here, idxATAC and idxRNA refer to the row indices of the peak or gene in the corresponding geneSet or peakSet which can be accessed via the metadata component of the p2g object. metadata(p2g) ## $peakSet ## GRanges object with 147407 ranges and 0 metadata columns: ## seqnames ranges strand ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; ## [1] chr1 752503-753003 * ## [2] chr1 762688-763188 * ## [3] chr1 773648-774148 * ## [4] chr1 779906-780406 * ## [5] chr1 801002-801502 * ## ... ... ... ... ## [147403] chrX 154807254-154807754 * ## [147404] chrX 154840939-154841439 * ## [147405] chrX 154841881-154842381 * ## [147406] chrX 154842390-154842890 * ## [147407] chrX 154862036-154862536 * ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths ## ## $geneSet ## GRanges object with 18601 ranges and 2 metadata columns: ## seqnames ranges strand | name idx ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; ## [1] chr1 69091 * | OR4F5 1 ## [2] chr1 762902 * | LINC00115 2 ## [3] chr1 812182 * | FAM41C 3 ## [4] chr1 860530 * | SAMD11 4 ## [5] chr1 894679 * | NOC2L 5 ## ... ... ... ... . ... ... ## [18597] chrX 154299695 * | BRCC3 708 ## [18598] chrX 154444701 * | VBP1 709 ## [18599] chrX 154493852 * | RAB39B 710 ## [18600] chrX 154563986 * | CLIC2 711 ## [18601] chrX 154842622 * | TMLHE 712 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths ## ## $seATAC ## [1] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4/Peak2GeneLinks/seATAC-Group-KNN.rds&quot; ## ## $seRNA ## [1] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4/Peak2GeneLinks/seRNA-Group-KNN.rds&quot; It is important not to confuse idxRNA with the value in the idx column of the geneSet. Within the geneSet, idx corresponds to the chronological position of the given gene across each chromosome. As such, idx is only unique across an individual chromosome and is not relevant for mapping idxRNA to a gene name. So, if we wanted to add the gene name and peak coordinates to our p2g DataFrame object, we would do the following: p2g$geneName &lt;- mcols(metadata(p2g)$geneSet)$name[p2g$idxRNA] p2g$peakName &lt;- (metadata(p2g)$peakSet %&gt;% {paste0(seqnames(.), &quot;_&quot;, start(.), &quot;_&quot;, end(.))})[p2g$idxATAC] p2g ## DataFrame with 43706 rows and 8 columns ## idxATAC idxRNA Correlation FDR VarQATAC VarQRNA ## &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 5 2 0.595121 6.46022e-47 0.351537 0.480619 ## 2 50 4 0.481528 9.74742e-29 0.740901 0.309768 ## 3 51 4 0.523227 1.30350e-34 0.652344 0.309768 ## 4 91 5 0.577011 1.60106e-43 0.875806 0.687221 ## 5 2 6 0.462365 2.66174e-26 0.904862 0.481049 ## ... ... ... ... ... ... ... ## 43702 147359 18589 0.464330 1.52289e-26 0.692552 0.736896 ## 43703 147358 18590 0.474616 7.68618e-28 0.355919 0.957045 ## 43704 147359 18590 0.521417 2.44218e-34 0.692552 0.957045 ## 43705 147373 18590 0.599431 9.35259e-48 0.769238 0.957045 ## 43706 147373 18591 0.511117 8.04962e-33 0.769238 0.960594 ## geneName peakName ## &lt;character&gt; &lt;character&gt; ## 1 LINC00115 chr1_801002_801502 ## 2 SAMD11 chr1_974038_974538 ## 3 SAMD11 chr1_974855_975355 ## 4 NOC2L chr1_1136870_1137370 ## 5 KLHL17 chr1_762688_763188 ## ... ... ... ## 43702 GAB3 chrX_153832174_15383.. ## 43703 DKC1 chrX_153828590_15382.. ## 43704 DKC1 chrX_153832174_15383.. ## 43705 DKC1 chrX_153979960_15398.. ## 43706 MPP1 chrX_153979960_15398.. You may also notice that there is other information stored within the metadata() of p2g including pointers to files called seATAC and seRNA which represent SummarizedExperiment objects for the ATAC-seq and RNA-seq data used to identify peak-to-gene linkages and these each include both the raw and normalized data matrices used in the analysis. metadata(p2g)$seATAC ## [1] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4/Peak2GeneLinks/seATAC-Group-KNN.rds&quot; metadata(p2g)$seRNA ## [1] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4/Peak2GeneLinks/seRNA-Group-KNN.rds&quot; If we set returnLoops = TRUE, then getPeak2GeneLinks() will return a loop track GRanges object that connects the peak and gene. As for co-accessibility, the start and end of the IRanges object represent the position of the peak and gene being linked. When resolution = 1, this links the center of the peak to the single-base TSS of the gene. p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 43626 ranges and 2 metadata columns: ## seqnames ranges strand | value FDR ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 762902-801252 * | 0.595121 6.46022e-47 ## [2] chr1 762938-895967 * | 0.462365 2.66174e-26 ## [3] chr1 762938-948847 * | 0.550805 5.63187e-39 ## [4] chr1 860530-974288 * | 0.481528 9.74742e-29 ## [5] chr1 860530-975105 * | 0.523227 1.30350e-34 ## ... ... ... ... . ... ... ## [43622] chrX 153828840-153991031 * | 0.474616 7.68618e-28 ## [43623] chrX 153832424-153979858 * | 0.464330 1.52289e-26 ## [43624] chrX 153832424-153991031 * | 0.521417 2.44218e-34 ## [43625] chrX 153980210-153991031 * | 0.599431 9.35259e-48 ## [43626] chrX 153980210-154033802 * | 0.511117 8.04962e-33 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths We can alternatively decrease the resolution of these links by setting resolution = 1000. This is primarily useful for plotting the links as a browser tracks because there are instances where many nearby peaks all link to the same gene and this can be difficult to visualize. p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1000, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 42045 ranges and 2 metadata columns: ## seqnames ranges strand | value FDR ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 762500-801500 * | 0.595121 6.46022e-47 ## [2] chr1 762500-895500 * | 0.462365 2.66174e-26 ## [3] chr1 762500-948500 * | 0.550805 5.63187e-39 ## [4] chr1 860500-974500 * | 0.481528 9.74742e-29 ## [5] chr1 860500-975500 * | 0.523227 1.30350e-34 ## ... ... ... ... . ... ... ## [42041] chrX 153828500-153991500 * | 0.474616 7.68618e-28 ## [42042] chrX 153832500-153979500 * | 0.464330 1.52289e-26 ## [42043] chrX 153832500-153991500 * | 0.521417 2.44218e-34 ## [42044] chrX 153980500-153991500 * | 0.599431 9.35259e-48 ## [42045] chrX 153980500-154033500 * | 0.511117 8.04962e-33 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Decreasing the resolution even further also decreases the total number of peak-to-gene links identified. p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 10000, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 33725 ranges and 2 metadata columns: ## seqnames ranges strand | value FDR ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 765000-805000 * | 0.595121 6.46022e-47 ## [2] chr1 765000-895000 * | 0.462365 2.66174e-26 ## [3] chr1 765000-945000 * | 0.550805 5.63187e-39 ## [4] chr1 865000-975000 * | 0.523227 1.30350e-34 ## [5] chr1 895000 * | 0.474614 7.69115e-28 ## ... ... ... ... . ... ... ## [33721] chrX 153825000-153995000 * | 0.474616 7.68618e-28 ## [33722] chrX 153835000-153975000 * | 0.464330 1.52289e-26 ## [33723] chrX 153835000-153995000 * | 0.521417 2.44218e-34 ## [33724] chrX 153985000-153995000 * | 0.599431 9.35259e-48 ## [33725] chrX 153985000-154035000 * | 0.511117 8.04962e-33 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths You may find that you would like to use a statistical approach to evaluate peak-to-gene associations. Such an approach was developed in Regner et al. 2021 and involves using permutation testing to empirically derive an FDR. This approach is quite computationally expensive but has been implemented as an option in addPeak2GeneLinks() via the addPermutedPval parameter. For more information on this approach, see this discussion post. 17.3.1 Plotting browser tracks with peak-to-gene links To plot these peak-to-gene links as a browser track, we use the same workflow shown for co-accessibility in the previous section. Here we use the plotBrowserTrack() function markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000, loops = getPeak2GeneLinks(projHeme5) ) ## ArchR logging to : ArchRLogs/ArchR-plotBrowserTrack-925b468a1-Date-2025-02-06_Time-02-49-03.297189.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:49:01.985563 : Validating Region, 0.022 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ------- ## seqinfo: 24 sequences from hg19 genome ## 2025-02-06 02:49:02.075656 : Adding Bulk Tracks (1 of 9), 0.02 mins elapsed. ## 2025-02-06 02:49:03.994375 : Adding Feature Tracks (1 of 9), 0.012 mins elapsed. ## 2025-02-06 02:49:04.076611 : Adding Loop Tracks (1 of 9), 0.013 mins elapsed. ## 2025-02-06 02:49:04.211859 : Adding Gene Tracks (1 of 9), 0.015 mins elapsed. ## 2025-02-06 02:49:04.420231 : Plotting, 0.019 mins elapsed. ## 2025-02-06 02:49:05.577812 : Adding Bulk Tracks (2 of 9), 0.038 mins elapsed. ## 2025-02-06 02:49:07.455849 : Adding Feature Tracks (2 of 9), 0.069 mins elapsed. ## 2025-02-06 02:49:07.546801 : Adding Loop Tracks (2 of 9), 0.071 mins elapsed. ## 2025-02-06 02:49:07.6892 : Adding Gene Tracks (2 of 9), 0.073 mins elapsed. ## 2025-02-06 02:49:07.906346 : Plotting, 0.077 mins elapsed. ## 2025-02-06 02:49:08.691367 : Adding Bulk Tracks (3 of 9), 0.09 mins elapsed. ## 2025-02-06 02:49:10.577964 : Adding Feature Tracks (3 of 9), 0.121 mins elapsed. ## 2025-02-06 02:49:10.672172 : Adding Loop Tracks (3 of 9), 0.123 mins elapsed. ## 2025-02-06 02:49:11.061905 : Adding Gene Tracks (3 of 9), 0.129 mins elapsed. ## 2025-02-06 02:49:11.286861 : Plotting, 0.133 mins elapsed. ## 2025-02-06 02:49:12.250556 : Adding Bulk Tracks (4 of 9), 0.149 mins elapsed. ## 2025-02-06 02:49:14.237169 : Adding Feature Tracks (4 of 9), 0.182 mins elapsed. ## 2025-02-06 02:49:14.323251 : Adding Loop Tracks (4 of 9), 0.184 mins elapsed. ## 2025-02-06 02:49:14.475799 : Adding Gene Tracks (4 of 9), 0.186 mins elapsed. ## 2025-02-06 02:49:14.680334 : Plotting, 0.19 mins elapsed. ## 2025-02-06 02:49:15.566444 : Adding Bulk Tracks (5 of 9), 0.205 mins elapsed. ## 2025-02-06 02:49:17.509581 : Adding Feature Tracks (5 of 9), 0.237 mins elapsed. ## 2025-02-06 02:49:17.60025 : Adding Loop Tracks (5 of 9), 0.238 mins elapsed. ## 2025-02-06 02:49:17.803788 : Adding Gene Tracks (5 of 9), 0.242 mins elapsed. ## 2025-02-06 02:49:18.010258 : Plotting, 0.245 mins elapsed. ## 2025-02-06 02:49:19.063965 : Adding Bulk Tracks (6 of 9), 0.263 mins elapsed. ## 2025-02-06 02:49:21.100406 : Adding Feature Tracks (6 of 9), 0.297 mins elapsed. ## 2025-02-06 02:49:21.186736 : Adding Loop Tracks (6 of 9), 0.298 mins elapsed. ## 2025-02-06 02:49:21.669676 : Adding Gene Tracks (6 of 9), 0.306 mins elapsed. ## 2025-02-06 02:49:21.871229 : Plotting, 0.31 mins elapsed. ## 2025-02-06 02:49:22.830714 : Adding Bulk Tracks (7 of 9), 0.326 mins elapsed. ## 2025-02-06 02:49:24.83812 : Adding Feature Tracks (7 of 9), 0.359 mins elapsed. ## 2025-02-06 02:49:24.927555 : Adding Loop Tracks (7 of 9), 0.361 mins elapsed. ## 2025-02-06 02:49:25.172896 : Adding Gene Tracks (7 of 9), 0.365 mins elapsed. ## 2025-02-06 02:49:25.38227 : Plotting, 0.368 mins elapsed. ## 2025-02-06 02:49:26.249319 : Adding Bulk Tracks (8 of 9), 0.383 mins elapsed. ## 2025-02-06 02:49:28.328631 : Adding Feature Tracks (8 of 9), 0.417 mins elapsed. ## 2025-02-06 02:49:28.411748 : Adding Loop Tracks (8 of 9), 0.419 mins elapsed. ## 2025-02-06 02:49:28.699722 : Adding Gene Tracks (8 of 9), 0.423 mins elapsed. ## 2025-02-06 02:49:28.925004 : Plotting, 0.427 mins elapsed. ## 2025-02-06 02:49:29.956741 : Adding Bulk Tracks (9 of 9), 0.444 mins elapsed. ## 2025-02-06 02:49:30.079082 : Adding Feature Tracks (9 of 9), 0.446 mins elapsed. ## 2025-02-06 02:49:30.16675 : Adding Loop Tracks (9 of 9), 0.448 mins elapsed. ## 2025-02-06 02:49:30.375868 : Adding Gene Tracks (9 of 9), 0.451 mins elapsed. ## 2025-02-06 02:49:30.583511 : Plotting, 0.455 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-plotBrowserTrack-925b468a1-Date-2025-02-06_Time-02-49-03.297189.log To plot our browser track we use the grid.draw function and select a specific marker gene by name using the $ accessor. grid::grid.newpage() grid::grid.draw(p$CD14) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes-with-Peak2GeneLinks.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL ## Plotting Gtable! ## NULL 17.3.2 Plotting a heatmap of peak-to-gene links To visualize the correspondence of all of our peak-to-gene links, we can plot a peak-to-gene heatmap which contains two side-by-side heatmaps, one for our scATAC-seq data and one for our scRNA-seq data. To do this, we use the plotPeak2GeneHeatmap() p &lt;- plotPeak2GeneHeatmap(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotPeak2GeneHeatmap-97c367426-Date-2025-02-06_Time-02-49-36.1348.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:49:51.026259 : Determining KNN Groups!, 0.248 mins elapsed. ## 2025-02-06 02:49:53.315845 : Ordering Peak2Gene Links!, 0.286 mins elapsed. ## 2025-02-06 02:49:59.295731 : Constructing ATAC Heatmap!, 0.386 mins elapsed. ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## 2025-02-06 02:49:59.713415 : Constructing RNA Heatmap!, 0.393 mins elapsed. ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotPeak2GeneHeatmap-97c367426-Date-2025-02-06_Time-02-49-36.1348.log The heatmap rows are clustered using k-means clustering based on the value passed to the parameter k, which defaults to 25 as shown below. p "],["identification-of-positive-tf-regulators.html", "17.4 Identification of Positive TF-Regulators", " 17.4 Identification of Positive TF-Regulators ATAC-seq allows for the unbiased identification of TFs that exhibit large changes in chromatin accessibility at sites containing their DNA binding motifs. However, families of TFs (for ex. GATA factors) share similar features in their binding motifs when looking in aggregate through position weight matrices (PWMs). This motif similarity makes it challenging to identify the specific TFs that might be driving observed changes in chromatin accessibility at their predicted binding sites. To circumvent this challenge, we have previously ATAC-seq and RNA-seq to identify TFs whose gene expression is positively correlated to changes in the accessibility of their corresponding motif. We term these TFs “positive regulators”. However, this analysis relies on matched gene expression data which may not be readily available in all experiments. To overcome this dependency, ArchR can identify TFs whose inferred gene scores are correlated to their chromVAR TF deviation z-scores. To achieve this, ArchR correlates chromVAR deviation z-scores of TF motifs with gene activity scores of TF genes from the low-overlapping cell aggregates. When using scRNA-seq integration with ArchR, gene expression of the TF can be used instead of inferred gene activity score. 17.4.1 Step 1. Identify Deviant TF Motifs The first part of identifying positive TF regulators is identification of deviant TF motifs. We performed this analysis in a previous chapter, creating a MotifMatrix of chromVAR deviations and deviation z-scores for all motifs. We can obtain this data, aggregated by clusters, by using the getGroupSE() function which returns a SummarizedExperiment. seGroupMotif &lt;- getGroupSE(ArchRProj = projHeme5, useMatrix = &quot;MotifMatrix&quot;, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-getGroupSE-96731eb81-Date-2025-02-06_Time-02-50-47.82255.log ## If there is an issue, please report to github with logFile! ## Getting Group Matrix ## 2025-02-06 02:50:57.12495 : Successfully Created Group Matrix, 0.142 mins elapsed. ## Normalizing by number of Cells ## ArchR logging successful to : ArchRLogs/ArchR-getGroupSE-96731eb81-Date-2025-02-06_Time-02-50-47.82255.log Because this SummarizedExperiment object comes from the MotifMatrix is has two seqnames - “deviations” and “z” - corresponding to the raw deviations and deviation z-scores from chromVAR. seGroupMotif ## class: SummarizedExperiment ## dim: 1740 11 ## metadata(0): ## assays(1): MotifMatrix ## rownames(1740): f1 f2 ... f1739 f1740 ## rowData names(3): seqnames idx name ## colnames(11): B CD4.M ... PreB Progenitor ## colData names(22): TSSEnrichment ReadsInTSS ... FRIP nCells We can subset this SummarizedExperiment to just the deviation z-scores. seZ &lt;- seGroupMotif[rowData(seGroupMotif)$seqnames==&quot;z&quot;,] Then we can identify the maximum delta in z-score between all clusters. This will be helpful in stratifying motifs based on the degree of variation observed across clusters. rowData(seZ)$maxDelta &lt;- lapply(seq_len(ncol(seZ)), function(x){ rowMaxs(assay(seZ) - assay(seZ)[,x]) }) %&gt;% Reduce(&quot;cbind&quot;, .) %&gt;% rowMaxs 17.4.2 Step 2. Identify Correlated TF Motifs and TF Gene Score/Expression To identify TFs whose motif accessibility is correlated with with their own gene activity (either by gene score or gene expression), we use the correlateMatrices() function and provide the two matrices that we are interested in, in this case the GeneScoreMatrix and the MotifMatrix. As mentioned previously, these correlations are determined across many low-overlapping cell aggregates determined in the lower dimension space specified in the reducedDims parameter. corGSM_MM &lt;- correlateMatrices( ArchRProj = projHeme5, useMatrix1 = &quot;GeneScoreMatrix&quot;, useMatrix2 = &quot;MotifMatrix&quot;, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-correlateMatrices-92032f4ff-Date-2025-02-06_Time-02-51-00.764345.log ## If there is an issue, please report to github with logFile! ## When accessing features from a matrix of class Sparse.Assays.Matrix it requires 1 seqname! ## Continuing with first seqname &#39;z&#39;! ## If confused, try getFeatures(ArchRProj, &#39;MotifMatrix&#39;) to list out available seqnames for input! ## 2025-02-06 02:51:04.64868 : Testing 825 Mappings!, 0.065 mins elapsed. ## 2025-02-06 02:51:04.663012 : Computing KNN, 0.065 mins elapsed. ## 2025-02-06 02:51:04.758644 : Identifying Non-Overlapping KNN pairs, 0.067 mins elapsed. ## 2025-02-06 02:51:06.35323 : Identified 493 Groupings!, 0.093 mins elapsed. ## 2025-02-06 02:51:13.990886 : Getting Group Matrix 1, 0.22 mins elapsed. ## 2025-02-06 02:51:40.987875 : Getting Group Matrix 2, 0.67 mins elapsed. ## Some entries in groupMat2 are less than 0, continuing without Log2 Normalization. ## Most likely this assay is a deviations matrix. ## Getting Correlations... ## 2025-02-06 02:51:50.001299 : ## Computing Correlation (250 of 825) ## Computing Correlation (500 of 825) ## Computing Correlation (750 of 825) ## ArchR logging successful to : ArchRLogs/ArchR-correlateMatrices-92032f4ff-Date-2025-02-06_Time-02-51-00.764345.log This function returns a DataFrame object that that contains the elements from each matrix and the correlation across the low-overlapping cell aggregates. corGSM_MM ## DataFrame with 825 rows and 14 columns ## GeneScoreMatrix_name MotifMatrix_name cor padj pval ## &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 HES4 HES4_95 0.0812056 1.00000e+00 7.16311e-02 ## 2 HES5 HES5_98 0.2129707 1.49532e-03 1.82802e-06 ## 3 PRDM16 PRDM16_211 0.4914614 1.99061e-28 2.43351e-31 ## 4 TP73 TP73_705 0.4816650 4.35853e-27 5.32828e-30 ## 5 TP73-AS1 TP73_705 -0.1021500 1.00000e+00 2.33123e-02 ## ... ... ... ... ... ... ## 821 TFDP3 TFDP3_309 -0.0872218 1 0.0529399 ## 822 ZNF75D ZNF75D_272 -0.0176484 1 0.6958763 ## 823 ZIC3 ZIC3_215 0.0182329 1 0.6863296 ## 824 SOX3 SOX3_759 0.0438860 1 0.3308404 ## 825 MECP2 MECP2_645 0.0558356 1 0.2158754 ## GeneScoreMatrix_seqnames GeneScoreMatrix_start GeneScoreMatrix_end ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## 1 chr1 935552 934342 ## 2 chr1 2461684 2460184 ## 3 chr1 2985742 3355185 ## 4 chr1 3569129 3652765 ## 5 chr1 3663937 3652548 ## ... ... ... ... ## 821 chrX 132352376 132350697 ## 822 chrX 134429965 134419723 ## 823 chrX 136648346 136654259 ## 824 chrX 139587225 139585152 ## 825 chrX 153363188 153287264 ## GeneScoreMatrix_strand GeneScoreMatrix_idx GeneScoreMatrix_matchName ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; ## 1 2 15 HES4 ## 2 2 74 HES5 ## 3 1 82 PRDM16 ## 4 1 89 TP73 ## 5 2 90 TP73 ## ... ... ... ... ## 821 2 697 TFDP3 ## 822 2 728 ZNF75D ## 823 1 753 ZIC3 ## 824 2 765 SOX3 ## 825 2 874 MECP2 ## MotifMatrix_seqnames MotifMatrix_idx MotifMatrix_matchName ## &lt;character&gt; &lt;integer&gt; &lt;character&gt; ## 1 z 95 HES4 ## 2 z 98 HES5 ## 3 z 211 PRDM16 ## 4 z 705 TP73 ## 5 z 705 TP73 ## ... ... ... ... ## 821 z 309 TFDP3 ## 822 z 272 ZNF75D ## 823 z 215 ZIC3 ## 824 z 759 SOX3 ## 825 z 645 MECP2 We can perform the same analysis using the GeneIntegrationMatrix instead of the GeneScoreMatrix. corGIM_MM &lt;- correlateMatrices( ArchRProj = projHeme5, useMatrix1 = &quot;GeneIntegrationMatrix&quot;, useMatrix2 = &quot;MotifMatrix&quot;, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-correlateMatrices-9666305e6-Date-2025-02-06_Time-02-51-50.211162.log ## If there is an issue, please report to github with logFile! ## When accessing features from a matrix of class Sparse.Assays.Matrix it requires 1 seqname! ## Continuing with first seqname &#39;z&#39;! ## If confused, try getFeatures(ArchRProj, &#39;MotifMatrix&#39;) to list out available seqnames for input! ## 2025-02-06 02:51:54.353546 : Testing 798 Mappings!, 0.069 mins elapsed. ## 2025-02-06 02:51:54.369524 : Computing KNN, 0.069 mins elapsed. ## 2025-02-06 02:51:54.466238 : Identifying Non-Overlapping KNN pairs, 0.071 mins elapsed. ## 2025-02-06 02:51:56.175334 : Identified 493 Groupings!, 0.099 mins elapsed. ## 2025-02-06 02:52:03.934808 : Getting Group Matrix 1, 0.229 mins elapsed. ## 2025-02-06 02:52:33.736136 : Getting Group Matrix 2, 0.725 mins elapsed. ## Some entries in groupMat2 are less than 0, continuing without Log2 Normalization. ## Most likely this assay is a deviations matrix. ## Getting Correlations... ## 2025-02-06 02:52:44.165835 : ## Computing Correlation (250 of 798) ## Computing Correlation (500 of 798) ## Computing Correlation (750 of 798) ## ArchR logging successful to : ArchRLogs/ArchR-correlateMatrices-9666305e6-Date-2025-02-06_Time-02-51-50.211162.log corGIM_MM ## DataFrame with 798 rows and 14 columns ## GeneIntegrationMatrix_name MotifMatrix_name cor padj ## &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 HES4 HES4_95 -0.409869 1.24354e-18 ## 2 HES5 HES5_98 -0.396790 2.83101e-17 ## 3 PRDM16 PRDM16_211 0.145180 7.12995e-01 ## 4 TP73 TP73_705 -0.218060 5.90733e-04 ## 5 HES2 HES2_19 -0.145874 6.74992e-01 ## ... ... ... ... ... ## 794 TFDP3 TFDP3_309 NA NA ## 795 ZNF75D ZNF75D_272 0.289988 3.04327e-08 ## 796 ZIC3 ZIC3_215 NA NA ## 797 SOX3 SOX3_759 NA NA ## 798 MECP2 MECP2_645 0.645679 9.96934e-57 ## pval GeneIntegrationMatrix_seqnames GeneIntegrationMatrix_start ## &lt;numeric&gt; &lt;character&gt; &lt;integer&gt; ## 1 2.14035e-21 chr1 935552 ## 2 4.87266e-20 chr1 2461684 ## 3 1.22719e-03 chr1 2985742 ## 4 1.01675e-06 chr1 3569129 ## 5 1.16178e-03 chr1 6484730 ## ... ... ... ... ## 794 NA chrX 132352376 ## 795 5.23798e-11 chrX 134429965 ## 796 NA chrX 136648346 ## 797 NA chrX 139587225 ## 798 1.71589e-59 chrX 153363188 ## GeneIntegrationMatrix_end GeneIntegrationMatrix_strand ## &lt;integer&gt; &lt;integer&gt; ## 1 934342 2 ## 2 2460184 2 ## 3 3355185 1 ## 4 3652765 1 ## 5 6472498 2 ## ... ... ... ## 794 132350697 2 ## 795 134419723 2 ## 796 136654259 1 ## 797 139585152 2 ## 798 153287264 2 ## GeneIntegrationMatrix_idx GeneIntegrationMatrix_matchName ## &lt;integer&gt; &lt;character&gt; ## 1 8 HES4 ## 2 53 HES5 ## 3 59 PRDM16 ## 4 64 TP73 ## 5 81 HES2 ## ... ... ... ## 794 562 TFDP3 ## 795 576 ZNF75D ## 796 595 ZIC3 ## 797 602 SOX3 ## 798 680 MECP2 ## MotifMatrix_seqnames MotifMatrix_idx MotifMatrix_matchName ## &lt;character&gt; &lt;integer&gt; &lt;character&gt; ## 1 z 95 HES4 ## 2 z 98 HES5 ## 3 z 211 PRDM16 ## 4 z 705 TP73 ## 5 z 19 HES2 ## ... ... ... ... ## 794 z 309 TFDP3 ## 795 z 272 ZNF75D ## 796 z 215 ZIC3 ## 797 z 759 SOX3 ## 798 z 645 MECP2 Step 3. Add Maximum Delta Deviation to the Correlation Data Frame For each of these correlation analyses, we can annotate each motif with the maximum delta observed between clusters which we calculated in Step 1. corGSM_MM$maxDelta &lt;- rowData(seZ)[match(corGSM_MM$MotifMatrix_name, rowData(seZ)$name), &quot;maxDelta&quot;] corGIM_MM$maxDelta &lt;- rowData(seZ)[match(corGIM_MM$MotifMatrix_name, rowData(seZ)$name), &quot;maxDelta&quot;] Step 4. Identify Positive TF Regulators We can use all of this information to identify positive TF regulators. In the examples below, we consider positive regulators as those TFs whose correlation between motif and gene score (or gene expression) is greater than 0.5 with an adjusted p-value less than 0.01 and a maximum inter-cluster difference in deviation z-score that is in the top quartile. We apply these selection criteria and do a little text juggling to isolate the TF names. corGSM_MM &lt;- corGSM_MM[order(abs(corGSM_MM$cor), decreasing = TRUE), ] corGSM_MM &lt;- corGSM_MM[which(!duplicated(gsub(&quot;\\\\-.*&quot;,&quot;&quot;,corGSM_MM[,&quot;MotifMatrix_name&quot;]))), ] corGSM_MM$TFRegulator &lt;- &quot;NO&quot; corGSM_MM$TFRegulator[which(corGSM_MM$cor &gt; 0.5 &amp; corGSM_MM$padj &lt; 0.01 &amp; corGSM_MM$maxDelta &gt; quantile(corGSM_MM$maxDelta, 0.75))] &lt;- &quot;YES&quot; sort(corGSM_MM[corGSM_MM$TFRegulator==&quot;YES&quot;,1]) ## [1] &quot;ASCL1&quot; &quot;BCL11A&quot; &quot;CEBPA-DT&quot; &quot;CEBPB&quot; &quot;CEBPD&quot; &quot;EBF1&quot; ## [7] &quot;EGR1&quot; &quot;EGR2&quot; &quot;EGR4&quot; &quot;EOMES&quot; &quot;ERF&quot; &quot;ETS1&quot; ## [13] &quot;ETV6&quot; &quot;FUBP1&quot; &quot;GATA1&quot; &quot;GATA2&quot; &quot;GATA5&quot; &quot;ID3&quot; ## [19] &quot;IRF2&quot; &quot;JDP2&quot; &quot;KLF11&quot; &quot;LEF1&quot; &quot;MECOM&quot; &quot;MEF2A&quot; ## [25] &quot;MITF&quot; &quot;NFE2&quot; &quot;NFIA&quot; &quot;NFIC&quot; &quot;NFIL3&quot; &quot;NFIX&quot; ## [31] &quot;NFKB2&quot; &quot;PAX5&quot; &quot;POU2F1&quot; &quot;POU2F2&quot; &quot;REL&quot; &quot;SMAD1&quot; ## [37] &quot;SP4&quot; &quot;SPI1&quot; &quot;SPIB&quot; &quot;TAL1&quot; &quot;TCF15&quot; &quot;TFAP2C&quot; ## [43] &quot;YY1&quot; &quot;ZEB1-AS1&quot; Having identified these positive TF regulators from gene scores and motif deviation z-scores, we can highlight them in a dot plot. p &lt;- ggplot(data.frame(corGSM_MM), aes(cor, maxDelta, color = TFRegulator)) + geom_point() + theme_ArchR() + geom_vline(xintercept = 0, lty = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;NO&quot;=&quot;darkgrey&quot;, &quot;YES&quot;=&quot;firebrick3&quot;)) + xlab(&quot;Correlation To Gene Score&quot;) + ylab(&quot;Max TF Motif Delta&quot;) + scale_y_continuous( expand = c(0,0), limits = c(0, max(corGSM_MM$maxDelta)*1.05) ) p ## Warning: Removed 7 rows containing missing values or values outside the scale ## range (`geom_point()`). We can perform the same analysis for the correlations derived from our GeneIntegrationMatrix. corGIM_MM &lt;- corGIM_MM[order(abs(corGIM_MM$cor), decreasing = TRUE), ] corGIM_MM &lt;- corGIM_MM[which(!duplicated(gsub(&quot;\\\\-.*&quot;,&quot;&quot;,corGIM_MM[,&quot;MotifMatrix_name&quot;]))), ] corGIM_MM$TFRegulator &lt;- &quot;NO&quot; corGIM_MM$TFRegulator[which(corGIM_MM$cor &gt; 0.5 &amp; corGIM_MM$padj &lt; 0.01 &amp; corGIM_MM$maxDelta &gt; quantile(corGIM_MM$maxDelta, 0.75))] &lt;- &quot;YES&quot; sort(corGIM_MM[corGIM_MM$TFRegulator==&quot;YES&quot;,1]) ## [1] &quot;ATF4&quot; &quot;BACH1&quot; &quot;CEBPA&quot; &quot;CEBPB&quot; &quot;CEBPD&quot; &quot;CEBPG&quot; &quot;CTCF&quot; &quot;EBF1&quot; &quot;EOMES&quot; ## [10] &quot;ESRRA&quot; &quot;ETS1&quot; &quot;FOS&quot; &quot;FOSB&quot; &quot;FOSL1&quot; &quot;FOSL2&quot; &quot;GATA1&quot; &quot;GATA2&quot; &quot;ID3&quot; ## [19] &quot;IRF3&quot; &quot;IRF9&quot; &quot;JDP2&quot; &quot;KLF2&quot; &quot;LEF1&quot; &quot;MEF2A&quot; &quot;MEF2C&quot; &quot;MITF&quot; &quot;NFE2&quot; ## [28] &quot;NFIA&quot; &quot;NFIB&quot; &quot;NFIC&quot; &quot;NFIL3&quot; &quot;NFIX&quot; &quot;NFKB2&quot; &quot;NR4A1&quot; &quot;NRF1&quot; &quot;PAX5&quot; ## [37] &quot;RELB&quot; &quot;RFX3&quot; &quot;RUNX1&quot; &quot;SMAD1&quot; &quot;SPI1&quot; &quot;STAT2&quot; &quot;TCF12&quot; &quot;TCF3&quot; &quot;TCF4&quot; p &lt;- ggplot(data.frame(corGIM_MM), aes(cor, maxDelta, color = TFRegulator)) + geom_point() + theme_ArchR() + geom_vline(xintercept = 0, lty = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;NO&quot;=&quot;darkgrey&quot;, &quot;YES&quot;=&quot;firebrick3&quot;)) + xlab(&quot;Correlation To Gene Expression&quot;) + ylab(&quot;Max TF Motif Delta&quot;) + scale_y_continuous( expand = c(0,0), limits = c(0, max(corGIM_MM$maxDelta)*1.05) ) p ## Warning: Removed 204 rows containing missing values or values outside the scale ## range (`geom_point()`). "],["trajectory-analysis-with-archr.html", "Chapter 18 Trajectory Analysis with ArchR", " Chapter 18 Trajectory Analysis with ArchR To order cells in pseudo-time, ArchR creates cellular trajectories that order cells across a lower N-dimensional subspace within an ArchRProject. Previously, we have performed this ordering in the 2-dimensional UMAP subspace but ArchR has improved upon this methodology to enable alignment within an N-dimensional subspace (i.e. LSI). First, ArchR requires a user-defined trajectory backbone that provides a rough ordering of cell groups/clusters. For example, given user-determined cluster identities, one might provide the cluster IDs for a stem cell cluster, then a progenitor cell cluster, and then a differentiated cell cluster that correspond to a known or presumed biologically relevant cellular trajectory (i.e. providing the cluster IDs for HSC, to GMP, to Monocyte). Next, for each cluster, ArchR calculates the mean coordinates for each cell group/cluster in N-dimensions and retains cells whose Euclidean distance to those mean coordinates is in the top 5% of all cells. Next, ArchR computes the distance for each cell from cluster i to the mean coordinates of cluster i+1 along the trajectory and computes a pseudo-time vector based on these distances for each iteration of i. This allows ArchR to determine an N-dimensional coordinate and a pseudo-time value for each of the cells retained as part of the trajectory based on the Euclidean distance to the cell group/cluster mean coordinates. Next, ArchR fits a continuous trajectory to each N-dimensional coordinate based on the pseudo-time value using the smooth.spline function. Then, ArchR aligns all cells to the trajectory based on their Euclidean distance to the nearest point along the manifold. ArchR then scales this alignment to 100 and stores this pseudo-time in the ArchRProject for downstream analyses. ArchR can create matrices that convey pseudo-time trends across features stored within the Arrow files. For example, ArchR can analyze changes in TF deviations, gene scores, or integrated gene expression across pseudo-time to identify regulators or regulatory elements that are dynamic throughout the cellular trajectory. First, ArchR groups cells in small user-defined quantile increments (default = 1/100) across the cellular trajectory. ArchR then smooths this matrix per feature using a user-defined smoothing window (default = 9/100) using the data.table::frollmean function. ArchR then returns this smoothed pseudo-time x feature matrix as a SummarizedExperiment for downstream analyses. ArchR additionally can correlate two of these smoothed pseudo-time x feature matrices using name matching (i.e. positive regulators with chromVAR TF deviations and gene score/integration profiles) or by genomic position overlap methods (i.e. peak-to-gene linkages) using low-overlapping cellular aggregates as described in previous sections. Thus, ArchR facilitates integrative analyses across cellular trajectories, revealing correlated regulatory dynamics across multi-modal data. "],["myeloid-trajectory---monocyte-differentiation.html", "18.1 Myeloid Trajectory - Monocyte Differentiation", " 18.1 Myeloid Trajectory - Monocyte Differentiation In this section, we will create a cellular trajectory that approximates the differentiation of HSCs into fully differentiated monocytes. To start, lets review the clusters and cell types that we defined previously, stored in cellColData in columns named “Clusters” and “Clusters2”. Overlaying these cell groupings on our UMAP embedding shows the different cell types that we are interested in. p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-984ab0ef-Date-2025-02-06_Time-02-54-41.875871.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-984ab0ef-Date-2025-02-06_Time-02-54-41.875871.log p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-921c166a-Date-2025-02-06_Time-02-54-43.685416.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-921c166a-Date-2025-02-06_Time-02-54-43.685416.log ggAlignPlots(p1, p2, type = &quot;h&quot;) 18.1.1 Pseudo-time UMAPs and individual feature plots We will use the cell type definitions that are stored in “Clusters2”. As mentioned above, we are creating a trajectory from stem cells (“Progenitor”), through the committed myeloid progenitor (“GMP”), to monocytes (“Mono”). The first step in creating a trajectory is to create a trajectory backbone in the form of an ordered vector of cell group labels. trajectory &lt;- c(&quot;Progenitor&quot;, &quot;GMP&quot;, &quot;Mono&quot;) trajectory ## [1] &quot;Progenitor&quot; &quot;GMP&quot; &quot;Mono&quot; We use the addTrajectory() function to create a trajectory and we add this to our ArchRProject. We will call this trajectory “MyeloidU”. What this does is it creates a new column in cellColData called “MyeloidU” that stores the pseudo-time value for each cell in the trajectory. Cells that are not part of the trajectory are labeled with NA. projHeme5 &lt;- addTrajectory( ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, groupBy = &quot;Clusters2&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE ) ## ArchR logging to : ArchRLogs/ArchR-addTrajectory-94bdae59a-Date-2025-02-06_Time-02-54-47.419022.log ## If there is an issue, please report to github with logFile! ## Filtering outliers ## Initial Alignment Before Spline Fit ## Spline Fit ## KNN to Spline ## ArchR logging successful to : ArchRLogs/ArchR-addTrajectory-94bdae59a-Date-2025-02-06_Time-02-54-47.419022.log We can look at this information and see that each cell has a unique pseudotime value between 0 and 100. We exclude cells with NA values because these are not part of the trajectory. head(projHeme5$MyeloidU[!is.na(projHeme5$MyeloidU)]) ## [1] 45.78870 50.93468 53.30813 45.51565 45.09557 47.88910 To plot this trajectory, we use the plotTrajectory() function which overlays the pseudo-time values on our UMAP embedding and displays an arrow approximating the trajectory path from the spline-fit. Cells that are not part of the trajectory are colored gray. In this example, we use colorBy = \"cellColData\" to tell ArchR to look within cellColData for the column specified by name - in this case, the “MyeloidU” pseudo-time trajectory. While it may seem conterintuitive to list “MyeloidU” for both trajectory and name, this is done because trajectory tells ArchR which subset of cells we are interested in and name tells ArchR how to color that subset of cells. p &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;cellColData&quot;, name = &quot;MyeloidU&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-92d43611b-Date-2025-02-06_Time-02-54-47.975397.log ## If there is an issue, please report to github with logFile! ## Plotting ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-92d43611b-Date-2025-02-06_Time-02-54-47.975397.log p[[1]] ## Warning: Removed 5489 rows containing non-finite outside the scale range ## (`stat_summary_hex()`). To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p, name = &quot;Plot-MyeloidU-Traj-UMAP.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## Plotting Ggplot! ## Plotting Ggplot! ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; We can also overlay other features on the trajectory within our UMAP embedding. This allows us to display specific features only within the cells that are relevant to our trajectory. If you have not already added impute weights to your projHeme5 project, lets do that now. projHeme5 &lt;- addImputeWeights(projHeme5) ## ArchR logging to : ArchRLogs/ArchR-addImputeWeights-934b34ab-Date-2025-02-06_Time-02-54-58.162486.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 02:54:58.563546 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. Then, we can plot the “MyeloidU” trajectory but color the cells by the gene score value of the CEBPB gene, a known regulator of monocyte function that becomes active during the differentiation process. We indicate the matrix to use via the colorBy parameter and the feature to use via the name parameter. p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;horizonExtra&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-9967556a-Date-2025-02-06_Time-02-55-10.09262.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values... ## 2025-02-06 02:55:11.779708 : ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-9967556a-Date-2025-02-06_Time-02-55-10.09262.log We can repeat this process but color the cells by their linked gene expression via the GeneIntegrationMatrix. p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;blueYellow&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-9337c3eba-Date-2025-02-06_Time-02-55-20.549369.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values... ## 2025-02-06 02:55:22.292649 : ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-9337c3eba-Date-2025-02-06_Time-02-55-20.549369.log The plotTrajectory() function actually returns a list of relevant plots. The first plot in the list is a UMAP embedding, colorized as specified in the function call. Comparing these UMAP plots side-by-side for the gene score and gene expression, we see that the activity of the CEBPB gene is highly specific to monocyte cells in the later part of the pseudo-time trajectory. ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ## Warning: Removed 5489 rows containing non-finite outside the scale range (`stat_summary_hex()`). ## Removed 5489 rows containing non-finite outside the scale range (`stat_summary_hex()`). The second plot in the list that is returned by plotTrajectory() is a dot plot of pseudo-time versus the value of the relevant feature, in this case, the gene score or gene expression of CEBPB. In this case, the cells are colored by their pseudo-time. ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 18.1.2 Pseudo-time heatmaps We can visualize changes in many features across pseudo-time using heatmaps. To do this, we first retrieve the trajectory of interest from the ArchRProject using the getTrajectory() function which returns the trajectory as a SummarizedExperiment object. We will create these pseudo-time heatmaps for motifs, gene scores, gene expression, and peak accessibility by passing the corresponding matrix to the useMatrix parameter. When calling getTrajectory() we can provide as argument to the trajectoryLabel parameter which allows for labeling of the heatmap pseudo-time bins based on the group (eg. stem cell, progenitor cell, differentiated cell). Typically, the value passed to trajectoryLabel should be the same as the column in cellColData used in the groupBy parameter when addTrajectory() was called. trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE, trajectoryLabel = &quot;Clusters2&quot;) ## Creating Trajectory Group Matrix.. ## Some values are below 0, this could be a DeviationsMatrix in which scaleTo should be set = NULL. ## Continuing without depth normalization! ## Smoothing... ## Attempting to add labels to the trajectory based on the trajectoryLabel parameter. trajMM ## class: SummarizedExperiment ## dim: 1740 100 ## metadata(1): Params ## assays(2): smoothMat mat ## rownames(1740): deviations:TFAP2B_1 deviations:TFAP2D_2 ... z:TBX18_869 ## z:TBX22_870 ## rowData names(3): seqnames idx name ## colnames(100): T.0_1 T.1_2 ... T.98_99 T.99_100 ## colData names(1): label getTrajectory() returns a Summarized Experiment where the rows are the features of interest and the columns are pseudo-time bins. The size of the pseudo-time bins can be controlled by the groupEvery parameter. We then pass this SummarizedExperiment to the plotTrajectoryHeatmap() function. To include a color label across the top of the heatmap that represents the groups of the pseudo-time bins, we additionally use the colorColumns and columnPal arguments. p1 &lt;- plotTrajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;), colorColumns = TRUE, columnPal = paletteDiscrete(values = unique(colData(trajMM)$label))) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9380caa4f-Date-2025-02-06_Time-02-55-50.116091.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2025-02-06 02:55:50.519287 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2025-02-06 02:55:50.524774 : ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9380caa4f-Date-2025-02-06_Time-02-55-50.116091.log p1 We can perform the same steps to obtain a pseudo-time heatmap of gene scores by setting useMatrix = \"GeneScoreMatrix\". trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE, trajectoryLabel = &quot;Clusters2&quot;) ## Creating Trajectory Group Matrix.. ## Smoothing... ## Attempting to add labels to the trajectory based on the trajectoryLabel parameter. p2 &lt;- plotTrajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;), colorColumns = TRUE, columnPal = paletteDiscrete(values = unique(colData(trajGSM)$label))) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-95eb8075e-Date-2025-02-06_Time-02-56-23.743509.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-95eb8075e-Date-2025-02-06_Time-02-56-23.743509.log p2 Similarly, we can obtain a pseudo-time heatmap of gene expression by setting useMatrix = \"GeneIntegrationMatrix\". trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE, trajectoryLabel = &quot;Clusters2&quot;) ## Creating Trajectory Group Matrix.. ## Smoothing... ## Attempting to add labels to the trajectory based on the trajectoryLabel parameter. p3 &lt;- plotTrajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;), colorColumns = TRUE, columnPal = paletteDiscrete(values = unique(colData(trajGIM)$label))) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94db2dc5b-Date-2025-02-06_Time-02-56-56.228106.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94db2dc5b-Date-2025-02-06_Time-02-56-56.228106.log p3 Lastly, we can obtain a pseudo-time heatmap of peak accessibility by setting useMatrix = \"PeakMatrix\". trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE, trajectoryLabel = &quot;Clusters2&quot;) ## Creating Trajectory Group Matrix.. ## Smoothing... ## Attempting to add labels to the trajectory based on the trajectoryLabel parameter. p4 &lt;- plotTrajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;), colorColumns = TRUE, columnPal = paletteDiscrete(values = unique(colData(trajPM)$label))) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-95ad4cb2b-Date-2025-02-06_Time-02-57-30.077996.log ## If there is an issue, please report to github with logFile! ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-95ad4cb2b-Date-2025-02-06_Time-02-57-30.077996.log p4 To save an editable vectorized version of these plots, we use plotPDF(). plotPDF(p1, p2, p3, p4, name = &quot;Plot-MyeloidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) ## Plotting ComplexHeatmap! ## Plotting ComplexHeatmap! ## Plotting ComplexHeatmap! ## Plotting ComplexHeatmap! 18.1.3 Integrative pseudo-time analyses We can also perform integrative analyses, such as identification of positive TF regulators by integration of gene scores / gene expression with motif accessibility across pseudo-time. This can be very powerful, for example in identifying drivers of differentiation. To do this, we use the correlateTrajectories() function which takes two SummarizedExperiment objects retrived from the getTrajectories() function. First, lets find motifs whose accessibility across pseudo-time is correlated with the gene score of the TF gene. Since we are ultimately going to only correlate with the deviation z-scores, we filter out any entries that correlate based on raw deviations. corGSM_MM &lt;- correlateTrajectories(trajGSM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-966a54b87-Date-2025-02-06_Time-02-57-44.208525.log ## If there is an issue, please report to github with logFile! ## Found 37 Correlated Pairings! ## 2025-02-06 02:58:08.928024 : idxToRemove &lt;- grep(pattern = &quot;deviations&quot;, x = corGSM_MM[[&quot;correlatedMappings&quot;]]$name2) if(length(idxToRemove &gt; 1)){ corGSM_MM[[&quot;correlatedMappings&quot;]] &lt;- corGSM_MM[[&quot;correlatedMappings&quot;]][-idxToRemove,] } The primary output of correlateTrajectories() is a list object containing a DataFrame object as the first entry in the list. This DataFrame has columns named idx1, matchname1, name1, and VarAssay1 which correspond to the index, match name, unaltered name, and the variance quantile of the features from the first trajectory (gene scores) passed to the correlateTrajectories() function. A “variance quantile” is a normalized measure of the given feature which allows us to derive a correlation across disparate assays. This DataFrame contains all of the features that met the cutoffs specified in the correlateTrajectories() function. corGSM_MM[[&quot;correlatedMappings&quot;]] ## DataFrame with 36 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1 82 1081 PRDM16 PRDM16 chr1:PRDM16 z:PRDM16_211 ## 2 731 932 TAL1 TAL1 chr1:TAL1 z:TAL1_62 ## 3 818 1013 JUN JUN chr1:JUN z:JUN_143 ## 4 2034 1002 ATF3 ATF3 chr1:ATF3 z:ATF3_132 ## 5 2369 1254 GATA3 GATA3 chr10:GATA3 z:GATA3_384 ## ... ... ... ... ... ... ... ## 32 20780 1031 SNAI2 SNAI2 chr8:SNAI2 z:SNAI2_161 ## 33 21658 1003 NFIL3 NFIL3 chr9:NFIL3 z:NFIL3_133 ## 34 21753 1538 NR4A3 NR4A3 chr9:NR4A3 z:NR4A3_668 ## 35 21793 1078 KLF4 KLF4 chr9:KLF4 z:KLF4_208 ## 36 22097 1565 RXRA RXRA chr9:RXRA z:RXRA_695 ## Correlation VarAssay1 VarAssay2 TStat Pval FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.823885 0.999784 0.867816 14.39074 6.60993e-26 3.60461e-23 ## 2 0.767083 0.854153 0.988506 11.83658 1.33614e-20 1.36620e-18 ## 3 0.513806 0.993990 0.967816 5.92887 4.57253e-08 4.64637e-07 ## 4 0.745960 0.983310 0.909195 11.08817 5.35814e-19 4.17424e-17 ## 5 0.678372 0.849094 0.995402 9.14028 8.88548e-15 3.23140e-13 ## ... ... ... ... ... ... ... ## 32 0.618889 0.869503 0.960345 7.79994 6.76130e-12 1.40773e-10 ## 33 0.756083 0.993125 0.938506 11.43640 9.57196e-20 8.24196e-18 ## 34 0.575115 0.815454 0.943103 6.95946 3.89654e-10 5.95771e-09 ## 35 0.802777 0.998833 0.822414 13.32779 9.82524e-24 3.21482e-21 ## 36 0.605137 0.912224 0.922414 7.52468 2.58286e-11 4.54360e-10 We can then subset our corresponding trajectory SummarizedExperiment objects to only contain the elements that passed significance above. trajGSM2 &lt;- trajGSM[corGSM_MM[[&quot;correlatedMappings&quot;]]$name1, ] trajMM2 &lt;- trajMM[corGSM_MM[[&quot;correlatedMappings&quot;]]$name2, ] To best order these features, we can create a new trajectory where the values of these two trajectories are multiplied. This will allow us to create side-by-side heatmaps that are identically ordered by row. trajCombined &lt;- trajGSM2 assay(trajCombined, withDimnames=FALSE) &lt;- t(apply(assay(trajGSM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) We can extract the optimal row order from the return of the plotTrajectoryHeatmap() function. combinedMat &lt;- plotTrajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-941e866f0-Date-2025-02-06_Time-02-58-09.044356.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-941e866f0-Date-2025-02-06_Time-02-58-09.044356.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGSM2)) With this, we are now ready to create our paired heatmaps. First, we will create the heatmap for the gene score trajectory. We specify the desired row order via the rowOrder parameter. ht1 &lt;- plotTrajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-959bd00cc-Date-2025-02-06_Time-02-58-09.752344.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-959bd00cc-Date-2025-02-06_Time-02-58-09.752344.log Then, we will create the heatmap for the motif trajectory, again specifying the row order via the rowOrder parameter. Here, we’ve used force = TRUE. In the context of the MotifMatrix trajectory, this would allow correlations to both “z” and “deviations”. In this example, we’ve removed the raw deviations above but if we had not done this, force = TRUE would be essential here. ht2 &lt;- plotTrajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder, force = TRUE) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94c2fe2e3-Date-2025-02-06_Time-02-58-10.523033.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2025-02-06 02:58:10.923082 : ## force=TRUE thus continuing ## 2025-02-06 02:58:10.927511 : ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94c2fe2e3-Date-2025-02-06_Time-02-58-10.523033.log Plotting these two heatmaps side-by-side, we see that the rows are matched across the two heatmaps. You may notice that the analysis captures both GATA3 and GATA3-AS1 (an anti-sense transcript of GATA3). This is due to how feature matching is performed and the anti-sense transcript entry could be removed manually in post-processing or programatically if desired. ComplexHeatmap::draw(ht1 + ht2) We can repeat this same exact process but use gene expression from the GeneIntegrationMatrix instead of gene scores. Because this is the same analytical workflow, we do not repeat our explanations for each step. corGIM_MM &lt;- correlateTrajectories(trajGIM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-942520b2e-Date-2025-02-06_Time-02-58-12.160729.log ## If there is an issue, please report to github with logFile! ## Found 48 Correlated Pairings! ## 2025-02-06 02:58:31.057049 : idxToRemove2 &lt;- grep(pattern = &quot;deviations&quot;, x = corGIM_MM[[&quot;correlatedMappings&quot;]]$name2) if(length(idxToRemove2 &gt; 1)){ corGIM_MM[[&quot;correlatedMappings&quot;]] &lt;- corGIM_MM[[&quot;correlatedMappings&quot;]][-idxToRemove2,] } corGIM_MM[[1]] ## DataFrame with 47 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1 295 1601 RUNX3 RUNX3 chr1:RUNX3 z:RUNX3_731 ## 2 680 1612 NFIA NFIA chr1:NFIA z:NFIA_742 ## 3 1227 1512 MEF2D MEF2D chr1:MEF2D z:MEF2D_642 ## 4 1936 1254 GATA3 GATA3 chr10:GATA3 z:GATA3_384 ## 5 2036 1027 ZEB1 ZEB1 chr10:ZEB1 z:ZEB1_157 ## ... ... ... ... ... ... ... ## 43 15859 997 CREB5 CREB5 chr7:CREB5 z:CREB5_127 ## 44 16783 1022 CEBPD CEBPD chr8:CEBPD z:CEBPD_152 ## 45 17463 1003 NFIL3 NFIL3 chr9:NFIL3 z:NFIL3_133 ## 46 17560 1078 KLF4 KLF4 chr9:KLF4 z:KLF4_208 ## 47 17803 1565 RXRA RXRA chr9:RXRA z:RXRA_695 ## Correlation VarAssay1 VarAssay2 TStat Pval FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.859304 0.836944 0.990805 16.6320 2.71340e-30 6.94894e-29 ## 2 0.871016 0.843718 0.935057 17.5522 5.15150e-32 1.93181e-30 ## 3 0.786838 0.852642 0.897126 12.6212 2.92156e-22 2.86695e-21 ## 4 0.874051 0.811247 0.995402 17.8099 1.73053e-32 6.98866e-31 ## 5 0.869930 0.825439 0.906897 17.4621 7.55989e-32 2.48059e-30 ## ... ... ... ... ... ... ... ## 43 0.840645 0.938552 0.913218 15.3659 7.55559e-28 1.46914e-26 ## 44 0.844978 0.993871 0.998851 15.6411 2.18504e-28 4.41210e-27 ## 45 0.790844 0.920219 0.938506 12.7921 1.28056e-22 1.29288e-21 ## 46 0.822718 0.987904 0.822414 14.3276 8.86608e-26 1.29297e-24 ## 47 0.913108 0.952207 0.922414 22.1705 5.74331e-40 6.70053e-38 trajGIM2 &lt;- trajGIM[corGIM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGIM_MM[[1]]$name2, ] trajCombined &lt;- trajGIM2 assay(trajCombined, withDimnames=FALSE) &lt;- t(apply(assay(trajGIM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) combinedMat &lt;- plotTrajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-914c9c584-Date-2025-02-06_Time-02-58-31.143978.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-914c9c584-Date-2025-02-06_Time-02-58-31.143978.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGIM2)) ht1 &lt;- plotTrajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-92fc86dcd-Date-2025-02-06_Time-02-58-31.824126.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-92fc86dcd-Date-2025-02-06_Time-02-58-31.824126.log ht2 &lt;- plotTrajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9777c73b5-Date-2025-02-06_Time-02-58-32.578954.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2025-02-06 02:58:32.988129 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2025-02-06 02:58:32.993881 : ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9777c73b5-Date-2025-02-06_Time-02-58-32.578954.log ComplexHeatmap::draw(ht1 + ht2) "],["lymphoid-trajectory---b-cell-differentiation.html", "18.2 Lymphoid Trajectory - B Cell Differentiation", " 18.2 Lymphoid Trajectory - B Cell Differentiation As a second example of a trajectory, we will create a B cell trajectory from progenitor cells, through the common lymphoid progenitor and pre-B cell all the way to fully differentiated B cells. Because this analysis is essentially repeated from the monocyte trajectory in the previous section, we do not provide explanations for the code snippets. If you are trying to learn how to perform trajectory analysis, check out the monocyte trajectory section in this chapter instead. For reference, this is what our clusters look like: p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-978fecc87-Date-2025-02-06_Time-02-58-34.36984.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-978fecc87-Date-2025-02-06_Time-02-58-34.36984.log p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9641552fc-Date-2025-02-06_Time-02-58-36.26264.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9641552fc-Date-2025-02-06_Time-02-58-36.26264.log ggAlignPlots(p1, p2, type = &quot;h&quot;) 18.2.1 Pseudo-time UMAPs and individual feature plots The trajectory we will use will span from “Progenitor” to a lymphoid progenitor cell (“CLP”) to a “PreB” cell, and finally to a mature “B” cell. trajectory &lt;- c(&quot;Progenitor&quot;, &quot;CLP&quot;, &quot;PreB&quot;, &quot;B&quot;) trajectory ## [1] &quot;Progenitor&quot; &quot;CLP&quot; &quot;PreB&quot; &quot;B&quot; projHeme5 &lt;- addTrajectory( ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, groupBy = &quot;Clusters2&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE ) ## ArchR logging to : ArchRLogs/ArchR-addTrajectory-931ced161-Date-2025-02-06_Time-02-58-39.602988.log ## If there is an issue, please report to github with logFile! ## Filtering outliers ## Initial Alignment Before Spline Fit ## Spline Fit ## KNN to Spline ## ArchR logging successful to : ArchRLogs/ArchR-addTrajectory-931ced161-Date-2025-02-06_Time-02-58-39.602988.log head(projHeme5$LymphoidU[!is.na(projHeme5$LymphoidU)]) ## [1] 79.175800 80.227970 78.956598 80.622534 1.227532 83.954406 p &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;cellColData&quot;, name = &quot;LymphoidU&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-91a0aae5e-Date-2025-02-06_Time-02-58-40.137215.log ## If there is an issue, please report to github with logFile! ## Plotting ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-91a0aae5e-Date-2025-02-06_Time-02-58-40.137215.log p[[1]] ## Warning: Removed 7969 rows containing non-finite outside the scale range ## (`stat_summary_hex()`). p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;horizonExtra&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-93ab771fe-Date-2025-02-06_Time-02-58-47.324669.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values... ## 2025-02-06 02:58:49.01757 : ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-93ab771fe-Date-2025-02-06_Time-02-58-47.324669.log p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;blueYellow&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-9578dfcfd-Date-2025-02-06_Time-02-58-55.549999.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values... ## 2025-02-06 02:58:57.241542 : ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-9578dfcfd-Date-2025-02-06_Time-02-58-55.549999.log ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ## Warning: Removed 7969 rows containing non-finite outside the scale range (`stat_summary_hex()`). ## Removed 7969 rows containing non-finite outside the scale range (`stat_summary_hex()`). ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 18.2.2 Pseudo-time heatmaps trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Some values are below 0, this could be a DeviationsMatrix in which scaleTo should be set = NULL. ## Continuing without depth normalization! ## Smoothing... p1 &lt;- plotTrajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-932c015a4-Date-2025-02-06_Time-02-59-22.194025.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2025-02-06 02:59:22.610019 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2025-02-06 02:59:22.616315 : ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-932c015a4-Date-2025-02-06_Time-02-59-22.194025.log p1 trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing... p2 &lt;- plotTrajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-98142466-Date-2025-02-06_Time-02-59-48.722015.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-98142466-Date-2025-02-06_Time-02-59-48.722015.log p2 trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Smoothing... p3 &lt;- plotTrajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;)) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-954fc94ba-Date-2025-02-06_Time-03-00-17.387233.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-954fc94ba-Date-2025-02-06_Time-03-00-17.387233.log p3 trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing... p4 &lt;- plotTrajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94e13eef9-Date-2025-02-06_Time-03-00-50.321903.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94e13eef9-Date-2025-02-06_Time-03-00-50.321903.log p4 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1, p2, p3, p4, name = &quot;Plot-LymphoidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) ## Plotting ComplexHeatmap! ## Plotting ComplexHeatmap! ## Plotting ComplexHeatmap! ## Plotting ComplexHeatmap! 18.2.3 Integrative pseudo-time analyses corGSM_MM &lt;- correlateTrajectories(trajGSM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-9401110d6-Date-2025-02-06_Time-03-01-04.39258.log ## If there is an issue, please report to github with logFile! ## Found 14 Correlated Pairings! ## 2025-02-06 03:01:29.126472 : corGSM_MM[[1]]$matchname1 ## [1] &quot;PRDM16&quot; &quot;CREM&quot; &quot;NFE2&quot; &quot;MAFG&quot; &quot;RFX2&quot; &quot;CEBPA&quot; &quot;SPIB&quot; &quot;FOSL2&quot; ## [9] &quot;BCL11A&quot; &quot;FOXP1&quot; &quot;GATA2&quot; &quot;LEF1&quot; &quot;IRF2&quot; &quot;PAX5&quot; corGSM_MM[[1]] ## DataFrame with 14 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1 82 1081 PRDM16 PRDM16 chr1:PRDM16 z:PRDM16_211 ## 2 2503 978 CREM CREM chr10:CREM z:CREM_108 ## 3 5181 989 NFE2 NFE2 chr12:NFE2 z:NFE2_119 ## 4 10078 1018 MAFG MAFG chr17:MAFG-DT z:MAFG_148 ## 5 10649 1594 RFX2 RFX2 chr19:RFX2 z:RFX2_724 ## ... ... ... ... ... ... ... ## 10 15543 1223 FOXP1 FOXP1 chr3:FOXP1 z:FOXP1_353 ## 11 15802 1258 GATA2 GATA2 chr3:GATA2 z:GATA2_388 ## 12 16831 1630 LEF1 LEF1 chr4:LEF1 z:LEF1_760 ## 13 17102 1504 IRF2 IRF2 chr4:IRF2 z:IRF2_634 ## 14 21499 1579 PAX5 PAX5 chr9:PAX5 z:PAX5_709 ## Correlation VarAssay1 VarAssay2 TStat Pval FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.522796 0.999438 0.837356 6.07117 2.40966e-08 9.84345e-07 ## 2 0.504021 0.832404 0.840230 5.77700 8.99457e-08 2.75332e-06 ## 3 0.725487 0.982445 0.993103 10.43532 1.37720e-17 3.21477e-15 ## 4 0.561670 0.984477 0.944253 6.72047 1.20473e-09 5.81794e-08 ## 5 0.778142 0.972932 0.958046 12.26455 1.64963e-21 5.39100e-19 ## ... ... ... ... ... ... ... ## 10 0.564325 0.940589 0.909770 6.76701 9.67927e-10 4.94248e-08 ## 11 0.544193 0.916721 0.994828 6.42132 4.85671e-09 2.14483e-07 ## 12 0.505344 0.889134 0.866667 5.79736 8.21851e-08 2.68222e-06 ## 13 0.590905 0.847235 0.979885 7.25098 9.68055e-11 6.87740e-09 ## 14 0.783126 0.968003 0.963793 12.46664 6.17743e-22 2.52348e-19 trajGSM2 &lt;- trajGSM[corGSM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGSM_MM[[1]]$name2, ] trajCombined &lt;- trajGSM2 assay(trajCombined, withDimnames=FALSE) &lt;- t(apply(assay(trajGSM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) combinedMat &lt;- plotTrajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-968ebab31-Date-2025-02-06_Time-03-01-29.216983.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-968ebab31-Date-2025-02-06_Time-03-01-29.216983.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGSM2)) ht1 &lt;- plotTrajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-95c360a13-Date-2025-02-06_Time-03-01-29.912661.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-95c360a13-Date-2025-02-06_Time-03-01-29.912661.log ht2 &lt;- plotTrajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9271e68b0-Date-2025-02-06_Time-03-01-30.671831.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2025-02-06 03:01:31.072151 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2025-02-06 03:01:31.077903 : ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9271e68b0-Date-2025-02-06_Time-03-01-30.671831.log ComplexHeatmap::draw(ht1 + ht2) corGIM_MM &lt;- correlateTrajectories(trajGIM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-9ebe0432-Date-2025-02-06_Time-03-01-32.260076.log ## If there is an issue, please report to github with logFile! ## Found 40 Correlated Pairings! ## 2025-02-06 03:01:51.810945 : corGIM_MM[[1]]$matchname1 ## [1] &quot;ID3&quot; &quot;NFIA&quot; &quot;NFKB2&quot; &quot;IRF7&quot; &quot;ETS1&quot; &quot;NFE2&quot; &quot;FOXO1&quot; ## [8] &quot;IRF9&quot; &quot;FOS&quot; &quot;MEF2A&quot; &quot;IRF8&quot; &quot;MAFG&quot; &quot;FOXK2&quot; &quot;MBD2&quot; ## [15] &quot;TCF4&quot; &quot;TCF3&quot; &quot;NFIC&quot; &quot;KLF2&quot; &quot;CEBPA&quot; &quot;POU2F2&quot; &quot;RELB&quot; ## [22] &quot;FOSB&quot; &quot;SPIB&quot; &quot;FOSL2&quot; &quot;REL&quot; &quot;NFE2L2&quot; &quot;RUNX1&quot; &quot;ETS2&quot; ## [29] &quot;SMARCC1&quot; &quot;FOXP1&quot; &quot;GATA2&quot; &quot;HLTF&quot; &quot;RBPJ&quot; &quot;LEF1&quot; &quot;IRF2&quot; ## [36] &quot;MEF2C&quot; &quot;IRF1&quot; &quot;EBF1&quot; &quot;HOXA9&quot; &quot;PAX5&quot; corGIM_MM[[1]] ## DataFrame with 40 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## &lt;integer&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1 275 908 ID3 ID3 chr1:ID3 z:ID3_38 ## 2 680 1612 NFIA NFIA chr1:NFIA z:NFIA_742 ## 3 2428 1584 NFKB2 NFKB2 chr10:NFKB2 z:NFKB2_714 ## 4 2625 1505 IRF7 IRF7 chr11:IRF7 z:IRF7_635 ## 5 3790 1202 ETS1 ETS1 chr11:ETS1 z:ETS1_332 ## ... ... ... ... ... ... ... ## 36 14165 1510 MEF2C MEF2C chr5:MEF2C z:MEF2C_640 ## 37 14287 1499 IRF1 IRF1 chr5:IRF1 z:IRF1_629 ## 38 14558 937 EBF1 EBF1 chr5:EBF1 z:EBF1_67 ## 39 15847 1275 HOXA9 HOXA9 chr7:HOXA9 z:HOXA9_405 ## 40 17354 1579 PAX5 PAX5 chr9:PAX5 z:PAX5_709 ## Correlation VarAssay1 VarAssay2 TStat Pval FDR ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.793690 0.889898 0.990230 12.91604 7.05035e-23 2.23849e-21 ## 2 0.788673 0.874254 0.963218 12.69895 2.00673e-22 5.99657e-21 ## 3 0.884879 0.945863 0.941954 18.80524 2.77031e-34 1.56368e-32 ## 4 0.724828 0.835762 0.940805 10.41534 1.52151e-17 2.37823e-16 ## 5 0.534531 0.937692 0.801149 6.26113 1.01495e-08 6.06584e-08 ## ... ... ... ... ... ... ... ## 36 0.673779 0.993065 0.935057 9.02664 1.56638e-14 1.72983e-13 ## 37 0.685853 0.967421 0.987356 9.32969 3.45083e-15 4.17386e-14 ## 38 0.919121 0.979463 0.991954 23.09489 1.98188e-41 2.68187e-39 ## 39 0.744585 0.914413 0.805747 11.04227 6.72741e-19 1.22054e-17 ## 40 0.805725 0.966561 0.963793 13.46683 5.07101e-24 1.77660e-22 trajGIM2 &lt;- trajGIM[corGIM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGIM_MM[[1]]$name2, ] trajCombined &lt;- trajGIM2 assay(trajCombined, withDimnames=FALSE) &lt;- t(apply(assay(trajGIM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) combinedMat &lt;- plotTrajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9a41b982-Date-2025-02-06_Time-03-01-51.901058.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-9a41b982-Date-2025-02-06_Time-03-01-51.901058.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGIM2)) ht1 &lt;- plotTrajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94aadbd60-Date-2025-02-06_Time-03-01-52.597862.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-94aadbd60-Date-2025-02-06_Time-03-01-52.597862.log ht2 &lt;- plotTrajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectoryHeatmap-92feea91d-Date-2025-02-06_Time-03-01-53.351488.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2025-02-06 03:01:53.760684 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2025-02-06 03:01:53.766557 : ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectoryHeatmap-92feea91d-Date-2025-02-06_Time-03-01-53.351488.log ComplexHeatmap::draw(ht1 + ht2) "],["monocle3-trajectories.html", "18.3 Monocle3 Trajectories", " 18.3 Monocle3 Trajectories ArchR can also handle trajectories derived in Monocle3. This is handled by the getMonocleTrajectories() and addMonocleTrajectory() functions. Before diving in, it is worth noting that much of the infrastructure that ArchR uses for storing and visualizing trajectories is based on the assumption that the trajectory is linear and the trajectories determined by Monocle3 are not necessarily linear. Because of this, we either have to (i) force Monocle3 to create a linear trajectory by limiting the cell groups that it uses, or (ii) to treat the resulting Monocle3 trajectory as a collection of individual trajectories coming from a single cellular group. We illustrate these two workflows below. Though this is slightly counter to the typical ArchR workflow, we first run getMonocleTrajectories() to retrieve the trajectory from Monocle3. In this function call, principalGroup indicates the apex group from which the trajectory will emanate and useGroups tells Monocle3 all of the groups that should be mapped on the trajectory. First, we will create a linear trajectory of the lymphoid lineage. The same workflow would apply for the myeloid lineage but we are just going to create the lymphoid trajectory here to enable downstream comparison of ArchR, Monocle3, and Slingshot trajectories in a subsequent secion of this book. monocle_lymphoid_solo &lt;- getMonocleTrajectories( ArchRProj = projHeme5, name = &quot;Monocle_Lymphoid_solo&quot;, useGroups = c(&quot;Progenitor&quot;,&quot;CLP&quot;,&quot;PreB&quot;,&quot;B&quot;), principalGroup = &quot;Progenitor&quot;, groupBy = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;, clusterParams = list(k = 50), seed = 1 ) ## Running Monocole3 Trajectory Infrastructure! ## Adding Embedding ## Clustering Embedding ## Learning Graphs ## | | | 0% | |======================================================================| 100% ## Getting Principal Node ## Ordering Cells ## Plotting Results - /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4/Monocole3/Plot-Results-Monocle_Lymphoid_solo.pdf You’ll notice that during the above function call, ArchR tells you that the trajectory results were plotted to a PDF called Monocole3/Plot-Results-Monocle_Lymphoid_solo.pdf which you can reference to see the trajectory results. After we have retrieved this trajectory object from Monocle3 (called a “cell data set” or CDS), we need to add this information to our ArchRProject object. To do this, we use addMonocleTrajectory() and pass it the output of getMonocleTrajectories() to the monocleCDS parameter. projHeme5 &lt;- addMonocleTrajectory( ArchRProj = projHeme5, name = &quot;Monocle_Lymphoid_solo&quot;, useGroups = c(&quot;Progenitor&quot;,&quot;CLP&quot;,&quot;PreB&quot;,&quot;B&quot;), groupBy = &quot;Clusters2&quot;, monocleCDS = monocle_lymphoid_solo, force = TRUE ) Now, we can use plotTrajectory() to plot as before. You’ll notice that we’ve set the parameter addArrow = FALSE because the fitted lines often look a little off for these non-ArchR trajectories. p_lymphoid_solo &lt;- plotTrajectory(projHeme5, trajectory = &quot;Monocle_Lymphoid_solo&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Monocle_Lymphoid_solo&quot;, addArrow = FALSE) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-9b2acd76-Date-2025-02-06_Time-03-02-14.241264.log ## If there is an issue, please report to github with logFile! ## Plotting ## Plotting Trajectory ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-9b2acd76-Date-2025-02-06_Time-03-02-14.241264.log p_lymphoid_solo[[1]] ## Warning: Removed 7715 rows containing non-finite outside the scale range ## (`stat_summary_hex()`). Alternatively, we could create a single trajectory encompassing both the myeloid and lymphoid branches with a single call to getMonocleTrajectories(), providing all of the relevant groups to useGroups. For certain applications, this may be a useful implementation so it is worth thinking about the best way to do this for your particular biological question. First, we create a new monocleCDS object using getMonocleTrajectories(), but passing the cell groups corresponding to both the lymphoid and myeloid cell types to useGroups. monocle_progenitor &lt;- getMonocleTrajectories( ArchRProj = projHeme5, name = &quot;Monocle_Progenitor&quot;, useGroups = c(&quot;Progenitor&quot;, &quot;GMP&quot;,&quot;Mono&quot;,&quot;CLP&quot;,&quot;PreB&quot;,&quot;B&quot;), principalGroup = &quot;Progenitor&quot;, groupBy = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;, clusterParams = list(k = 50), seed = 1 ) ## Running Monocole3 Trajectory Infrastructure! ## Adding Embedding ## Clustering Embedding ## Learning Graphs ## | | | 0% | |======================================================================| 100% ## Getting Principal Node ## Ordering Cells ## Plotting Results - /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme4/Monocole3/Plot-Results-Monocle_Progenitor.pdf As mentioned above, the resulting Monocle trajectory contains multiple branches so we need to add each branch individually as its own trajectory. First, we will add the myeloid trajectory, by specifying the myeloid cell groupings to useGroups. projHeme5 &lt;- addMonocleTrajectory( ArchRProj = projHeme5, name = &quot;Monocle_Myeloid&quot;, useGroups = c(&quot;Progenitor&quot;,&quot;GMP&quot;,&quot;Mono&quot;), groupBy = &quot;Clusters2&quot;, monocleCDS = monocle_progenitor, force = TRUE ) Plotting this trajectory is the same as above. p_myeloid &lt;- plotTrajectory(projHeme5, trajectory = &quot;Monocle_Myeloid&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Monocle_Myeloid&quot;, addArrow = FALSE) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-94313c934-Date-2025-02-06_Time-03-02-44.682402.log ## If there is an issue, please report to github with logFile! ## Plotting ## Plotting Trajectory ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-94313c934-Date-2025-02-06_Time-03-02-44.682402.log p_myeloid[[1]] ## Warning: Removed 4960 rows containing non-finite outside the scale range ## (`stat_summary_hex()`). Similarly, we can add the lymphoid trajectory. projHeme5 &lt;- addMonocleTrajectory( ArchRProj = projHeme5, name = &quot;Monocle_Lymphoid&quot;, useGroups = c(&quot;Progenitor&quot;,&quot;CLP&quot;,&quot;PreB&quot;,&quot;B&quot;), groupBy = &quot;Clusters2&quot;, monocleCDS = monocle_progenitor, force = TRUE ) And then plot that lymphoid trajectory. p_lymphoid &lt;- plotTrajectory(projHeme5, trajectory = &quot;Monocle_Lymphoid&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Monocle_Lymphoid&quot;, addArrow = FALSE) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-95de1d685-Date-2025-02-06_Time-03-02-49.110668.log ## If there is an issue, please report to github with logFile! ## Plotting ## Plotting Trajectory ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-95de1d685-Date-2025-02-06_Time-03-02-49.110668.log p_lymphoid[[1]] ## Warning: Removed 7715 rows containing non-finite outside the scale range ## (`stat_summary_hex()`). If you look closely, you’ll notice slight differences between this lymphoid trajectory identified in isolation compared to the lymphoid branch of the larger joint monocle trajectory calculated at the beginning of this section. In particular, the “Progenitor” cells have a different pattern. "],["slingshot-trajectories.html", "18.4 Slingshot Trajectories", " 18.4 Slingshot Trajectories The same general workflow also works for trajectories determined by Slingshot. The only difference is that the workflow for Slingshot is more similar to the workflow for ArchR trajectories. Slingshot only utilizes the addSlingShotTrajectories() function and in doing so directly adds this trajectory to cellColData. Given how Slingshot works in ArchR, we will add a separate trajectory for each branch. Since this is primarily for illustrative purposes, we will only calculate the lymphoid trajectory here. projHeme5 &lt;- addSlingShotTrajectories( ArchRProj = projHeme5, name = &quot;Slingshot_Lymphoid&quot;, useGroups = c(&quot;Progenitor&quot;,&quot;CLP&quot;,&quot;PreB&quot;,&quot;B&quot;), principalGroup = &quot;Progenitor&quot;, groupBy = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;, seed = 1, force = TRUE ) This trajectory gets stored into cellColData in a column called “Slingshot_Lymphoid.Curve1”. Now, we can use plotTrajectory() to show the trajectory on our embedding. p_slingshot &lt;- plotTrajectory(projHeme5, trajectory = &quot;Slingshot_Lymphoid.Curve1&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Slingshot_Lymphoid.Curve1&quot;, addArrow = FALSE) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-96633c21c-Date-2025-02-06_Time-03-02-54.590481.log ## If there is an issue, please report to github with logFile! ## Plotting ## Plotting Trajectory ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-96633c21c-Date-2025-02-06_Time-03-02-54.590481.log p_slingshot[[1]] ## Warning: Removed 7715 rows containing non-finite outside the scale range ## (`stat_summary_hex()`). "],["comparing-the-different-trajectories.html", "18.5 Comparing the different trajectories", " 18.5 Comparing the different trajectories All of these trajectories show very similar results. We can quantify the overlap by looking at the correlation of the pseudo-time positions of the cells. First, we will make a data.frame containing the corresponding information dL &lt;- data.frame( ArchR = projHeme5$LymphoidU, SlingShot = projHeme5$Slingshot_Lymphoid.Curve1, Monocle = projHeme5$Monocle_Lymphoid_solo, Groups = projHeme5$Clusters2 ) Then, we can look at the correlation across these different approaches. corL &lt;- cor(dL[, 1:3], use=&quot;complete.obs&quot;) corL ## ArchR SlingShot Monocle ## ArchR 1.0000000 0.9538287 0.7476766 ## SlingShot 0.9538287 1.0000000 0.7715130 ## Monocle 0.7476766 0.7715130 1.0000000 We can also plot one-to-one correlation plots to show the pairwise comparisons. lymphoid_cells &lt;- c(&quot;Progenitor&quot;,&quot;CLP&quot;,&quot;PreB&quot;,&quot;B&quot;) dL &lt;- dL[!is.na(rowSums(dL[,1:3])), ,drop=FALSE] #Remove NA rows for cells not in trajectory p1 &lt;- ggPoint(dL[,1], dL[,2], paste0(dL[,&quot;Groups&quot;]), pal = paletteDiscrete(projHeme5$Clusters2)[lymphoid_cells], xlabel=&quot;ArchR&quot;, ylabel=&quot;Sling&quot;, labelAsFactors=F, labelMeans=F) p2 &lt;- ggPoint(dL[,1], dL[,3], paste0(dL[,&quot;Groups&quot;]), pal = paletteDiscrete(projHeme5$Clusters2)[lymphoid_cells], xlabel=&quot;ArchR&quot;, ylabel=&quot;Mon&quot;,labelAsFactors=F, labelMeans=F) p3 &lt;- ggPoint(dL[,2], dL[,3], paste0(dL[,&quot;Groups&quot;]), pal = paletteDiscrete(projHeme5$Clusters2)[lymphoid_cells], xlabel=&quot;Sling&quot;, ylabel=&quot;Mon&quot;,labelAsFactors=F, labelMeans=F) ggAlignPlots(p1,p2,p3,type=&quot;h&quot;) In most cases, ArchR and Slingshot agree more closely than either does with Monocle3, but this is not altogether surprising given the different methodologies. This, of course, does not mean that one is correct and the others are not but serves to accent that they are slightly different. "],["handling-archr-output.html", "Chapter 19 Handling ArchR Output", " Chapter 19 Handling ArchR Output This chapter will introduce you to how to extract data out of ArchR for your own use or for analysis with other available packages. In general, our goal is for ArchR to be your go-to software of choice for single-cell ATAC-seq and multi-omic analyses so if there are features that you feel should be added, please feel free to post in our Discussions forum on GitHub under the “Feature Requests” label. Before doing so, make sure to search old issues and discussions to make sure that this hasnt already been addressed. To start off, ArchR makes heavy use of SummarizedExperiment objects when exporting data. Many of the “get” functions in ArchR (getMarkerFeatures(),getCoAccessibility(), getPeakToGeneLinks(), etc.) return SummarizedExperiment objects. If you are not familiar with the SummarizedExperiment package, you should invest the time to familiarize yourself with it as it serves as the basis for the majority of genomics-related data types in R. You can read more about SummarizedExperiment here. There are also multiple YouTube videos that walk through the basics. If you aren’t familiar with SummarizedExperiment objects and opperations, then the remainder of this section may not be very helpful. "],["exporting-fragment-level-data.html", "19.1 Exporting fragment-level data", " 19.1 Exporting fragment-level data Before we start exporting data, lets save projHeme5 to its own directory. projHeme5 &lt;- saveArchRProject(ArchRProj = projHeme5, outputDirectory = &quot;Save-ProjHeme5&quot;, load = TRUE) ## Copying ArchRProject to new outputDirectory : /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5 ## Copying Arrow Files... ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights... ## Copying Other Files... ## Copying Other Files (1 of 12): Annotations ## Copying Other Files (2 of 12): Background-Peaks.rds ## Copying Other Files (3 of 12): Embeddings ## Copying Other Files (4 of 12): GroupCoverages ## Copying Other Files (5 of 12): IterativeLSI ## Copying Other Files (6 of 12): IterativeLSI2 ## Copying Other Files (7 of 12): IterativeLSI3 ## Copying Other Files (8 of 12): Monocole3 ## Copying Other Files (9 of 12): Peak2GeneLinks ## Copying Other Files (10 of 12): PeakCalls ## Copying Other Files (11 of 12): Plots ## Copying Other Files (12 of 12): RNAIntegration ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## To enable optimal flexibility, ArchR allows you to export fragments from your ArchRProject or ArrowFiles at any time using the getFragmentsFromArrow(), getFragmentsFromProject(), and getGroupFragments() functions. For the getFragmentsFromArrow() and getFragmentsFromProject() functions, you must provide the cellNames for the cells you wish to extract. For example, you might extract the fragments from a particular cluster from your entire project like this: frags &lt;- getFragmentsFromProject( ArchRProj = projHeme5, cellNames = getCellNames(ArchRProj = projHeme5)[which(projHeme5@cellColData$Clusters2 == &quot;Mono&quot;)] ) ## ArchR logging to : ArchRLogs/ArchR-getFragmentsFromProject-93afeb579-Date-2025-02-06_Time-03-08-30.449711.log ## If there is an issue, please report to github with logFile! ## Reading ArrowFile 1 of 3 ## Reading ArrowFile 2 of 3 ## Reading ArrowFile 3 of 3 Inspecting the frags object here, shows it to be a list and each of the elements of frags is a GRanges object corresponding to one of the original Arrow Files: frags ## List of length 3 ## names(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 We can just unlist this object to get a GRanges object where each entry represents an individual fragment: unlist(frags) ## GRanges object with 9320877 ranges and 1 metadata column: ## seqnames ranges strand | RG ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;Rle&gt; ## scATAC_BMMC_R1 chr1 842515-842901 * | scATAC_BMMC_R1#CCCAC.. ## scATAC_BMMC_R1 chr1 931221-931355 * | scATAC_BMMC_R1#CCCAC.. ## scATAC_BMMC_R1 chr1 939387-939615 * | scATAC_BMMC_R1#CCCAC.. ## scATAC_BMMC_R1 chr1 985376-985401 * | scATAC_BMMC_R1#CCCAC.. ## scATAC_BMMC_R1 chr1 988510-988541 * | scATAC_BMMC_R1#CCCAC.. ## ... ... ... ... . ... ## scATAC_PBMC_R1 chrY 22737645-22737827 * | scATAC_PBMC_R1#AATGG.. ## scATAC_PBMC_R1 chrY 15443307-15443509 * | scATAC_PBMC_R1#GGTGC.. ## scATAC_PBMC_R1 chrY 14604751-14604917 * | scATAC_PBMC_R1#CGATG.. ## scATAC_PBMC_R1 chrY 5609640-5609780 * | scATAC_PBMC_R1#TATGT.. ## scATAC_PBMC_R1 chrY 22737684-22737775 * | scATAC_PBMC_R1#TATGT.. ## ------- ## seqinfo: 24 sequences from an unspecified genome; no seqlengths Similarly, getGroupFragments() provides a shortcut to doing fragment export based on cell groupings defined in cellColData. However, this function creates fragment files on disk, rather than storing them as a GRanges object. frags &lt;- getGroupFragments(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) Inspecting the frags object returned as the output of getGroupFragments(), we get the file paths to the fragment files on disk. frags ## [1] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.B.tsv.gz&quot; ## [2] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.CD4.M.tsv.gz&quot; ## [3] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.CD4.N.tsv.gz&quot; ## [4] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.CLP.tsv.gz&quot; ## [5] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.Erythroid.tsv.gz&quot; ## [6] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.GMP.tsv.gz&quot; ## [7] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.Mono.tsv.gz&quot; ## [8] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.NK.tsv.gz&quot; ## [9] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.pDC.tsv.gz&quot; ## [10] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.PreB.tsv.gz&quot; ## [11] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupFragments/Clusters2.Progenitor.tsv.gz&quot; "],["exporting-matrix-level-data.html", "19.2 Exporting matrix-level data", " 19.2 Exporting matrix-level data ArchR provides the getMatrixFromProject() function which allows you to export any matrix from your project as a SummarizedExperiment. The information returned is on a per-cell basis. In most cases, that matrix will be stored as a sparse matrix of class dgCMatrix. Some matrices, especially for larger projects, may take up excessive memory and lead to crashes when trying to export and there is really no way around this. This is, in fact, why ArchR leverages the on-disk storage of these data in HDF5 format. For example, we can export the GeneScoreMatrix from our project like so: GSM_se &lt;- getMatrixFromProject( ArchRProj = projHeme5, useMatrix &lt;- &quot;GeneScoreMatrix&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMatrixFromProject-97cfcfd33-Date-2025-02-06_Time-03-11-00.505036.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:11:10.827051 : Organizing colData, 0.172 mins elapsed. ## 2025-02-06 03:11:10.949313 : Organizing rowData, 0.174 mins elapsed. ## 2025-02-06 03:11:10.957773 : Organizing rowRanges, 0.174 mins elapsed. ## 2025-02-06 03:11:10.96988 : Organizing Assays (1 of 1), 0.174 mins elapsed. ## 2025-02-06 03:11:11.132909 : Constructing SummarizedExperiment, 0.177 mins elapsed. ## 2025-02-06 03:11:14.708232 : Finished Matrix Creation, 0.237 mins elapsed. When we inspect this object, we can see the various attributes stored in the SummarizedExperiment: GSM_se ## class: SummarizedExperiment ## dim: 23127 10250 ## metadata(0): ## assays(1): GeneScoreMatrix ## rownames: NULL ## rowData names(6): seqnames start ... name idx ## colnames(10250): scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 ... ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 ## colData names(39): BlacklistRatio DoubletEnrichment ... ## Monocle_Lymphoid Slingshot_Lymphoid.Curve1 For various reasons, we do not provide a method for directly converting an ArchRProject into an object that can interface with other tools like Seurat. Given the large differences in how these different tools work, this is beyond the scope of what we aim to support. However, once a matrix is exported as a SummarizedExperiment object, it is relatively simple to reformat that object to something that can be imported into the Seurat ecosystem. Shown below is an example of how this might be accomplished using a GeneScoreMatrix but the same applies to other matrices: library(SingleCellExperiment) library(Seurat) GSM_sce &lt;- as(GSM_se, &quot;SingleCellExperiment&quot;) counts &lt;- as.matrix(assay(GSM_sce, &quot;GeneScoreMatrix&quot;)) ## Warning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size ## 1.8 GiB assays(GSM_sce)$counts &lt;- counts libSizes &lt;- colSums(counts) sizeFactors &lt;- libSizes/mean(libSizes) assays(GSM_sce)$logcounts &lt;- log2(t(t(counts)/sizeFactors) + 1) rownames(GSM_sce) &lt;- rowData(GSM_sce)$name seuratObj &lt;- as.Seurat(GSM_sce, counts = &quot;counts&quot;, data = &quot;logcounts&quot;) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes ## (&#39;-&#39;) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes ## (&#39;-&#39;) ## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes ## (&#39;-&#39;) This gives us an object of class Seurat: seuratObj ## An object of class Seurat ## 23127 features across 10250 samples within 1 assay ## Active assay: originalexp (23127 features, 0 variable features) ## 2 layers present: counts, data You can then manipulate this object as you would any other Seurat object. Other operations are possible, for example, you can take your dimensionality reduction results from ArchR and add them to this Seurat object: seuratObj[[&quot;iterativeLSI&quot;]] &lt;- CreateDimReducObject(embeddings = getReducedDims(projHeme5), key = &quot;ILSI_&quot;, assay = DefaultAssay(seuratObj)) "],["exporting-pseudo-bulked-data-to-a-summarizedexperiment.html", "19.3 Exporting pseudo-bulked data to a SummarizedExperiment", " 19.3 Exporting pseudo-bulked data to a SummarizedExperiment Often times, we want to analyze our single-cell data as if it were bulk data to get around issues of sparsity. For example, you might want to use pseudo-bulk replicates when trying to understand “how does cluster X or cell type Y differ across cases and controls”. To enable this type of analysis, ArchR provides the getGroupSE() and getPBGroupSE() functions. These function will group your cells based on different parameters. getGroupSE() will group cells based on the values found in a column of cellColData. For example, you might want to get an SE containing information from each sample for each cluster. As you will remember from earlier chapters, you can add whatever information you want as new columns to cellColData and this can be helpful to create the grouping divisions that you want to extract with getGroupSE(). getPBGroupSE() is similar but it uses the exact pseudo-bulk cell groupings that were used in your ArchRProject to create coverage files, call peaks, etc. If the difference between these functions seems subtle, you should re-read the chapter on pseudo-bulks to understand the difference. For example, if we wanted to create pseudo-bulk replicates based on Cluster and Sample, creating a single replicate for each sample x cluster combination, we could add a new column to cellColData representing this information: projHeme5 &lt;- addCellColData(ArchRProj = projHeme5, data = paste0(projHeme5@cellColData$Sample,&quot;_x_&quot;,projHeme5@cellColData$Clusters2), name = &quot;Clusters2_x_Sample&quot;, cells = getCellNames(projHeme5)) head(projHeme5@cellColData$Clusters2_x_Sample) ## [1] &quot;scATAC_BMMC_R1_x_B&quot; &quot;scATAC_BMMC_R1_x_CD4.N&quot; &quot;scATAC_BMMC_R1_x_PreB&quot; ## [4] &quot;scATAC_BMMC_R1_x_PreB&quot; &quot;scATAC_BMMC_R1_x_PreB&quot; &quot;scATAC_BMMC_R1_x_GMP&quot; We can then use this column in cellColData as the groupBy parameter to getGroupSE() to get a SummarizedExperiment object containing a single column per sample x cluster combination: groupSE &lt;- getGroupSE(ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2_x_Sample&quot;) ## ArchR logging to : ArchRLogs/ArchR-getGroupSE-941c924a-Date-2025-02-06_Time-03-11-30.470645.log ## If there is an issue, please report to github with logFile! ## Getting Group Matrix ## 2025-02-06 03:11:56.800054 : Successfully Created Group Matrix, 0.42 mins elapsed. ## Normalizing by number of Cells ## ArchR logging successful to : ArchRLogs/ArchR-getGroupSE-941c924a-Date-2025-02-06_Time-03-11-30.470645.log dim(groupSE) ## [1] 147407 25 colnames(groupSE) ## [1] &quot;scATAC_BMMC_R1_x_B&quot; &quot;scATAC_BMMC_R1_x_CD4.M&quot; ## [3] &quot;scATAC_BMMC_R1_x_CD4.N&quot; &quot;scATAC_BMMC_R1_x_CLP&quot; ## [5] &quot;scATAC_BMMC_R1_x_Erythroid&quot; &quot;scATAC_BMMC_R1_x_GMP&quot; ## [7] &quot;scATAC_BMMC_R1_x_Mono&quot; &quot;scATAC_BMMC_R1_x_NK&quot; ## [9] &quot;scATAC_BMMC_R1_x_pDC&quot; &quot;scATAC_BMMC_R1_x_PreB&quot; ## [11] &quot;scATAC_BMMC_R1_x_Progenitor&quot; &quot;scATAC_CD34_BMMC_R1_x_B&quot; ## [13] &quot;scATAC_CD34_BMMC_R1_x_CLP&quot; &quot;scATAC_CD34_BMMC_R1_x_Erythroid&quot; ## [15] &quot;scATAC_CD34_BMMC_R1_x_GMP&quot; &quot;scATAC_CD34_BMMC_R1_x_Mono&quot; ## [17] &quot;scATAC_CD34_BMMC_R1_x_pDC&quot; &quot;scATAC_CD34_BMMC_R1_x_Progenitor&quot; ## [19] &quot;scATAC_PBMC_R1_x_B&quot; &quot;scATAC_PBMC_R1_x_CD4.M&quot; ## [21] &quot;scATAC_PBMC_R1_x_CD4.N&quot; &quot;scATAC_PBMC_R1_x_GMP&quot; ## [23] &quot;scATAC_PBMC_R1_x_Mono&quot; &quot;scATAC_PBMC_R1_x_NK&quot; ## [25] &quot;scATAC_PBMC_R1_x_pDC&quot; getGroupSE() is capable of exporting any matrix to a SummarizedExperiment object. The functionality of getPBGroupSE() is nearly identical to getGroupSE(). The primary difference is that the cell groupings used will be determined by calling addGroupCoverages() with returnGroups = TRUE. "],["exporting-pseudo-bulked-data-to-a-bigwig-file.html", "19.4 Exporting pseudo-bulked data to a bigWig file", " 19.4 Exporting pseudo-bulked data to a bigWig file Another common use for pseudo-bulked data is to look at genome browser tracks. Of course, ArchR does have its own built-in genome browser which can be accessed via ArchRBrowser(), but we also enable users to export pseudo-bulked bigWig tracks for use with other tools. To do this, we use the getGroupBW() function. This function uses the same groupBy parameter as above. Additionally, users can toggle how the tracks are normalized but we recommend the default which is “ReadsInTSS” which simultaneously normalized for sequencing depth and data quality. When we run this function, a folder is created within the outputDirectory of our ArchRProject called “GroupBigWigs” and within that directory a subdirectory is created based on the value passed to groupBy. In the below example, we extract bigWig tracks for each group in Clusters2: coverageFiles &lt;- getGroupBW(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-getGroupBW-96d85d2d7-Date-2025-02-06_Time-03-12-00.699859.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:12:02.465851 : B (1 of 11) : Creating BigWig for Group, 0.029 mins elapsed. ## 2025-02-06 03:12:52.470986 : CD4.M (2 of 11) : Creating BigWig for Group, 0.863 mins elapsed. ## 2025-02-06 03:13:25.123833 : CD4.N (3 of 11) : Creating BigWig for Group, 1.407 mins elapsed. ## 2025-02-06 03:13:58.51762 : CLP (4 of 11) : Creating BigWig for Group, 1.964 mins elapsed. ## 2025-02-06 03:14:30.983712 : Erythroid (5 of 11) : Creating BigWig for Group, 2.505 mins elapsed. ## 2025-02-06 03:15:04.645637 : GMP (6 of 11) : Creating BigWig for Group, 3.066 mins elapsed. ## 2025-02-06 03:15:50.463719 : Mono (7 of 11) : Creating BigWig for Group, 3.829 mins elapsed. ## 2025-02-06 03:16:35.82617 : NK (8 of 11) : Creating BigWig for Group, 4.585 mins elapsed. ## 2025-02-06 03:17:09.78164 : pDC (9 of 11) : Creating BigWig for Group, 5.151 mins elapsed. ## 2025-02-06 03:17:55.195733 : PreB (10 of 11) : Creating BigWig for Group, 5.908 mins elapsed. ## 2025-02-06 03:18:14.459673 : Progenitor (11 of 11) : Creating BigWig for Group, 6.229 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-getGroupBW-96d85d2d7-Date-2025-02-06_Time-03-12-00.699859.log The return value of getGroupBW() is a vector of file paths to the created bigWig files. coverageFiles ## [1] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/B-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [2] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/CD4.M-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [3] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/CD4.N-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [4] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/CLP-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [5] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/Erythroid-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [6] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/GMP-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [7] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/Mono-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [8] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/NK-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [9] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/pDC-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [10] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/PreB-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; ## [11] &quot;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme5/GroupBigWigs/Clusters2/Progenitor-TileSize-100-normMethod-ReadsInTSS-ArchR.bw&quot; "],["integration-with-bulk-atac-seq.html", "Chapter 20 Integration with bulk ATAC-seq", " Chapter 20 Integration with bulk ATAC-seq Many bulk ATAC-seq datasets exist and it can often be useful to leverage these bulk datasets during our single-cell workflows. This chapter will review the ways in which ArchR enables integration of single-cell and bulk ATAC-seq data. However, ArchR is not currently designed for the analysis of bulk ATAC-seq data alone. This is on the feature development roadmap but not currently possible. "],["projecting-bulk-atac-seq-data.html", "20.1 Projecting bulk ATAC-seq data", " 20.1 Projecting bulk ATAC-seq data Projection of bulk ATAC-seq data into a single-cell dimensionality reduction is handled by the projectBulkATAC() function. This function accepts a SummarizedExperiment object containing the relevant bulk ATAC-seq data, subsets this object based on overlap of the peak regions in the bulk ATAC-seq SummarizedExperiment and single-cell ArchRProject, simulates sub-sampled “pseudocells”, and projects these pseudocells into the specified dimensionality reduction and embedding. A “pseudocell” is a downsampled representation of a bulk ATAC-seq library To get the projectBulkATAC() function to work, the SummarizedExperiment object must be properly formatted. In particular, there needs to be an assay named “counts” containing the raw counts for each peak (row) for each sample (column). The rowRanges can be any peak set and the projectBulkATAC() function will match those rows to the peakSet of your ArchRProject based on overlaps. This means that it is not required to have a counts matrix based on the exact same set of peaks as used in your ArchRProject, enabling projection of bulk ATAC-seq data analyzed previously, for example from publicly available sources. Below, we demonstrate the core functionality of projectBulkATAC() using a data set of bulk ATAC-seq data from FACS-enriched hematopoietic cell types (Corces et al. Nature Genetics 2015). First, lets download the counts matrix from GEO and fix the column names to be more human readable. #Download bulk ATAC-seq data and organize raw counts matrix download.file(url = &quot;https://ftp.ncbi.nlm.nih.gov/geo/series/GSE74nnn/GSE74912/suppl/GSE74912_ATACseq_All_Counts.txt.gz&quot;, destfile = &quot;Corces_HemeAML_BulkATAC.txt.gz&quot;) download.file(url = &quot;https://jeffgranja.s3.amazonaws.com/ArchR/TestData/Corces_HemeAML_ReHeader.txt&quot;, destfile = &quot;Corces_HemeAML_ReHeader.txt&quot;) df &lt;- read.table(file = &quot;Corces_HemeAML_BulkATAC.txt.gz&quot;, header = TRUE, sep = &#39;\\t&#39;, stringsAsFactors = FALSE) header &lt;- read.table(file = &quot;Corces_HemeAML_ReHeader.txt&quot;, header = TRUE, sep = &#39;\\t&#39;, stringsAsFactors = FALSE) colnames(df) &lt;- header$NewHeader df[1:6,1:6] ## chr start end Donor4983_1A_HSC Donor4983_2A_MPP Donor4983_3A_LMPP ## 1 chr1 10025 10525 1 0 4 ## 2 chr1 13252 13752 0 5 6 ## 3 chr1 16019 16519 4 2 6 ## 4 chr1 96376 96876 0 0 0 ## 5 chr1 115440 115940 0 3 0 ## 6 chr1 235393 235893 0 2 2 Inspecting the first few rows and columns of this data.frame shows that the first three columns are actually the peak coordinates and the remaining columns represent the individual samples. Because of this, we need to strip out the peak information and create a separate GenomicRanges object to represent the peak regions. bulk_gr &lt;- GRanges(seqnames = df$chr, ranges = IRanges(start = df$start+1, end = df$end)) df &lt;- df[,which(colnames(df) %ni% c(&quot;chr&quot;,&quot;start&quot;,&quot;end&quot;))] rownames(df) &lt;- paste(bulk_gr) We don’t need all of the data in this counts matrix so for simplicity we will subset the counts matrix to only include a few cell types (columns) with data that is well-represented in our tutorial dataset. colsToKeep &lt;- c(&quot;Donor4983_10A_CD8Tcell&quot;, &quot;Donor4983_9A_CD4Tcell&quot;, &quot;Donor5483_13A_Bcell&quot;, &quot;Donor5483_11B_NKcell&quot;, &quot;Donor7256_7B_Mono&quot;) df &lt;- df[,colsToKeep] Now we are ready to create our SummarizedExperiment object using the raw counts and peak regions. seBulk &lt;- SummarizedExperiment(assays = SimpleList(counts = as.matrix(df)), rowRanges = bulk_gr) seBulk ## class: RangedSummarizedExperiment ## dim: 590650 5 ## metadata(0): ## assays(1): counts ## rownames(590650): chr1:10026-10525 chr1:13253-13752 ... ## chrX:154912442-154912941 chrX:155259861-155260360 ## rowData names(0): ## colnames(5): Donor4983_10A_CD8Tcell Donor4983_9A_CD4Tcell ## Donor5483_13A_Bcell Donor5483_11B_NKcell Donor7256_7B_Mono ## colData names(0): To project these bulk samples using projectBulkATAC(), we specify the reducedDims and embedding we want to use as well as the number of “pseudocells” we want to project. bulkPro &lt;- projectBulkATAC(ArchRProj = projHeme5, seATAC = seBulk, reducedDims = &quot;IterativeLSI&quot;, embedding = &quot;UMAP&quot;, n = 250) ## ArchR logging to : ArchRLogs/ArchR-projectBulkATAC-927f8515a-Date-2025-02-06_Time-03-26-58.532702.log ## If there is an issue, please report to github with logFile! ## Overlap Ratio of Reduced Dims Features = 0.99084 ## 2025-02-06 03:26:59.057741 : ## 03:27:07 Creating temp directory /tmp/RtmpCdKDaq/dir9e918331 ## untar: using cmd = &#39;/usr/bin/tar -xf &#39;/workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjHeme1/Embeddings/Save-Uwot-UMAP-Params-IterativeLSI-92066cb76-Date-2025-02-06_Time-01-06-45.092175.tar&#39; -C &#39;/tmp/RtmpCdKDaq/dir9e918331&#39;&#39; ## 03:27:11 Read 6250 rows and found 30 numeric columns ## 03:27:11 Processing block 1 of 1 ## 03:27:11 Writing NN index file to temp file /tmp/RtmpCdKDaq/file9249c80e4 ## 03:27:11 Searching Annoy index using 8 threads, search_k = 3000 ## 03:27:12 Commencing smooth kNN distance calibration using 8 threads with target n_neighbors = 30 ## 03:27:12 Initializing by weighted average of neighbor coordinates using 8 threads ## 03:27:12 Commencing optimization for 67 epochs, with 187500 positive edges ## 03:27:12 Finished ## ArchR logging successful to : ArchRLogs/ArchR-projectBulkATAC-927f8515a-Date-2025-02-06_Time-03-26-58.532702.log bulkPro ## List of length 3 ## names(3): simulatedBulkUMAP singleCellUMAP simulatedReducedDims The output of projectBulkATAC() is a list object containing 3 entries discussed below. simulatedBulkUMAP is a DataFrame containing the embedding coordinates for the simulated “pseduocells”. head(bulkPro$simulatedBulkUMAP) ## DataFrame with 6 rows and 3 columns ## UMAP1 UMAP2 Type ## &lt;numeric&gt; &lt;numeric&gt; &lt;Rle&gt; ## Donor4983_10A_CD8Tcell#1 9.37652 -0.2009891 Donor4983_10A_CD8Tcell ## Donor4983_10A_CD8Tcell#2 9.69217 0.4535988 Donor4983_10A_CD8Tcell ## Donor4983_10A_CD8Tcell#3 9.65991 -0.0697212 Donor4983_10A_CD8Tcell ## Donor4983_10A_CD8Tcell#4 9.65814 -0.0221541 Donor4983_10A_CD8Tcell ## Donor4983_10A_CD8Tcell#5 9.64607 0.1114746 Donor4983_10A_CD8Tcell ## Donor4983_10A_CD8Tcell#6 9.46927 -0.2376311 Donor4983_10A_CD8Tcell singleCellUMAP is a DataFrame containing the embedding coordinates for all of the original single-cells in your ArchRProject. head(bulkPro$singleCellUMAP) ## DataFrame with 6 rows and 3 columns ## UMAP1 UMAP2 Type ## &lt;numeric&gt; &lt;numeric&gt; &lt;Rle&gt; ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 -2.0100708 -0.463790 scATAC ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 8.3619858 1.214364 scATAC ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 -0.1737829 -9.489737 scATAC ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 -0.1669594 -7.583627 scATAC ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 -0.0378193 -8.868483 scATAC ## scATAC_BMMC_R1#AGTTACGAGAACGTCG-1 -2.8937029 0.609718 scATAC simulatedReducedDims is a DataFrame containing the coordinates in the given reduced dimensions (i.e. “IterativeLSI”) for each of the simulated “pseudocells”. head(bulkPro$simulatedReducedDims[,1:5]) ## LSI1 LSI2 LSI3 LSI4 LSI5 ## Donor4983_10A_CD8Tcell#1 -4.625283 1.686137 -0.5859489 -0.16511159 0.5173089 ## Donor4983_10A_CD8Tcell#2 -4.655096 1.604512 -0.3136310 -0.22394294 0.4209449 ## Donor4983_10A_CD8Tcell#3 -4.677772 1.683076 -0.5080028 -0.01157532 0.5635535 ## Donor4983_10A_CD8Tcell#4 -4.631163 1.706387 -0.4764640 -0.02528689 0.4869747 ## Donor4983_10A_CD8Tcell#5 -4.643288 1.659233 -0.5008208 -0.17292483 0.3627571 ## Donor4983_10A_CD8Tcell#6 -4.614042 1.690643 -0.3981789 -0.01228556 0.6056827 Once we have the output of projectBulkATAC(), we often just want to plot this data to see where in our embedding the simulated “pseudocells” fall. There are many ways to do this but the easiest is to just concatenate the data from projectBulkATAC(), create a color palette, and use ggPoint() to plot. #concatenate single-cell and pseudocell embedding positions pro_df &lt;- rbind(bulkPro$singleCellUMAP, bulkPro$simulatedBulkUMAP) #create a color palette and force the scATAC cells to be grey to enable visualization of the project bulk ATAC data pal &lt;- paletteDiscrete(values = unique(as.character(pro_df$Type)), set = &quot;stallion&quot;) pal[&quot;scATAC&quot;] &lt;- &quot;#BABABA&quot; #plot using ggPoint ggPoint(x = pro_df$UMAP1, y = pro_df$UMAP2, discrete = TRUE, color = as.character(pro_df$Type), pal = pal, xlabel = &quot;UMAP Dimension 1&quot;, ylabel = &quot;UMAP Dimension 2&quot;, title = &quot;Heme Bulk ATAC-seq Projection&quot;) In the resulting projection UMAP plot, you can see that the bulk ATAC-seq pseudocells pile up in the regions occupied by the corresponding single-cells. At this point in the tutorial, we are done modifying our ArchRProject so lets save it one last time to make sure all of our changes are saved on disk. We will just save it on top of our previous projHeme5 directory. projHeme5 &lt;- saveArchRProject(ArchRProj = projHeme5, outputDirectory = “Save-ProjHeme5”, load = TRUE) "],["multiomic-data-analysis-in-archr.html", "Chapter 21 Multiomic data analysis in ArchR", " Chapter 21 Multiomic data analysis in ArchR This chapter provides an overview of how to analyze multiomic data in ArchR. For clarity, when we say “multiomic data”, what we are really talking about is ATAC-seq and RNA-seq acquired from the same single cells using the 10x Genomics platform. Our hope is to eventually generalize the infrastructure and workflows here to arbitrary multiomic data types and platforms but given that the vast majority of use cases focus specifically on the 10x Multiome kit, that is the first implementation we have made. Importantly, this chapter is not meant to serve as the only thing you read if you are a new ArchR user starting with Multiome data. Instead, you should read the full manual from the start. This chapter really just shows how to work with Multiome data and load it into the ArchR ecosystem. It does not provide details on all of the other capabilities of ArchR and how to properly use them. "],["importing-data-and-setting-up-a-multiome-project.html", "21.1 Importing data and setting up a Multiome project", " 21.1 Importing data and setting up a Multiome project First, it is worth noting that the datasets used in this chapter are different from the datasets used in the other chapters and we will be creating a new ArchRProject here. For this reason, and to make this chapter a standalone, we will repeat operations from other parts of the manual. Lets start by loading ArchR and setting up our genome (hg38 in this case), our threads (which are system dependent so you should change that based on your computational resources), and our random seed. library(ArchR) addArchRGenome(&quot;hg38&quot;) ## Setting default genome to Hg38. addArchRThreads(8) ## Setting default number of Parallel threads to 8. addArchRLocking(locking = TRUE) ## Setting ArchRLocking to TRUE. set.seed(1) We can download the files associated with the multiome tutorial just like we did for the main tutorial but using tutorial = \"Multiome\". inputFiles &lt;- getTutorialData(tutorial = &quot;Multiome&quot;) ## Downloading files to Multiome... If we inspect inputFiles you can see that we have a .fragments.tsv.gz file and a filtered_feature_bc_matrix.h5 file for each sample. These two files are both standard outputs of the 10x Genomics cellranger-arc pipeline. inputFiles ## pbmc_sorted_3k ## &quot;Multiome/pbmc_sorted_3k.fragments.tsv.gz&quot; ## pbmc_unsorted_3k ## &quot;Multiome/pbmc_unsorted_3k.fragments.tsv.gz&quot; ## pbmc_sorted_3k ## &quot;Multiome/pbmc_sorted_3k.filtered_feature_bc_matrix.h5&quot; ## pbmc_unsorted_3k ## &quot;Multiome/pbmc_unsorted_3k.filtered_feature_bc_matrix.h5&quot; The first thing we need to do is separate out the scATAC-seq input files from the scRNA-seq input files. Here, we are doing that using grep() but you can also do it manually however you want. The important thing is to end up with a named vector of files corresponding to the scATAC-seq data and a named vector of files corresponding to the scRNA-seq data and that the names of the corresponding samples match! atacFiles &lt;- inputFiles[grep(pattern = &quot;\\\\.fragments.tsv.gz$&quot;, x = inputFiles)] rnaFiles &lt;- inputFiles[grep(pattern = &quot;\\\\.filtered_feature_bc_matrix.h5$&quot;, x = inputFiles)] For clarity, the above code is the same as doing this manually: atacFiles &lt;- c(&quot;pbmc_sorted_3k&quot; = &quot;Multiome/pbmc_sorted_3k.fragments.tsv.gz&quot;, &quot;pbmc_unsorted_3k&quot; = &quot;Multiome/pbmc_unsorted_3k.fragments.tsv.gz&quot;) rnaFiles &lt;- c(&quot;pbmc_sorted_3k&quot; = &quot;Multiome/pbmc_sorted_3k.filtered_feature_bc_matrix.h5&quot;, &quot;pbmc_unsorted_3k&quot; = &quot;Multiome/pbmc_unsorted_3k.filtered_feature_bc_matrix.h5&quot;) You can see that the names in these vectors match which is what will be used to link the files together upon import. names(atacFiles) ## [1] &quot;pbmc_sorted_3k&quot; &quot;pbmc_unsorted_3k&quot; names(rnaFiles) ## [1] &quot;pbmc_sorted_3k&quot; &quot;pbmc_unsorted_3k&quot; all.equal(names(atacFiles), names(rnaFiles)) ## [1] TRUE As in the main tutorial, the first step is to create ArrowFiles from the scATAC-seq fragment files. ArrowFiles &lt;- createArrowFiles( inputFiles = atacFiles, sampleNames = names(atacFiles), minTSS = 4, minFrags = 1000, addTileMat = TRUE, addGeneScoreMat = TRUE ) ## Using GeneAnnotation set by addArchRGenome(Hg38)! ## Using GeneAnnotation set by addArchRGenome(Hg38)! ## ArchR logging to : ArchRLogs/ArchR-createArrows-96aeb8df5-Date-2025-02-06_Time-03-35-55.533788.log ## If there is an issue, please report to github with logFile! ## Cleaning Temporary Files ## subThreading Disabled since ArchRLocking is TRUE see `addArchRLocking` ## 2025-02-06 03:35:56.187222 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-createArrows-96aeb8df5-Date-2025-02-06_Time-03-35-55.533788.log Then we create an ArchRProject object from those ArrowFiles projMulti1 &lt;- ArchRProject(ArrowFiles = ArrowFiles) ## Using GeneAnnotation set by addArchRGenome(Hg38)! ## Using GeneAnnotation set by addArchRGenome(Hg38)! ## Validating Arrows... ## Getting SampleNames... ## ## Copying ArrowFiles to Ouptut Directory! If you want to save disk space set copyArrows = FALSE ## 1 2 ## Getting Cell Metadata... ## ## Merging Cell Metadata... ## Initializing ArchRProject... ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## Now that we’ve handled the scATAC-seq data, we turn out attention to the scRNA-seq data. ArchR provides the import10xFeatureMatrix() function which will perform this automatically for all of the filtered_feature_bc_matrix.h5 files in your data set. While this process may seem straightforward, there are a few things going on under-the-hood which are important to understand. First, the filtered_feature_bc_matrix.h5 created by cellranger-arc are not always perfectly matched across samples. For example, ArchR will throw an error if your various scRNA-seq input files do not match based on the gene names or the metadata columns because we view this as an unforseen incompatibility between data, potentially caused by alignment to different reference genomes or something similar. There are also more permissible mismatches that occur across these input files. Relatively frequently, the transcript-level data that is associated with each gene can vary slightly across samples for reasons that aren’t completely clear. For more information, see this post. Because of this, you have to decide what to do when these minor conflicts arise. We provide two options which are controlled by the strictMatch parameter. If you want to try to keep the genes with mis-matched metadata information, set strictMatch = FALSE which will coerce all samples to match the metadata information of the first sample from your input. Alternatively, if you would prefer to remove genes whose metadata is mis-matched across samples, you can set strictMatch = TRUE which will remove the offending genes from all samples. This is often a very small number of genes so it is unlikely to affect your analysis either way. seRNA &lt;- import10xFeatureMatrix( input = rnaFiles, names = names(rnaFiles), strictMatch = TRUE ) ## Importing Feature Matrix 1 of 2 ## Merging individual RNA objects... ## ## Merging pbmc_unsorted_3k ## Importing Feature Matrix 2 of 2 ## Warning in import10xFeatureMatrix(input = rnaFiles, names = names(rnaFiles), : These features had no interval present and were given a fake GRanges location on `chrNA`: ## ## MT-ND1,MT-ND2,MT-CO1,MT-CO2,MT-ATP8,MT-ATP6,MT-CO3,MT-ND3,MT-ND4L,MT-ND4,MT-ND5,MT-ND6,MT-CYB ## ## Either modify the output SE or see `features` input to use a reference GRanges to add to these features! In this tutorial data, there actually aren’t any examples of this transcript-level metadata mismatch. But if there were, ArchR would output warnings to tell you about the genes that were being excluded or coerced. However, what you do see is a warning that some of the features (genes) did not have an “interval” (or genomic location) present in the 10x input file. This is most frequently the case for genes encoded on the mitochondrial DNA but could in theory happen for other genes in other species as well. This causes problems for ArchR because we assume that every gene has a position in the genome. To get around this problem, ArchR will default to assigning these genes a fake genomic position on “chrNA”. All of these genes will then get excluded from downstream analyses. If you want to rescue these genes, then you must provide this information via the features parameter. This is most easily done using an Ensembl database object from BioConductor. The below code assumes that you have installed the EnsDb.Hsapiens.v86 package from BioConductor. if (!requireNamespace(&quot;EnsDb.Hsapiens.v86&quot;, quietly = TRUE)) { BiocManager::install(&quot;EnsDb.Hsapiens.v86&quot;, update = FALSE) } library(EnsDb.Hsapiens.v86) ## Loading required package: ensembldb ## Loading required package: AnnotationFilter ## ## Attaching package: &#39;AnnotationFilter&#39; ## The following object is masked from &#39;package:magrittr&#39;: ## ## not ## ## Attaching package: &#39;ensembldb&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## filter seRNA &lt;- import10xFeatureMatrix( input = rnaFiles, names = names(rnaFiles), strictMatch = TRUE, features = genes(EnsDb.Hsapiens.v86) ) ## Importing Feature Matrix 1 of 2 ## Correcting missing intervals... ## Merging individual RNA objects... ## ## Merging pbmc_unsorted_3k ## Importing Feature Matrix 2 of 2 ## Correcting missing intervals... After supplying the genes to the features param, you can see that all of the genes encoded on the mitochondrial genome are rescued. The next thing that we want to do is add this scRNA-seq data to our ArchRProject via the addGeneExpressionMatrix() function. However, there is some tidying up that we need to do before we are ready to do that. Inherent in how the multiomic data is generated, you will likely have cells that pass scRNA-seq quality control but not scATAC-seq quality control and vice versa. This can cause problems downstream with other ArchR functions that expect every cell to have every data type. For example, if you were to add gene expression data for only a subset of cells and then try to perform addIterativeLSI() on the corresponding GeneExpressionMatrix, ArchR would not know what to do with the cells that were missing data in the GeneExpressionMatrix. Because our ArchRProject is anchored in the scATAC-seq data, we first check to see how many cells in our project (the ones that have passed scATAC-seq quality control) are not also in our scRNA-seq data length(which(getCellNames(projMulti1) %ni% colnames(seRNA))) ## [1] 119 Though not many cells in this case, we need to remove these cells from our project before proceeding. We do this using the subsetArchRProject() function and saving this as a new ArchRProject called projMulti2. Again, this removal isn’t explicitly necessary but there are downstream ArchR functions that could break if all cells dont have both data types so the safest thing to do is remove them. cellsToKeep &lt;- which(getCellNames(projMulti1) %in% colnames(seRNA)) projMulti2 &lt;- subsetArchRProject(ArchRProj = projMulti1, cells = getCellNames(projMulti1)[cellsToKeep], outputDirectory = &quot;Save-ProjMulti2&quot;, force = TRUE) ## Copying ArchRProject to new outputDirectory : /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjMulti2 ## Copying Arrow Files... ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## Copying Other Files... ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## Finally, we are ready to add the gene expression data to our project. You’ll notice here another parameter called strictMatch. When strictMatch = TRUE, this will ensure that all cells in the ArchRProject are also represented in the seRNA object. This is a nice fail-safe to make sure that the above project subsetting went smoothly. If strictMatch = FALSE (the default), then this function will merely throw a warning telling you that not all of your cells have scRNA-seq information and that this could cause problems downstream. projMulti2 &lt;- addGeneExpressionMatrix(input = projMulti2, seRNA = seRNA, strictMatch = TRUE, force = TRUE) ## ArchR logging to : ArchRLogs/ArchR-addGeneExpressionMatrix-936437d2-Date-2025-02-06_Time-03-40-14.18066.log ## If there is an issue, please report to github with logFile! ## Overlap w/ scATAC = 1 ## 2025-02-06 03:40:14.741087 : ## Overlap Per Sample w/ scATAC : pbmc_sorted_3k=2626,pbmc_unsorted_3k=2845 ## 2025-02-06 03:40:14.755301 : ## 2025-02-06 03:40:16.021819 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneExpressionMatrix-936437d2-Date-2025-02-06_Time-03-40-14.18066.log The last thing that we will do during this project setup phase is filter out any doublets. projMulti2 &lt;- addDoubletScores(projMulti2, force = TRUE) ## ArchR logging to : ArchRLogs/ArchR-addDoubletScores-95eccb65e-Date-2025-02-06_Time-03-42-52.270117.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:42:52.703694 : Batch Execution w/ safelapply!, 0 mins elapsed. ## 2025-02-06 03:42:52.726859 : pbmc_sorted_3k (1 of 2) : Computing Doublet Statistics, 0 mins elapsed. ## pbmc_sorted_3k (1 of 2) : UMAP Projection R^2 = 0.99786 ## pbmc_sorted_3k (1 of 2) : UMAP Projection R^2 = 0.99786 ## 2025-02-06 03:45:40.92925 : pbmc_unsorted_3k (2 of 2) : Computing Doublet Statistics, 2.804 mins elapsed. ## pbmc_unsorted_3k (2 of 2) : UMAP Projection R^2 = 0.99594 ## pbmc_unsorted_3k (2 of 2) : UMAP Projection R^2 = 0.99594 ## ArchR logging successful to : ArchRLogs/ArchR-addDoubletScores-95eccb65e-Date-2025-02-06_Time-03-42-52.270117.log projMulti2 &lt;- filterDoublets(projMulti2) ## Filtering 148 cells from ArchRProject! ## pbmc_unsorted_3k : 80 of 2845 (2.8%) ## pbmc_sorted_3k : 68 of 2626 (2.6%) "],["analysis-of-multiome-data-in-archr.html", "21.2 Analysis of multiome data in ArchR", " 21.2 Analysis of multiome data in ArchR With our multiome project created, we’re now ready to start analysis. It is worth mentioning that the analyses below aren’t altogether different from the analyses presented in the rest of this manual. Because of the inclusion of gene scores, ArchR was already performing analyses that leveraged gene-level information and scATAC-seq information. The primary difference between ATAC-only analysis and multiomic analysis is that we are using the GeneExpressionMatrix instead of the GeneScoreMatrix. The first thing we will do is perform dimensionality reduction using addIterativeLSI(). We can do this on the scATAC-seq data via the TileMatrix and on the scRNA-seq data via the GeneExpressionMatrix. projMulti2 &lt;- addIterativeLSI( ArchRProj = projMulti2, clusterParams = list( resolution = 0.2, sampleCells = 10000, n.start = 10 ), saveIterations = FALSE, useMatrix = &quot;TileMatrix&quot;, depthCol = &quot;nFrags&quot;, name = &quot;LSI_ATAC&quot; ) ## Checking Inputs... ## ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-963a5675f-Date-2025-02-06_Time-03-48-11.040714.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:48:12.941967 : Computing Total Across All Features, 0.019 mins elapsed. ## 2025-02-06 03:48:14.967981 : Computing Top Features, 0.053 mins elapsed. ## ########### ## 2025-02-06 03:48:16.617515 : Running LSI (1 of 2) on Top Features, 0.08 mins elapsed. ## ########### ## 2025-02-06 03:48:16.635495 : Creating Partial Matrix, 0.08 mins elapsed. ## 2025-02-06 03:48:29.907606 : Computing LSI, 0.302 mins elapsed. ## 2025-02-06 03:49:12.988642 : Identifying Clusters, 1.02 mins elapsed. ## 2025-02-06 03:49:39.474452 : Identified 5 Clusters, 1.461 mins elapsed. ## 2025-02-06 03:49:39.504991 : Creating Cluster Matrix on the total Group Features, 1.462 mins elapsed. ## 2025-02-06 03:50:14.790914 : Computing Variable Features, 2.05 mins elapsed. ## ########### ## 2025-02-06 03:50:14.896647 : Running LSI (2 of 2) on Variable Features, 2.051 mins elapsed. ## ########### ## 2025-02-06 03:50:14.916993 : Creating Partial Matrix, 2.052 mins elapsed. ## 2025-02-06 03:50:29.223764 : Computing LSI, 2.29 mins elapsed. ## 2025-02-06 03:50:59.709546 : Finished Running IterativeLSI, 2.798 mins elapsed. projMulti2 &lt;- addIterativeLSI( ArchRProj = projMulti2, clusterParams = list( resolution = 0.2, sampleCells = 10000, n.start = 10 ), saveIterations = FALSE, useMatrix = &quot;GeneExpressionMatrix&quot;, depthCol = &quot;Gex_nUMI&quot;, varFeatures = 2500, firstSelection = &quot;variable&quot;, binarize = FALSE, name = &quot;LSI_RNA&quot; ) ## Checking Inputs... ## ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-966297cf7-Date-2025-02-06_Time-03-50-59.736587.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:51:01.644262 : Computing Variability Across All Features, 0.02 mins elapsed. ## 2025-02-06 03:51:03.96835 : Computing Variable Features, 0.058 mins elapsed. ## ########### ## 2025-02-06 03:51:07.056315 : Running LSI (1 of 2) on Top Features, 0.11 mins elapsed. ## ########### ## 2025-02-06 03:51:07.074664 : Creating Partial Matrix, 0.11 mins elapsed. ## 2025-02-06 03:51:12.43333 : Computing LSI, 0.199 mins elapsed. ## 2025-02-06 03:51:31.534792 : Identifying Clusters, 0.518 mins elapsed. ## 2025-02-06 03:51:57.528274 : Identified 8 Clusters, 0.951 mins elapsed. ## 2025-02-06 03:51:57.557746 : Creating Cluster Matrix on the total Group Features, 0.952 mins elapsed. ## 2025-02-06 03:52:33.006265 : Computing Variable Features, 1.542 mins elapsed. ## ########### ## 2025-02-06 03:52:33.052432 : Running LSI (2 of 2) on Variable Features, 1.543 mins elapsed. ## ########### ## 2025-02-06 03:52:33.077571 : Creating Partial Matrix, 1.544 mins elapsed. ## 2025-02-06 03:52:38.518207 : Computing LSI, 1.634 mins elapsed. ## 2025-02-06 03:52:57.807005 : Finished Running IterativeLSI, 1.956 mins elapsed. We can also create a dimensionality reduction that uses information from both the scATAC-seq and scRNA-seq data. We will name this reducedDims object “LSI_Combined”. projMulti2 &lt;- addCombinedDims(projMulti2, reducedDims = c(&quot;LSI_ATAC&quot;, &quot;LSI_RNA&quot;), name = &quot;LSI_Combined&quot;) We can create UMAP embeddings for each of these dimensionality reductions. projMulti2 &lt;- addUMAP(projMulti2, reducedDims = &quot;LSI_ATAC&quot;, name = &quot;UMAP_ATAC&quot;, minDist = 0.8, force = TRUE) ## 03:52:57 UMAP embedding parameters a = 0.2321 b = 1.681 ## 03:52:57 Read 5323 rows and found 30 numeric columns ## 03:52:57 Using Annoy for neighbor search, n_neighbors = 40 ## 03:52:57 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 03:52:58 Writing NN index file to temp file /tmp/RtmpCdKDaq/file9602e5435 ## 03:52:58 Searching Annoy index using 12 threads, search_k = 4000 ## 03:52:58 Annoy recall = 100% ## 03:53:01 Commencing smooth kNN distance calibration using 12 threads with target n_neighbors = 40 ## 03:53:02 Initializing from normalized Laplacian + noise (using RSpectra) ## 03:53:02 Commencing optimization for 500 epochs, with 303684 positive edges ## 03:53:08 Optimization finished ## 03:53:08 Creating temp model dir /tmp/RtmpCdKDaq/dir975298d03 ## 03:53:08 Creating dir /tmp/RtmpCdKDaq/dir975298d03 ## 03:53:28 Changing to /tmp/RtmpCdKDaq/dir975298d03 ## 03:53:28 Creating /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjMulti2/Embeddings/Save-Uwot-UMAP-Params-LSI_ATAC-979ae2cf1-Date-2025-02-06_Time-03-53-08.893336.tar projMulti2 &lt;- addUMAP(projMulti2, reducedDims = &quot;LSI_RNA&quot;, name = &quot;UMAP_RNA&quot;, minDist = 0.8, force = TRUE) ## 03:53:30 UMAP embedding parameters a = 0.2321 b = 1.681 ## 03:53:30 Read 5323 rows and found 30 numeric columns ## 03:53:30 Using Annoy for neighbor search, n_neighbors = 40 ## 03:53:30 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 03:53:30 Writing NN index file to temp file /tmp/RtmpCdKDaq/file963928c07 ## 03:53:30 Searching Annoy index using 12 threads, search_k = 4000 ## 03:53:30 Annoy recall = 100% ## 03:53:31 Commencing smooth kNN distance calibration using 12 threads with target n_neighbors = 40 ## 03:53:34 Initializing from normalized Laplacian + noise (using RSpectra) ## 03:53:34 Commencing optimization for 500 epochs, with 296148 positive edges ## 03:53:41 Optimization finished ## 03:53:41 Creating temp model dir /tmp/RtmpCdKDaq/dir9d2360c0 ## 03:53:41 Creating dir /tmp/RtmpCdKDaq/dir9d2360c0 ## 03:53:59 Changing to /tmp/RtmpCdKDaq/dir9d2360c0 ## 03:53:59 Creating /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjMulti2/Embeddings/Save-Uwot-UMAP-Params-LSI_RNA-94663e4c9-Date-2025-02-06_Time-03-53-41.353109.tar projMulti2 &lt;- addUMAP(projMulti2, reducedDims = &quot;LSI_Combined&quot;, name = &quot;UMAP_Combined&quot;, minDist = 0.8, force = TRUE) ## 03:53:59 UMAP embedding parameters a = 0.2321 b = 1.681 ## 03:53:59 Read 5323 rows and found 60 numeric columns ## 03:53:59 Using Annoy for neighbor search, n_neighbors = 40 ## 03:53:59 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 03:54:00 Writing NN index file to temp file /tmp/RtmpCdKDaq/file9425f4266 ## 03:54:00 Searching Annoy index using 12 threads, search_k = 4000 ## 03:54:00 Annoy recall = 100% ## 03:54:03 Commencing smooth kNN distance calibration using 12 threads with target n_neighbors = 40 ## 03:54:05 Initializing from normalized Laplacian + noise (using RSpectra) ## 03:54:06 Commencing optimization for 500 epochs, with 301884 positive edges ## 03:54:12 Optimization finished ## 03:54:12 Creating temp model dir /tmp/RtmpCdKDaq/dir93527d07d ## 03:54:12 Creating dir /tmp/RtmpCdKDaq/dir93527d07d ## 03:54:29 Changing to /tmp/RtmpCdKDaq/dir93527d07d ## 03:54:29 Creating /workspace/ArchR/ArchR_Website_Testing/bookdown/Save-ProjMulti2/Embeddings/Save-Uwot-UMAP-Params-LSI_Combined-9450dfff8-Date-2025-02-06_Time-03-54-12.902206.tar And then call clusters for each. projMulti2 &lt;- addClusters(projMulti2, reducedDims = &quot;LSI_ATAC&quot;, name = &quot;Clusters_ATAC&quot;, resolution = 0.4, force = TRUE) ## ArchR logging to : ArchRLogs/ArchR-addClusters-9406ddccd-Date-2025-02-06_Time-03-54-31.229961.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:54:31.906183 : Running Seurats FindClusters (Stuart et al. Cell 2019), 0.001 mins elapsed. ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 5323 ## Number of edges: 232328 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9148 ## Number of communities: 11 ## Elapsed time: 0 seconds ## 2025-02-06 03:54:57.687669 : Testing Biased Clusters, 0.431 mins elapsed. ## 2025-02-06 03:54:57.734341 : Testing Outlier Clusters, 0.432 mins elapsed. ## 2025-02-06 03:54:57.740222 : Assigning Cluster Names to 11 Clusters, 0.432 mins elapsed. ## 2025-02-06 03:54:57.771847 : Finished addClusters, 0.432 mins elapsed. projMulti2 &lt;- addClusters(projMulti2, reducedDims = &quot;LSI_RNA&quot;, name = &quot;Clusters_RNA&quot;, resolution = 0.4, force = TRUE) ## ArchR logging to : ArchRLogs/ArchR-addClusters-92e0f613a-Date-2025-02-06_Time-03-54-57.780312.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:54:58.432856 : Running Seurats FindClusters (Stuart et al. Cell 2019), 0.001 mins elapsed. ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 5323 ## Number of edges: 214403 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9122 ## Number of communities: 11 ## Elapsed time: 0 seconds ## 2025-02-06 03:55:23.552224 : Testing Biased Clusters, 0.419 mins elapsed. ## 2025-02-06 03:55:23.568193 : Testing Outlier Clusters, 0.42 mins elapsed. ## 2025-02-06 03:55:23.574057 : Assigning Cluster Names to 11 Clusters, 0.42 mins elapsed. ## 2025-02-06 03:55:23.60245 : Finished addClusters, 0.42 mins elapsed. projMulti2 &lt;- addClusters(projMulti2, reducedDims = &quot;LSI_Combined&quot;, name = &quot;Clusters_Combined&quot;, resolution = 0.4, force = TRUE) ## ArchR logging to : ArchRLogs/ArchR-addClusters-95d77b92e-Date-2025-02-06_Time-03-55-23.610747.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 03:55:24.24496 : Running Seurats FindClusters (Stuart et al. Cell 2019), 0.001 mins elapsed. ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 5323 ## Number of edges: 233729 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9241 ## Number of communities: 13 ## Elapsed time: 0 seconds ## 2025-02-06 03:55:49.45903 : Testing Biased Clusters, 0.421 mins elapsed. ## 2025-02-06 03:55:49.475444 : Testing Outlier Clusters, 0.421 mins elapsed. ## 2025-02-06 03:55:49.482584 : Assigning Cluster Names to 13 Clusters, 0.421 mins elapsed. ## 2025-02-06 03:55:49.518816 : Finished addClusters, 0.422 mins elapsed. We can plot how each of these dimensionality reductions look with respect to the clusters called in “LSI_Combined”. p1 &lt;- plotEmbedding(projMulti2, name = &quot;Clusters_Combined&quot;, embedding = &quot;UMAP_ATAC&quot;, size = 1, labelAsFactors=F, labelMeans=F) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9125fa73e-Date-2025-02-06_Time-03-55-49.542472.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9125fa73e-Date-2025-02-06_Time-03-55-49.542472.log p2 &lt;- plotEmbedding(projMulti2, name = &quot;Clusters_Combined&quot;, embedding = &quot;UMAP_RNA&quot;, size = 1, labelAsFactors=F, labelMeans=F) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-95bf8e7f1-Date-2025-02-06_Time-03-55-51.61776.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-95bf8e7f1-Date-2025-02-06_Time-03-55-51.61776.log p3 &lt;- plotEmbedding(projMulti2, name = &quot;Clusters_Combined&quot;, embedding = &quot;UMAP_Combined&quot;, size = 1, labelAsFactors=F, labelMeans=F) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9484f6313-Date-2025-02-06_Time-03-55-53.634987.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9484f6313-Date-2025-02-06_Time-03-55-53.634987.log p &lt;- lapply(list(p1,p2,p3), function(x){ x + guides(color = &quot;none&quot;, fill = &quot;none&quot;) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p)) We can also save this to a PDF file. plotPDF(p1, p2, p3, name = &quot;UMAP-scATAC-scRNA-Combined&quot;, addDOC = FALSE) ## Plotting Ggplot! ## Plotting Ggplot! ## Plotting Ggplot! You’ll notice that there are some differences between the cluster residence of cells in the scATAC-seq space and cells in the scRNA-seq space. We can visualize these differences using a confusion matrix. cM_atac_rna &lt;- confusionMatrix(paste0(projMulti2$Clusters_ATAC), paste0(projMulti2$Clusters_RNA)) cM_atac_rna &lt;- cM_atac_rna / Matrix::rowSums(cM_atac_rna) library(pheatmap) p_atac_rna &lt;- pheatmap::pheatmap( mat = as.matrix(cM_atac_rna), color = paletteContinuous(&quot;whiteBlue&quot;), border_color = &quot;black&quot; ) p_atac_rna Nearly all of the operations that you will want to do downstream are equivalent to what is shown throughout the manual for the scATAC-seq-only analyses so we wont go into them here. As an example, to get peak-to-gene links from multiome data, we could use the following code. pathToMacs2 &lt;- findMacs2() ## Searching For MACS2.. ## Found with $PATH at /usr/local/bin/macs2 projMulti2 &lt;- addGroupCoverages(ArchRProj = projMulti2, groupBy = &quot;Clusters_Combined&quot;, verbose = FALSE) ## ArchR logging to : ArchRLogs/ArchR-addGroupCoverages-915f0d6b1-Date-2025-02-06_Time-03-56-03.619249.log ## If there is an issue, please report to github with logFile! ## C1 (1 of 13) : CellGroups N = 2 ## C2 (2 of 13) : CellGroups N = 2 ## C3 (3 of 13) : CellGroups N = 2 ## C4 (4 of 13) : CellGroups N = 2 ## C5 (5 of 13) : CellGroups N = 2 ## C6 (6 of 13) : CellGroups N = 2 ## C7 (7 of 13) : CellGroups N = 2 ## C8 (8 of 13) : CellGroups N = 2 ## C9 (9 of 13) : CellGroups N = 2 ## C10 (10 of 13) : CellGroups N = 2 ## C11 (11 of 13) : CellGroups N = 2 ## C12 (12 of 13) : CellGroups N = 2 ## C13 (13 of 13) : CellGroups N = 2 ## 2025-02-06 03:56:16.514205 : Creating Coverage Files!, 0.215 mins elapsed. ## 2025-02-06 03:56:16.515878 : Batch Execution w/ safelapply!, 0.215 mins elapsed. ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 47 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 125 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 120 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 304 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 286 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 185 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 226 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 192 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 100 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 95 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 41 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 45 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 286 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 340 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 40 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 500 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## Number of Cells = 67 ## Coverage File Exists! ## Added Coverage Group ## Added Metadata Group ## Added ArrowCoverage Class ## Added Coverage/Info ## Added Coverage/Info/CellNames ## 2025-02-06 04:30:17.554117 : Adding Kmer Bias to Coverage Files!, 34.232 mins elapsed. ## Completed Kmer Bias Calculation ## Adding Kmer Bias (1 of 26) ## Adding Kmer Bias (2 of 26) ## Adding Kmer Bias (3 of 26) ## Adding Kmer Bias (4 of 26) ## Adding Kmer Bias (5 of 26) ## Adding Kmer Bias (6 of 26) ## Adding Kmer Bias (7 of 26) ## Adding Kmer Bias (8 of 26) ## Adding Kmer Bias (9 of 26) ## Adding Kmer Bias (10 of 26) ## Adding Kmer Bias (11 of 26) ## Adding Kmer Bias (12 of 26) ## Adding Kmer Bias (13 of 26) ## Adding Kmer Bias (14 of 26) ## Adding Kmer Bias (15 of 26) ## Adding Kmer Bias (16 of 26) ## Adding Kmer Bias (17 of 26) ## Adding Kmer Bias (18 of 26) ## Adding Kmer Bias (19 of 26) ## Adding Kmer Bias (20 of 26) ## Adding Kmer Bias (21 of 26) ## Adding Kmer Bias (22 of 26) ## Adding Kmer Bias (23 of 26) ## Adding Kmer Bias (24 of 26) ## Adding Kmer Bias (25 of 26) ## Adding Kmer Bias (26 of 26) ## 2025-02-06 04:35:25.79768 : Finished Creation of Coverage Files!, 39.37 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGroupCoverages-915f0d6b1-Date-2025-02-06_Time-03-56-03.619249.log # projMulti2 &lt;- addReproduciblePeakSet(ArchRProj = projMulti2, groupBy = &quot;Clusters_Combined&quot;, pathToMacs2 = &quot;/corces/home/rcorces/tools/python/p3.8.5/bin/macs2&quot;) projMulti2 &lt;- addReproduciblePeakSet(ArchRProj = projMulti2, groupBy = &quot;Clusters_Combined&quot;, pathToMacs2 = pathToMacs2) ## ArchR logging to : ArchRLogs/ArchR-addReproduciblePeakSet-959b528b2-Date-2025-02-06_Time-04-35-26.047577.log ## If there is an issue, please report to github with logFile! ## Calling Peaks with Macs2 ## 2025-02-06 04:35:26.635384 : Peak Calling Parameters!, 0.01 mins elapsed. ## Group nCells nCellsUsed nReplicates nMin nMax maxPeaks ## C1 C1 50 50 2 40 40 25000 ## C2 C2 87 87 2 40 47 43500 ## C3 C3 245 245 2 120 125 122500 ## C4 C4 959 804 2 304 500 150000 ## C5 C5 567 540 2 40 500 150000 ## C6 C6 471 471 2 185 286 150000 ## C7 C7 418 418 2 192 226 150000 ## C8 C8 195 195 2 95 100 97500 ## C9 C9 81 81 2 40 41 40500 ## C10 C10 798 545 2 45 500 150000 ## C11 C11 326 326 2 40 286 150000 ## C12 C12 380 380 2 40 340 150000 ## C13 C13 746 567 2 67 500 150000 ## 2025-02-06 04:35:26.676293 : Batching Peak Calls!, 0.01 mins elapsed. ## 2025-02-06 04:35:26.835947 : Batch Execution w/ safelapply!, 0 mins elapsed. ## 2025-02-06 04:37:32.291989 : Identifying Reproducible Peaks!, 2.104 mins elapsed. ## 2025-02-06 04:37:43.557129 : Creating Union Peak Set!, 2.292 mins elapsed. ## Converged after 9 iterations! ## Plotting Ggplot! ## 2025-02-06 04:37:51.701386 : Finished Creating Union Peak Set (165313)!, 2.428 mins elapsed. projMulti2 &lt;- addPeakMatrix(ArchRProj = projMulti2) ## ArchR logging to : ArchRLogs/ArchR-addPeakMatrix-9761f2ae6-Date-2025-02-06_Time-04-37-51.709274.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 04:37:51.917238 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeakMatrix-9761f2ae6-Date-2025-02-06_Time-04-37-51.709274.log projMulti2 &lt;- addPeak2GeneLinks(ArchRProj = projMulti2, reducedDims = &quot;LSI_Combined&quot;, useMatrix = &quot;GeneExpressionMatrix&quot;) ## ArchR logging to : ArchRLogs/ArchR-addPeak2GeneLinks-9536355a3-Date-2025-02-06_Time-04-40-28.409441.log ## If there is an issue, please report to github with logFile! ## 2025-02-06 04:40:28.911077 : Getting Available Matrices, 0.008 mins elapsed. ## 2025-02-06 04:40:30.928312 : Filtered Low Prediction Score Cells (0 of 5471, 0), 0.011 mins elapsed. ## 2025-02-06 04:40:31.291405 : Computing KNN, 0.017 mins elapsed. ## 2025-02-06 04:40:31.337867 : Identifying Non-Overlapping KNN pairs, 0.018 mins elapsed. ## 2025-02-06 04:40:32.736373 : Identified 478 Groupings!, 0.042 mins elapsed. ## 2025-02-06 04:40:32.7689 : Getting Group RNA Matrix, 0.042 mins elapsed. ## 2025-02-06 04:41:18.78523 : Getting Group ATAC Matrix, 0.809 mins elapsed. ## 2025-02-06 04:42:14.555358 : Normalizing Group Matrices, 1.739 mins elapsed. ## 2025-02-06 04:42:19.923677 : Finding Peak Gene Pairings, 1.828 mins elapsed. ## 2025-02-06 04:42:20.382133 : Computing Correlations, 1.836 mins elapsed. ## 2025-02-06 04:42:37.464255 : Completed Peak2Gene Correlations!, 2.12 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeak2GeneLinks-9536355a3-Date-2025-02-06_Time-04-40-28.409441.log p2g &lt;- getPeak2GeneLinks(ArchRProj = projMulti2) p2g[[1]] ## Ranges object with 104942 ranges and 2 metadata columns: ## seqnames ranges strand | value FDR ## &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; ## [1] chr1 817339-998050 * | 0.512265 3.39968e-32 ## [2] chr1 817339-999980 * | 0.510469 6.10720e-32 ## [3] chr1 817339-1001137 * | 0.635300 6.58780e-54 ## [4] chr1 827597-844123 * | 0.555816 7.50792e-39 ## [5] chr1 827597-844646 * | 0.501037 1.24559e-30 ## ... ... ... ... . ... ... ## [104938] chrX 154801020-154805396 * | 0.774004 1.65154e-94 ## [104939] chrX 154805396-155027877 * | 0.470255 1.24530e-26 ## [104940] chrX 154886348-155026818 * | 0.481967 4.18165e-28 ## [104941] chrX 155611508-155612876 * | 0.556690 5.39159e-39 ## [104942] chrX 155612876-155841532 * | 0.533240 2.80429e-35 ## ------- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths There are, of course, some aspects of the analysis which you should tweak when using multiome data. One such example is the bias argument to getMarkerFeatures() which can be tweaked to account for both scATAC-seq data quality (\"TSSEnrichment) and read depth for both assays (\"log10(nFrags)\" for scATAC-seq and \"log10(Gex_nUMI)\" for scRNA-seq). se &lt;- getMarkerFeatures(ArchRProj = projMulti2, groupBy = &quot;Clusters_Combined&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;, &quot;log10(Gex_nUMI)&quot;)) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-919c73a6d-Date-2025-02-06_Time-04-42-37.719909.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Double.Matrix ## 2025-02-06 04:42:36.322358 : Matching Known Biases, 0.004 mins elapsed. ## ########### ## 2025-02-06 04:46:33.377304 : Completed Pairwise Tests, 3.955 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-919c73a6d-Date-2025-02-06_Time-04-42-37.719909.log heatmap_gex &lt;- plotMarkerHeatmap( seMarker = se, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 2&quot;, nLabel = 4, transpose = TRUE ) ## ArchR logging to : ArchRLogs/ArchR-plotMarkerHeatmap-9605c8832-Date-2025-02-06_Time-04-46-33.531656.log ## If there is an issue, please report to github with logFile! ## Printing Top Marker Genes: ## C1: ## MIR6729, LRRC38, TSPAN1, FAAH, TTC39A, TTC39A-AS1, LINC01725, LINC01356, HAO2, LCE3A, SLC9C2, LAD1, VASH2, CDC42BPA, TRIM67 ## C2: ## FAM87B, CLDN19, FCER1A, PACERR, SHISA4, TGFB2-AS1, OR2G3, OR13G1, LINC00842, GPRIN2, VSTM4, DRGX, SLC18A2, NTF3, ADCY6 ## C3: ## MIR6728, NPPA-AS1, TMEM51, C1orf195, IGSF21, LINC01355, ELAVL4, PALMD, LINC01397, RPTN, TNFSF18, BECN2, TMEM26-AS1, LIPK, RBP4 ## C4: ## PADI2, PADI3, MIR3972, PADI6, CDA, LINC01226, MIR1262, MIR378G, CASQ2, LINC00622, ZNF697, PRR9, S100A9, S100A8, OR10K1 ## C5: ## MIR4684, PTGFR, LINC01649, PGLYRP4, CRP, SEC16B, MYBPH, LINC00836, MBL2, LOC101929234, CYP2C19, RPEL1, PNLIPRP3, CLRN3, OR52B2 ## C6: ## LINC01346, PLA2G2D, LINC01141, ALPL, HPCA, GRIK3, MIR4255, LINC01343, BEND5, ROR1, SLC44A5, CYR61, LRRC39, NTNG1, KCND3 ## C7: ## GLIS1, BRDT, EPHX4, VCAM1, GAS5-AS1, FGFR2, KRTAP5-2, FZD4, CADM1, PZP, IFNG, LINC00944, MIR548AR, MIR4502, LOC101928417 ## C8: ## TAS1R2, C8A, C8B, IL23R, IL12RB2, VANGL1, PDZK1, CD160, SH2D1B, LOC100505795, MIR557, XCL1, C1orf21, LGR6, SOX13 ## C9: ## FAM87B, LINC01346, MIR6728, NPPA-AS1, MIR6729, LRRC38, TMEM51-AS1, TMEM51, C1orf195, PADI2, PADI3, MIR3972, PADI4, PADI6, IGSF21 ## C10: ## LOC105755953, TCERG1L-AS1, CABS1, NAP1L3, FAM87B, LINC01346, MIR6728, NPPA-AS1, MIR6729, LRRC38, TMEM51-AS1, TMEM51, C1orf195, PADI2, PADI3 ## C11: ## OR2T4, KLRC1, KRT72, LINC00517, STRA6, CPEB1, SNTG2, LOC100144595, BIRC7, MIR3196, KRTAP12-1, ROBO1, ZBED9, CPA5, CD8A ## C12: ## MIR4794, MIR675, KRT3, MKRN3, MIR4508, KRT34, MYCNOS, LOC100507600, MIR375, DNAJB8, BPESC1, SLC6A18, MAGI2-AS3, LOC389602, C9orf135-DT ## C13: ## THRSP, MIR203A, NTRK3-AS1, LINC00852, SNORD123, SNHG18, FAM87B, LINC01346, MIR6728, NPPA-AS1, MIR6729, LRRC38, TMEM51-AS1, TMEM51, C1orf195 ## Identified 1260 markers! ## [1] &quot;MIR6729&quot; &quot;LRRC38&quot; &quot;TSPAN1&quot; &quot;FAAH&quot; &quot;FAM87B&quot; ## [6] &quot;CLDN19&quot; &quot;FCER1A&quot; &quot;PACERR&quot; &quot;MIR6728&quot; &quot;NPPA-AS1&quot; ## [11] &quot;TMEM51&quot; &quot;C1orf195&quot; &quot;PADI2&quot; &quot;PADI3&quot; &quot;MIR3972&quot; ## [16] &quot;PADI6&quot; &quot;MIR4684&quot; &quot;PTGFR&quot; &quot;LINC01649&quot; &quot;PGLYRP4&quot; ## [21] &quot;LINC01346&quot; &quot;PLA2G2D&quot; &quot;LINC01141&quot; &quot;ALPL&quot; &quot;GLIS1&quot; ## [26] &quot;BRDT&quot; &quot;EPHX4&quot; &quot;VCAM1&quot; &quot;TAS1R2&quot; &quot;C8A&quot; ## [31] &quot;C8B&quot; &quot;IL23R&quot; &quot;LOC105755953&quot; &quot;TCERG1L-AS1&quot; &quot;CABS1&quot; ## [36] &quot;NAP1L3&quot; &quot;OR2T4&quot; &quot;KLRC1&quot; &quot;KRT72&quot; &quot;LINC00517&quot; ## [41] &quot;MIR4794&quot; &quot;MIR675&quot; &quot;KRT3&quot; &quot;MKRN3&quot; &quot;THRSP&quot; ## [46] &quot;MIR203A&quot; &quot;NTRK3-AS1&quot; &quot;LINC00852&quot; ## Adding Annotations.. ## Preparing Main Heatmap.. ## &#39;magick&#39; package is suggested to install to give better rasterization. ## ## Set `ht_opt$message = FALSE` to turn off this message. ## ArchR logging successful to : ArchRLogs/ArchR-plotMarkerHeatmap-9605c8832-Date-2025-02-06_Time-04-46-33.531656.log draw(heatmap_gex, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) Lastly, we will save this project for future reference. projMulti2 &lt;- saveArchRProject(ArchRProj = projMulti2, outputDirectory = &quot;Save-ProjMulti2&quot;, overwrite = TRUE, load = TRUE) ## Saving ArchRProject... ## Loading ArchRProject... ## Successfully loaded ArchRProject! ## ## / | ## / \\ ## . / |. ## \\\\\\ / |. ## \\\\\\ / `|. ## \\\\\\ / |. ## \\ / |\\ ## \\\\#####\\ / || ## ==###########&gt; / || ## \\\\##==......\\ / || ## ______ = =|__ /__ || \\\\\\ ## ,--&#39; ,----`-,__ ___/&#39; --,-`-===================##========&gt; ## \\ &#39; ##_______ _____ ,--,__,=##,__ /// ## , __== ___,-,__,--&#39;#&#39; ===&#39; `-&#39; | ##,-/ ## -,____,---&#39; \\\\####\\\\________________,--\\\\_##,/ ## ___ .______ ______ __ __ .______ ## / \\ | _ \\ / || | | | | _ \\ ## / ^ \\ | |_) | | ,----&#39;| |__| | | |_) | ## / /_\\ \\ | / | | | __ | | / ## / _____ \\ | |\\ \\\\___ | `----.| | | | | |\\ \\\\___. ## /__/ \\__\\ | _| `._____| \\______||__| |__| | _| `._____| ## "],["plot-aesthetics-in-archr.html", "Chapter 22 Plot aesthetics in ArchR", " Chapter 22 Plot aesthetics in ArchR Making useful and interpretable plots is one of the key goals of ArchR. We have done our best to make sensible defaults and to make a collection of aesthetically appealing color palettes available to users. However, we also want to make it possible to change the various default settings and manipulate plot aesthetics to your liking. This chapter provides a basic guide for how to alter these various plot aesthetics. Importantly, ArchR has some base plotting functions that are recurrently used and many other plotting functions in ArchR are just wrappers around these base plotting functions. You can read about each of these individual functions in the “Plotting / aesthetic functions” section of the function documentation page. For example plotEmbedding() is a wrapper around the ggPoint() function (which is a wrapper around ggplot2). Other commonly used plotting wrapper functions in ArchR include ggGroup(), ggHex(), and ggOneToOne(). Often times, when you are using a function such as plotEmbedding(), ArchR allows you to pass arguments through to ggPoint() or ggHex() to manipulate various aspects of plot aesthetics using the ... argument. As a preface to the sections in this chapter, ArchR is not a one-stop-shop for every plot customization you could desire. What you cannot tweak programatically, you will have to tweak “in post” in a vector graphics software such as Adobe Illustrator. The plots output by ArchR often contain complex layers and clipping masks and you should familiarize yourself with those if you plan to edit ArchR output plots by hand. Lastly, ArchR attempts to default to rasterizing plots with many individual points. For example, in an embedding, you could have one point for every cell. If you have tens-of-thousands of cells, this means your plots will have tens-of-thousands of points on them which can be challenging to display and edit. To get around this, ArchR “rasterizes” or “flattens” the plot area while maintaining the rest of the plot elements (text, lines, legend, etc.) as editable vector graphics. "],["using-and-manipulating-palettes-in-archr.html", "22.1 Using and manipulating palettes in ArchR", " 22.1 Using and manipulating palettes in ArchR ArchR provides a list of color palettes that we have used in the past and find aesthetically pleasing. These are stored in an object called ArchRPalettes. If we inspect the first few entries of this object, you can see the general structure of a palette in ArchR. ArchRPalettes[1:3] ## $stallion ## 1 2 3 4 5 6 7 8 ## &quot;#D51F26&quot; &quot;#272E6A&quot; &quot;#208A42&quot; &quot;#89288F&quot; &quot;#F47D2B&quot; &quot;#FEE500&quot; &quot;#8A9FD1&quot; &quot;#C06CAB&quot; ## 19 10 11 12 13 14 15 16 ## &quot;#E6C2DC&quot; &quot;#90D5E4&quot; &quot;#89C75F&quot; &quot;#F37B7D&quot; &quot;#9983BD&quot; &quot;#D24B27&quot; &quot;#3BBCA8&quot; &quot;#6E4B9E&quot; ## 17 18 9 20 ## &quot;#0C727C&quot; &quot;#7E1416&quot; &quot;#D8A767&quot; &quot;#3D3D3D&quot; ## ## $stallion2 ## 1 2 3 4 5 6 7 8 ## &quot;#D51F26&quot; &quot;#272E6A&quot; &quot;#208A42&quot; &quot;#89288F&quot; &quot;#F47D2B&quot; &quot;#FEE500&quot; &quot;#8A9FD1&quot; &quot;#C06CAB&quot; ## 19 10 11 12 13 14 15 16 ## &quot;#E6C2DC&quot; &quot;#90D5E4&quot; &quot;#89C75F&quot; &quot;#F37B7D&quot; &quot;#9983BD&quot; &quot;#D24B27&quot; &quot;#3BBCA8&quot; &quot;#6E4B9E&quot; ## 17 18 9 ## &quot;#0C727C&quot; &quot;#7E1416&quot; &quot;#D8A767&quot; ## ## $calm ## 1 2 3 4 5 6 7 8 ## &quot;#7DD06F&quot; &quot;#844081&quot; &quot;#688EC1&quot; &quot;#C17E73&quot; &quot;#484125&quot; &quot;#6CD3A7&quot; &quot;#597873&quot; &quot;#7B6FD0&quot; ## 9 10 11 12 13 14 15 16 ## &quot;#CF4A31&quot; &quot;#D0CD47&quot; &quot;#722A2D&quot; &quot;#CBC594&quot; &quot;#D19EC4&quot; &quot;#5A7E36&quot; &quot;#D4477D&quot; &quot;#403552&quot; ## 17 18 19 20 ## &quot;#76D73C&quot; &quot;#96CED5&quot; &quot;#CE54D1&quot; &quot;#C48736&quot; From this, you can see that a palette is a named vector where the names are numbers, starting at 1. The rationale for this is that we have tried to optimize these color palettes to optimally distinguish discrete variables. For example, if you have 5 clusters that you want to color, you would want to use the 5 most easily distinguished colors from the color palette rather than using the 5 random colors which may not be optimally distinguished. In this way, the first N entries in each ArchR palette represent the 5 colors that we find to be best for representing N groups. Note that (i) we have not necessarily optimized the color palettes in ArchR to be color blind-friendly though we do provide some options which are in this class of palettes and (ii) if you have more groups than the number of colors in the designated palette, R will be forced to interpolate colors (the largest palette that we provide is 20 colors). In the below examples, we use plotEmbedding() as the example function but the same principles apply to other plotting functions as well. 22.1.1 Using pre-defined ArchR palettes Probably the most confusing aspect of using palettes in ArchR is that some functions that ask for a color palette (for ex. plotEmbedding() or plotTrajectory()) have three parameters that can be manipulated: discreteSet, continuousSet, and pal. Here, discreteSet and continuousSet are used to select pre-defined palettes from ArchRPalettes which are discussed in this section. pal, on the other hand, accepts custom palettes that override the default ArchR palette for a given plot. Certain types of matrices in ArchR have been assigned a default color scheme. For example, if we do not specify a color palette for continuousSet, the default for GeneScoreMatrix will be “horizonExtra” and the default for other types of matrices will be “solarExtra”: plotEmbedding( ArchRProj = projHeme5, embedding = &quot;UMAP&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CD14&quot;, size = 1, sampleCells = NULL, baseSize = 10, plotAs = &quot;points&quot;) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9fe860a5-Date-2025-02-06_Time-04-55-47.562718.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 04:55:49.685178 : ## ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9fe860a5-Date-2025-02-06_Time-04-55-47.562718.log However, we can change the color palette to another pre-defined palette in ArchRPalettes by passing the name of that palette to continuousSet (e.g. “whitePurple”). Note that because this data is continuous data, we must use continuousSet and manipulating discreteSet would have no effect. plotEmbedding( ArchRProj = projHeme5, embedding = &quot;UMAP&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CD14&quot;, continuousSet = &quot;whitePurple&quot;, size = 1, sampleCells = NULL, baseSize = 10, plotAs = &quot;points&quot;) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-915690d0b-Date-2025-02-06_Time-04-55-59.484704.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 04:55:58.982311 : ## ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-915690d0b-Date-2025-02-06_Time-04-55-59.484704.log If instead we are plotting discrete data, for example “Clusters”, the default color scheme will be “stallion”. plotEmbedding( ArchRProj = projHeme5, embedding = &quot;UMAP&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, size = 1, sampleCells = NULL, baseSize = 10, plotAs = &quot;points&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-97e8f20cf-Date-2025-02-06_Time-04-56-06.135397.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-97e8f20cf-Date-2025-02-06_Time-04-56-06.135397.log As above, we can change the color scheme used for this discrete data by passing the name of one of the pre-defined color palettes in ArchRPalettes to discreteSet: plotEmbedding( ArchRProj = projHeme5, embedding = &quot;UMAP&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, discreteSet = &quot;kelly&quot;, size = 1, sampleCells = NULL, baseSize = 10, plotAs = &quot;points&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-94ddeb18b-Date-2025-02-06_Time-04-56-09.338492.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-94ddeb18b-Date-2025-02-06_Time-04-56-09.338492.log 22.1.2 Using custom palettes in ArchR The pal argument allows for the use of custom palettes in most plotting functions. The format of a custom palette is very specific and if you fail to follow this format, it will not work. Effectively, the input to pal must look exactly like the output of paletteDiscrete() for discrete data or paletteContinuous() for continuous data. 22.1.2.1 For discrete data paletteDiscrete(values = projHeme5$Clusters, set = &quot;kelly&quot;) ## C1 C2 C3 C4 C5 C6 C7 C8 ## &quot;#FFB300&quot; &quot;#803E75&quot; &quot;#FF6800&quot; &quot;#A6BDD7&quot; &quot;#C10020&quot; &quot;#CEA262&quot; &quot;#817066&quot; &quot;#007D34&quot; ## C9 C10 C11 C12 ## &quot;#F6768E&quot; &quot;#00538A&quot; &quot;#FF7A5C&quot; &quot;#53377A&quot; Thus for discrete data, you can see that pal needs to be a named vector of colors where each color is named for the corresponding group (e.g. \"C1\" = \"#F97070\"). We can create our own custom palette and pass it to plotEmbedding() to customize the coloration of our clusters: disc_pal &lt;- c( &quot;C1&quot; = &quot;#F97070&quot;, &quot;C2&quot; = &quot;#D60000&quot;, &quot;C3&quot; = &quot;#7F0303&quot;, &quot;C4&quot; = &quot;#F97E2B&quot;, &quot;C5&quot; = &quot;#FFE600&quot;, &quot;C6&quot; = &quot;#7BE561&quot;, &quot;C7&quot; = &quot;#19891E&quot;, &quot;C8&quot; = &quot;#20C4AC&quot;, &quot;C9&quot; = &quot;#83A4FF&quot;, &quot;C10&quot; = &quot;#262C6B&quot;, &quot;C11&quot; = &quot;#7C0EDD&quot;, &quot;C12&quot; = &quot;#DB65D2&quot;) plotEmbedding( ArchRProj = projHeme5, embedding = &quot;UMAP&quot;, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, pal = disc_pal, size = 1, sampleCells = NULL, baseSize = 10, plotAs = &quot;points&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9760e128b-Date-2025-02-06_Time-04-56-12.65299.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9760e128b-Date-2025-02-06_Time-04-56-12.65299.log 22.1.2.2 For continuous data paletteContinuous(set = &quot;comet&quot;, n = 10) ## [1] &quot;#E6E7E8&quot; &quot;#ACCCEF&quot; &quot;#73B1F7&quot; &quot;#3A97FF&quot; &quot;#546CE1&quot; &quot;#6E40C4&quot; &quot;#8816A7&quot; ## [8] &quot;#5A0E6F&quot; &quot;#2D0737&quot; &quot;#000000&quot; Thus for continuous data, you can see that pal is just a vector of colors. You can create this vector however you wish but here is an example: cont_pal &lt;- colorRampPalette(c(&quot;blue&quot;,&quot;white&quot;,&quot;red&quot;)) plotEmbedding( ArchRProj = projHeme5, embedding = &quot;UMAP&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CD14&quot;, pal = cont_pal(256), size = 1, sampleCells = NULL, baseSize = 10, plotAs = &quot;points&quot;) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-9dff6b20-Date-2025-02-06_Time-04-56-16.053137.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values... ## 2025-02-06 04:56:17.87527 : ## ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-9dff6b20-Date-2025-02-06_Time-04-56-16.053137.log "],["testing-your-archr-installation.html", "Chapter 23 Testing Your ArchR Installation", " Chapter 23 Testing Your ArchR Installation To provide a system for testing a wide array of ArchR’s functionalities, we use testthat. This essentially automates testing ArchR functions by running the code present in the examples section of each function. Below is an example workflow for how to do this. These tests are run at the time each new stable release is created, using the version of R and the provided renv lockfile that accompanies each stable release. We would not expect you to encounter errors during this testing process if you are using the suggested version of R and the provided renv environment for the given release. Note that we run these tests outside of RStudio, in the R terminal, because of issues that appear to be related to long file paths that are created during testing. So in our hands, these tests do not work when run in RStudio. Instead, if you navigate to the directory where your renv project was initiated and you launch R, it will automatically load your renv environment and you can run the tests from the terminal. First, we will load ArchR and devtools. library(ArchR) library(devtools) Because we will be creating Arrow Files during this process, we need to ensure that HDF5 file locking is handled correctly. On the system where this code is run to create this manual, we use locking = TRUE but this may be different on your system. See the chapter on Getting Started with ArchR for more information. We will also set our seed here for reproducibility. addArchRLocking(locking = TRUE) set.seed(1) We will start by creating a directory in which to perform all testing. dir_test &lt;- &quot;ArchRTests&quot; dir.create(dir_test, showWarnings = FALSE) Then we will download and unzip the full ArchR package code corresponding to the branch that we want to test. We increase the timeout option to give the system enough time to download the full package. branch &lt;- &quot;dev&quot; options(timeout = 999) download.file(url = paste0(&quot;https://github.com/GreenleafLab/ArchR/archive/refs/heads/&quot;,branch,&quot;.zip&quot;), destfile = file.path(dir_test,paste0(&quot;ArchR-&quot;,branch,&quot;.zip&quot;))) unzip(zipfile = file.path(dir_test,paste0(&quot;ArchR-&quot;,branch,&quot;.zip&quot;)), exdir = dir_test) For reasons that aren’t necessary to explain, we need to remove the configure file from the package directory before starting the tests. file.remove(file.path(dir_test,paste0(&quot;ArchR-&quot;,branch),&quot;configure&quot;)) Lastly, we run devtools::test() to perform all tests. devtools::test(pkg = file.path(dir_test,paste0(&quot;ArchR-&quot;,branch,&quot;/&quot;))) With a working installation of ArchR, one should not encounter any errors during this process. If errors are indeed encountered, please see the chapter on Using renv to manage dependencies for aid in establishing a working environment. "],["session-information.html", "Chapter 24 Session Information", " Chapter 24 Session Information This tutorial was run on the date specified below. ## [1] &quot;2025-02-06&quot; The sessionInfo() at run time was: sessionInfo() ## R version 4.4.1 (2024-06-14) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.5 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## Random number generation: ## RNG: L&#39;Ecuyer-CMRG ## Normal: Inversion ## Sample: Rejection ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] parallel stats4 grid stats graphics grDevices utils ## [8] datasets methods base ## ## other attached packages: ## [1] zlibbioc_1.50.0 ## [2] zip_2.3.1 ## [3] yaml_2.3.10 ## [4] xtable_1.8-4 ## [5] xopen_1.0.1 ## [6] xml2_1.3.6 ## [7] xfun_0.48 ## [8] wk_0.9.4 ## [9] withr_3.0.2 ## [10] whisker_0.4.1 ## [11] warp_0.2.1 ## [12] waldo_0.5.3 ## [13] vroom_1.6.5 ## [14] viridis_0.6.5 ## [15] viridisLite_0.4.2 ## [16] vipor_0.4.7 ## [17] vctrs_0.6.5 ## [18] utf8_1.2.4 ## [19] urlchecker_1.0.1 ## [20] units_0.8-5 ## [21] tzdb_0.4.0 ## [22] tinytex_0.53 ## [23] tidyselect_1.2.1 ## [24] tidyr_1.3.1 ## [25] tibble_3.2.1 ## [26] textshaping_0.4.0 ## [27] testthat_3.2.1.1 ## [28] systemfonts_1.1.0 ## [29] sys_3.4.3 ## [30] stringi_1.8.4 ## [31] statmod_1.5.0 ## [32] speedglm_0.3-5 ## [33] spdep_1.3-6 ## [34] spatstat.utils_3.1-0 ## [35] spatstat.sparse_3.1-0 ## [36] tensor_1.5 ## [37] spatstat.explore_3.3-3 ## [38] spatstat.random_3.3-2 ## [39] spatstat.geom_3.3-3 ## [40] spatstat.univar_3.0-1 ## [41] spatstat.data_3.1-2 ## [42] spatial_7.3-17 ## [43] spam_2.11-0 ## [44] spData_2.3.3 ## [45] sourcetools_0.1.7-1 ## [46] snow_0.4-4 ## [47] slider_0.3.2 ## [48] slam_0.1-54 ## [49] sitmo_2.0.2 ## [50] shiny_1.9.1 ## [51] shape_1.4.6.1 ## [52] sf_1.0-18 ## [53] sessioninfo_1.2.2 ## [54] seqLogo_1.70.0 ## [55] sctransform_0.4.1 ## [56] scattermore_1.2 ## [57] scales_1.3.0 ## [58] sass_0.4.9 ## [59] s2_1.1.7 ## [60] rversions_2.1.2 ## [61] rsvd_1.0.5 ## [62] rstudioapi_0.17.1 ## [63] rsample_1.2.1 ## [64] rprojroot_2.0.4 ## [65] rpart_4.1.23 ## [66] roxygen2_7.3.2 ## [67] rmarkdown_2.28 ## [68] rlang_1.1.4 ## [69] rjson_0.2.23 ## [70] rhdf5filters_1.16.0 ## [71] reticulate_1.39.0 ## [72] restfulr_0.0.15 ## [73] reshape2_1.4.4 ## [74] renv_1.0.11.9000 ## [75] remotes_2.5.0 ## [76] rematch2_2.1.2 ## [77] readr_2.1.5 ## [78] rcmdcheck_1.4.0 ## [79] rappdirs_0.3.3 ## [80] ragg_1.3.3 ## [81] pwalign_1.0.0 ## [82] purrr_1.0.2 ## [83] pscl_1.5.9 ## [84] ps_1.8.1 ## [85] proxy_0.4-27 ## [86] promises_1.3.0 ## [87] progressr_0.15.0 ## [88] progress_1.2.3 ## [89] profvis_0.4.0 ## [90] processx_3.8.4 ## [91] prettyunits_1.2.0 ## [92] praise_1.0.0 ## [93] pracma_2.4.4 ## [94] poweRlaw_0.80.0 ## [95] polyclip_1.10-7 ## [96] png_0.1-8 ## [97] plotly_4.10.4 ## [98] plogr_0.2.0 ## [99] pkgload_1.4.0 ## [100] pkgdown_2.1.1 ## [101] pkgconfig_2.0.3 ## [102] pkgbuild_1.4.5 ## [103] pillar_1.9.0 ## [104] pbmcapply_1.5.1 ## [105] pbapply_1.7-2 ## [106] patchwork_1.3.0 ## [107] parallelly_1.38.0 ## [108] openssl_2.2.2 ## [109] nnet_7.3-19 ## [110] nloptr_2.1.1 ## [111] munsell_0.5.1 ## [112] minqa_1.2.8 ## [113] miniUI_0.1.1.1 ## [114] mime_0.12 ## [115] mgcv_1.9-1 ## [116] nlme_3.1-166 ## [117] metapod_1.12.0 ## [118] memoise_2.0.1 ## [119] locfit_1.5-9.10 ## [120] lmtest_0.9-40 ## [121] zoo_1.8-12 ## [122] lme4_1.1-35.5 ## [123] listenv_0.9.1 ## [124] lifecycle_1.0.4 ## [125] leidenbase_0.1.31 ## [126] leiden_0.4.3.1 ## [127] lazyeval_0.2.2 ## [128] lattice_0.22-6 ## [129] later_1.3.2 ## [130] lambda.r_1.2.4 ## [131] labeling_0.4.3 ## [132] knitr_1.48 ## [133] jsonlite_1.8.9 ## [134] jquerylib_0.1.4 ## [135] isoband_0.2.7 ## [136] irlba_2.3.5.1 ## [137] ini_0.3.1 ## [138] ica_1.0-3 ## [139] httr2_1.0.5 ## [140] httr_1.4.7 ## [141] httpuv_1.6.15 ## [142] htmlwidgets_1.6.4 ## [143] htmltools_0.5.8.1 ## [144] hms_1.1.3 ## [145] highr_0.11 ## [146] here_1.0.1 ## [147] grr_0.9.5 ## [148] gplots_3.2.0 ## [149] goftest_1.2-3 ## [150] glue_1.8.0 ## [151] globals_0.16.3 ## [152] gitcreds_0.1.2 ## [153] gh_1.4.1 ## [154] ggrastr_1.0.2 ## [155] ggbeeswarm_0.7.2 ## [156] gert_2.1.4 ## [157] generics_0.1.3 ## [158] future.apply_1.11.3 ## [159] futile.options_1.0.1 ## [160] futile.logger_1.4.3 ## [161] furrr_0.3.1 ## [162] future_1.34.0 ## [163] fs_1.6.4 ## [164] formatR_1.14 ## [165] foreign_0.8-86 ## [166] fontawesome_0.5.2 ## [167] fitdistrplus_1.2-1 ## [168] survival_3.7-0 ## [169] fastmap_1.2.0 ## [170] fastDummies_1.7.4 ## [171] farver_2.1.2 ## [172] fansi_1.0.6 ## [173] evaluate_1.0.1 ## [174] ellipsis_0.3.2 ## [175] edgeR_4.2.2 ## [176] limma_3.60.6 ## [177] e1071_1.7-16 ## [178] dqrng_0.4.1 ## [179] dplyr_1.1.4 ## [180] downlit_0.4.4 ## [181] dotCall64_1.2 ## [182] doParallel_1.0.17 ## [183] iterators_1.0.14 ## [184] foreach_1.5.2 ## [185] digest_0.6.37 ## [186] diffobj_0.3.5 ## [187] desc_1.4.3 ## [188] deldir_2.0-4 ## [189] curl_5.2.3 ## [190] crosstalk_1.2.1 ## [191] credentials_2.0.2 ## [192] crayon_1.5.3 ## [193] cpp11_0.5.0 ## [194] cowplot_1.1.3 ## [195] commonmark_1.9.2 ## [196] colorspace_2.1-1 ## [197] codetools_0.2-20 ## [198] cluster_2.1.6 ## [199] clue_0.3-65 ## [200] clipr_0.8.0 ## [201] cli_3.6.3 ## [202] classInt_0.4-10 ## [203] class_7.3-22 ## [204] callr_3.7.6 ## [205] cachem_1.1.0 ## [206] caTools_1.18.3 ## [207] bslib_0.8.0 ## [208] brio_1.1.5 ## [209] brew_1.0-10 ## [210] boot_1.3-30 ## [211] bluster_1.14.0 ## [212] blob_1.2.4 ## [213] bitops_1.0-9 ## [214] bit64_4.5.2 ## [215] bit_4.5.0 ## [216] biglm_0.9-3 ## [217] beeswarm_0.4.0 ## [218] beachmat_2.20.0 ## [219] batchelor_1.20.0 ## [220] base64enc_0.1-3 ## [221] assertthat_0.2.1 ## [222] askpass_1.2.1 ## [223] annotate_1.82.0 ## [224] XML_3.99-0.17 ## [225] UCSC.utils_1.0.0 ## [226] TFMPvalue_0.0.9 ## [227] TFBSTools_1.42.0 ## [228] ScaledMatrix_1.12.0 ## [229] Rhtslib_3.0.0 ## [230] RhpcBLASctl_0.23-42 ## [231] Rhdf5lib_1.26.0 ## [232] ResidualMatrix_1.14.1 ## [233] RcppTOML_0.2.2 ## [234] RcppProgress_0.4.2 ## [235] RcppHNSW_0.6.0 ## [236] RcppEigen_0.3.4.0.2 ## [237] RcppAnnoy_0.0.22 ## [238] RSpectra_0.16-2 ## [239] RSQLite_2.3.7 ## [240] ROCR_1.0-11 ## [241] RCurl_1.98-1.16 ## [242] RColorBrewer_1.1-3 ## [243] RANN_2.6.2 ## [244] R6_2.5.1 ## [245] R.utils_2.12.3 ## [246] R.oo_1.26.0 ## [247] R.methodsS3_1.8.2 ## [248] MASS_7.3-61 ## [249] KernSmooth_2.23-24 ## [250] KEGGREST_1.44.1 ## [251] HDF5Array_1.32.1 ## [252] GlobalOptions_0.1.2 ## [253] GetoptLong_1.0.5 ## [254] GenomicAlignments_1.40.0 ## [255] Rsamtools_2.20.0 ## [256] GenomeInfoDbData_1.2.12 ## [257] GO.db_3.19.1 ## [258] FNN_1.1.4.1 ## [259] DirichletMultinomial_1.46.0 ## [260] DelayedMatrixStats_1.26.0 ## [261] DelayedArray_0.30.1 ## [262] SparseArray_1.4.8 ## [263] S4Arrays_1.4.1 ## [264] abind_1.4-8 ## [265] DT_0.33 ## [266] DBI_1.2.3 ## [267] Cairo_1.6-2 ## [268] CNEr_1.40.0 ## [269] BiocVersion_3.19.1 ## [270] BiocSingular_1.20.0 ## [271] BiocParallel_1.38.0 ## [272] BiocNeighbors_1.22.0 ## [273] BiocManager_1.30.25 ## [274] BH_1.84.0-0 ## [275] EnsDb.Hsapiens.v86_2.99.0 ## [276] ensembldb_2.28.1 ## [277] AnnotationFilter_1.28.0 ## [278] BSgenome.Hsapiens.UCSC.hg38_1.4.5 ## [279] slingshot_2.12.0 ## [280] TrajectoryUtils_1.12.0 ## [281] princurve_2.1.6 ## [282] monocle3_1.3.7 ## [283] chromVAR_1.26.0 ## [284] ggseqlogo_0.2 ## [285] chromVARmotifs_0.2.0 ## [286] motifmatchr_1.26.0 ## [287] presto_1.0.0 ## [288] ggrepel_0.9.6 ## [289] hexbin_1.28.4 ## [290] circlize_0.4.16 ## [291] ComplexHeatmap_2.20.0 ## [292] Rtsne_0.17 ## [293] igraph_2.1.1 ## [294] scran_1.32.0 ## [295] scuttle_1.14.0 ## [296] SingleCellExperiment_1.26.0 ## [297] pheatmap_1.0.12 ## [298] harmony_1.2.1 ## [299] uwot_0.2.2 ## [300] ggridges_0.5.6 ## [301] BSgenome.Hsapiens.UCSC.hg19_1.4.3 ## [302] nabor_0.5.0 ## [303] Seurat_5.1.0 ## [304] SeuratObject_5.0.2 ## [305] sp_2.1-4 ## [306] pdftools_3.4.1 ## [307] org.Dm.eg.db_3.19.1 ## [308] TxDb.Dmelanogaster.UCSC.dm6.ensGene_3.12.0 ## [309] GenomicFeatures_1.56.0 ## [310] AnnotationDbi_1.66.0 ## [311] BSgenome.Dmelanogaster.UCSC.dm6_1.4.1 ## [312] BSgenome_1.72.0 ## [313] rtracklayer_1.64.0 ## [314] BiocIO_1.14.0 ## [315] Biostrings_2.72.1 ## [316] XVector_0.44.0 ## [317] rhdf5_2.48.0 ## [318] SummarizedExperiment_1.34.0 ## [319] Biobase_2.64.0 ## [320] RcppArmadillo_14.0.2-1 ## [321] Rcpp_1.0.13 ## [322] Matrix_1.7-1 ## [323] GenomicRanges_1.56.2 ## [324] GenomeInfoDb_1.40.1 ## [325] IRanges_2.38.1 ## [326] S4Vectors_0.42.1 ## [327] BiocGenerics_0.50.0 ## [328] sparseMatrixStats_1.16.0 ## [329] MatrixGenerics_1.16.0 ## [330] matrixStats_1.4.1 ## [331] data.table_1.16.2 ## [332] stringr_1.5.1 ## [333] plyr_1.8.9 ## [334] magrittr_2.0.3 ## [335] ggplot2_3.5.1 ## [336] gtable_0.3.6 ## [337] gtools_3.9.5 ## [338] gridExtra_2.3 ## [339] devtools_2.4.5 ## [340] usethis_3.0.0 ## [341] ArchR_1.0.3 ## ## loaded via a namespace (and not attached): ## [1] ProtGenerics_1.36.0 tools_4.4.1 bookdown_0.41 ## [4] qpdf_1.3.4 splines_4.4.1 compiler_4.4.1 ## [7] svglite_2.1.3 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
