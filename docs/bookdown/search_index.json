[
["index.html", "Chapter 15 - Cellular Trajectory Analysis with ArchR ", " Chapter 15 - Cellular Trajectory Analysis with ArchR Jeffrey Granja and Ryan Corces 2020-04-17 ArchR is a full-featured software suite for the analysis of single-cell chromatin accessibility data. It is designed to handle hundreds of thousands of single cells without large memory or computational requirements, keeping pace with the experimental scale that is achievable with commercial platforms such as the 10x Genomics Chromium system. This website is a complete user’s guide to ArchR. We explain how to use ArchR by walking through examples of every analysis we could think of. We also include some more extensive documention on some of the more salient points of scATAC-seq analysis such as dimensionality reduction and clustering. All of the chapters will utilize the same gold-standard downsampled dataset of hematopoietic cells Granja* et al. Nature Biotechnology 2019. Each chapter will build on the previous and we provide intermediate files for you to jump in at any point. Importantly, these tutorials assume that you are running ArchR locally. This walkthrough assumes that you have already successfully installed ArchR and all dependencies. If that is not the case, please visit the home page for installation instructions. Cant find what you are looking for? There is a search feature that can be enabled using the magnifying glass in the navigation bar above which will help you find whatever it is you are looking for. If you dont find it in this book, or if you think the documentation on this website or in the function annotations is unclear, please submit an issue on Github with the documentation tag and we will do our best to clarify. If none of these options help, send us an email and we will do our best to respond in a timely fashion. "],
["getting-started-with-archr.html", "Chapter 1 Getting Started with ArchR", " Chapter 1 Getting Started with ArchR This chapter will introduce you to how to import data into ArchR and how to create ArrowFiles, the base unit of ArchR analysis. "],
["a-brief-primer-on-atac-seq-terminology.html", "1.1 A Brief Primer on ATAC-seq Terminology", " 1.1 A Brief Primer on ATAC-seq Terminology The most fundamental component of any ATAC-seq experiment is a “fragment”. In ATAC-seq, a fragment refers to a sequenceable DNA molecule created by two transposition events. Each end of that fragment is sequenced using paired-end sequencing. The inferred single-base position of the start and end of the fragment is adjusted based on the insertion offset of Tn5. As reported previously26, Tn5 transposase binds to DNA as a homodimer with 9-bp of DNA between the two Tn5 molecules. Because of this, each Tn5 homodimer binding event creates two insertions, separated by 9 bp. Thus, the actual central point of the “accessible” site is in the very center of the Tn5 dimer, not the location of each Tn5 insertion. To account for this, we apply an offset to the individual Tn5 insertions, adjusting plus-stranded insertion events by +4 bp and minus-stranded insertion events by -5 bp. This is consistent with the convention put forth during the original description of ATAC-seq27. Thus, in ArchR, “fragments” refers to a table or genomic ranges containing the chromosome, offset-adjusted chromosome start position, offset-adjusted chromosome end position, and unique cellular barcode ID corresponding to each sequenced fragment. Similarly, “insertions” refer to the offset-adjuset single-base position at the very center of an accessible site. "],
["why-use-archr.html", "1.2 Why use ArchR?", " 1.2 Why use ArchR? QQQ include some benchmarking figures "],
["what-is-an-arrow-file-archrproject.html", "1.3 What is an Arrow file / ArchRProject?", " 1.3 What is an Arrow file / ArchRProject? The base unit of an analytical project in ArchR is called an Arrow file. Each Arrow file stores all of the data associated with an individual sample (i.e. metadata, accessible fragments, and data matrices). Here, an “individual sample” would be the most detailed unit of analysis desired (for ex. a single replicate of a particular condition). During creation and as additional analyses are performed, ArchR updates and edits each Arrow file to contain additional layers of information. It is worth noting that, to ArchR, an Arrow file is actually just a path to an external file stored on disk. More explicitly, an Arrow file is not an R-language object that is stored in memory but rather an HDF5-format file stored on disk. Because of this, we use an ArchRProject object to associate these Arrow files together into a single analytical framework that can be rapidly accessed in R. This ArchRProject object is small in size and is stored in memory. Certain actions can be taken directly on Arrow files while other actions are taken on an ArchRProject which in turn updates each associated Arrow file. Because Arrow files are stored as large HDF5-format files, “get-er” functions in ArchR retrieve data by interacting with the ArchRProject while “add-er” functions either (i) add data directly to Arrow files, (ii) add data directly to an ArchRProject, or (iii) add data to Arrow files by interacting with an ArchRProject. "],
["input-file-types-in-archr.html", "1.4 Input File Types in ArchR", " 1.4 Input File Types in ArchR QQQ "],
["getting-set-up.html", "1.5 Getting Set Up", " 1.5 Getting Set Up The first thing we do is set up our working directory and set the number of threads we would like to use, and load our gene and genome annotations. Depending on the configuration of your local environment, you may need to modify the number of threads used below in addArchRThreads(). By default ArchR uses half of the total number of threads available but you can adjust this manually as you see fit. If you are using windows, the usable threads will automatically be set to 1 because the parallel processing in ArchR is build for Unix-based operating systems. #Load R Libraries library(ArchR) #Set Default Threads for ArchR Functions #The recommendation is to set it around 1/2 to 3/4 of the total available cores. addArchRThreads(threads = 16) &gt;&gt; Setting default number of Parallel threads to 16. #Set Gene and Genome Annotations to be used addArchRGenome(&quot;hg19&quot;) &gt;&gt; Setting default genome to Hg19. "],
["setting-a-genome-and-geneannotation.html", "1.6 Setting a Genome and GeneAnnotation", " 1.6 Setting a Genome and GeneAnnotation ArchR requires gene and genome annotations to do things such as calculate TSS enrichment scores, nucleotide content, and gene activity scores. Because our tutorial dataset uses scATAC-seq data that has already been aligned to the hg19 reference genome, we have set “hg19” as the default genome above. However, ArchR supports “hg19”, “hg38”, “mm9”, and “mm10” natively but you can create your own using the createGeneAnnotation() and createGenomeAnnotation() functions. Providing this information to ArchR is streamlined through the addArchRGenome() function. This function tells ArchR that, for all analyses in the current session, it should use the genomeAnnotation and geneAnnotation associated with the defined ArchRGenome. Each of the natively supported genomes are composed of a BSgenome object and a GRanges object containing a set of blacklisted regions. Below are examples of how to load gene and genome annotations for the natively supported genomes as well as information on their BSgenome and blacklist components. The precompiled version of the hg19 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg19 and a blacklist that was merged using ArchR::mergeGR() from the hg19 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg19 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg19 genome: addArchRGenome(&quot;hg19&quot;) &gt;&gt; Setting default genome to Hg19. The precompiled version of the hg38 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg38 and a blacklist that was merged using ArchR::mergeGR() from the hg38 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg38 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg38 genome: addArchRGenome(&quot;hg38&quot;) &gt;&gt; Setting default genome to Hg38. The precompiled version of the mm9 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm9 and a blacklist that was merged using ArchR::mergeGR() from the mm9 v1 blacklist regions from Anshul Kundaje and from mitochondrial regions that show high mappability to the mm9 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled mm9 genome: addArchRGenome(&quot;mm9&quot;) &gt;&gt; Setting default genome to Mm9. The precompiled version of the mm10 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm10 and a blacklist that was merged using ArchR::mergeGR() from the mm10 v2 blacklist regions and from mitochondrial regions that show high mappability to the mm10 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg38 genome: addArchRGenome(&quot;mm10&quot;) &gt;&gt; Setting default genome to Mm10. 1.6.1 Creating a custom genome annotation To instead create a custom genome annotation, we can use createGenomeAnnotation(). To do this, you will need the following information: A BSgenome object which contains the sequence information for a genome. These are commonly Bioconductor packages (for example, BSgenome.Hsapiens.UCSC.hg38) that can be easily found with google. A GRanges genomic ranges object containing a set of blacklisted regions that will be used to filter out unwanted regions from downstream analysis. This is not required but is recommended. if (!requireNamespace(&quot;BSgenome.Dmelanogaster.UCSC.dm6&quot;, quietly = TRUE)){ BiocManager::install(&quot;BSgenome.Dmelanogaster.UCSC.dm6&quot;) } library(BSgenome.Dmelanogaster.UCSC.dm6) &gt;&gt; Loading required package: BSgenome &gt;&gt; Loading required package: Biostrings &gt;&gt; Loading required package: XVector &gt;&gt; Attaching package: ‘Biostrings’ &gt;&gt; The following object is masked from ‘package:base’: strsplit genomeAnnotation &lt;- createGenomeAnnotation(genome = BSgenome.Dmelanogaster.UCSC.dm6) &gt;&gt; Getting genome.. &gt;&gt; Getting chromSizes.. &gt;&gt; Getting blacklist.. &gt;&gt; Blacklist not downloaded! Continuing without, be careful for downstream biases.. genomeAnnotation &gt;&gt; List of length 3 &gt;&gt; names(3): genome chromSizes blacklist To create a custom gene annotation for use instead we can use createGeneAnnotation(). To do this, you will need the following information: A TxDb object (transcript database) from Bioconductor which contains information for gene/transcript coordinates. For example, from txdb &lt;- TxDb.Hsapiens.UCSC.hg38.knownGene. An OrgDb object (organism database) from Bioconductor which contains information for gene/transcript symbols from ids. For example, from orgdb &lt;- org.Hs.eg.db. if (!requireNamespace(&quot;TxDb.Dmelanogaster.UCSC.dm6.ensGene&quot;, quietly = TRUE)){ BiocManager::install(&quot;TxDb.Dmelanogaster.UCSC.dm6.ensGene&quot;) } if (!requireNamespace(&quot;org.Dm.eg.db&quot;, quietly = TRUE)){ BiocManager::install(&quot;org.Dm.eg.db&quot;) } library(TxDb.Dmelanogaster.UCSC.dm6.ensGene) &gt;&gt; Loading required package: GenomicFeatures &gt;&gt; Loading required package: AnnotationDbi library(org.Dm.eg.db) geneAnnotation &lt;- createGeneAnnnotation(TxDb = TxDb.Dmelanogaster.UCSC.dm6.ensGene, OrgDb = org.Dm.eg.db) &gt;&gt; Getting Genes.. &gt;&gt; Determined Annotation Style = ENSEMBL &gt;&gt; Getting Exons.. &gt;&gt; Getting TSS.. geneAnnotation &gt;&gt; List of length 3 &gt;&gt; names(3): genes exons TSS Alternatively, if you dont have a TxDb and OrgDb object, you can create a geneAnnotation object from the following information : A GRanges object containing gene coordinates (start to end). Must have a symbols column matching the symbols column of exons. A GRanges object containing gene exon coordinates. Must have a symbols column matching the symbols column of genes. A GRanges object containing standed transcription start site (TSS) coordinates. geneAnnotation &lt;- createGeneAnnnotation( TSS = geneAnnotation$TSS, exons = geneAnnotation$exons, genes = geneAnnotation$genes ) "],
["creating-arrow-files.html", "1.7 Creating Arrow Files", " 1.7 Creating Arrow Files For this tutorial, we will use data from a downsampled dataset of hematopoietic cells Granja* et al. Nature Biotechnology 2019. This includes data from bone marrow mononuclear cells (BMMC), peripheral blood mononuclear cells (PBMC), and CD34+ hematopoietic stem and progenitor cells from bone marrow (CD34 BMMC). This data is downloaded as fragment files which contain the start and end genomic coordinates of all aligned sequenced fragments. Fragment files are one of the base file types of the 10x Genomics analytical platform (and other platforms) and can be easily created from any BAM file. See QQQ for information on making your own fragment files for input to ArchR. Once we have our fragment files, we provide their paths as a character vector to createArrowFiles(). During creation, some basic metadata and matrices are added to each ArrowFile including a “TileMatrix” containing insertion counts across genome-wide 500-bp bins (see addTileMatrix()) and a “GeneScoreMatrix” that is determined based on weighting insertion counts in tiles nearby a gene promoter (see addGeneScoreMatrix()). library(ArchR) #Get Tutorial Data ~0.5GB To Download (if downloaded already ArchR will bypass downloading). inputFiles &lt;- getTutorialData(&quot;Hematopoiesis&quot;) inputFiles &gt;&gt; scATAC_BMMC_R1 &gt;&gt; “HemeFragments/scATAC_BMMC_R1.fragments.tsv.gz” &gt;&gt; scATAC_CD34_BMMC_R1 &gt;&gt; “HemeFragments/scATAC_CD34_BMMC_R1.fragments.tsv.gz” &gt;&gt; scATAC_PBMC_R1 &gt;&gt; “HemeFragments/scATAC_PBMC_R1.fragments.tsv.gz” Now we will create our Arrow Files (10-15 minutes). For each sample, this step will: Read accessible fragments from the provided input files. Calculate quality control information for each cell (i.e. TSS enrichment scores and nucleosome info). Filter cells based on quality control parameters. Create a genome-wide TileMatrix using 500-bp bins. Create a GeneScoreMatrix using the custom geneAnnotation that was defined when we called addArchRGenome(). #Set Genome Annotations to be used to hg19 addArchRGenome(&quot;hg19&quot;) &gt;&gt; Setting default genome to Hg19. #Set Default Threads for ArchR Functions addArchRThreads(threads = 16) &gt;&gt; Setting default number of Parallel threads to 16. ArrowFiles &lt;- createArrowFiles( inputFiles = inputFiles, sampleNames = names(inputFiles), filterTSS = 4, #Dont set this too high because you can always increase later filterFrags = 1000, addTileMat = TRUE, addGeneScoreMat = TRUE ) &gt;&gt; Using GeneAnnotation set by addArchRGenome(Hg19)! &gt;&gt; Using GeneAnnotation set by addArchRGenome(Hg19)! &gt;&gt; ArchR logging to : ArchRLogs/ArchR-createArrows-dfa159ddbf6e-Date-2020-04-15_Time-09-21-27.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Cleaning Temporary Files &gt;&gt; 2020-04-15 09:21:28 : Batch Execution w/ safelapply!, 0 mins elapsed. &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-createArrows-dfa159ddbf6e-Date-2020-04-15_Time-09-21-27.log ArrowFiles &gt;&gt; “scATAC_BMMC_R1.arrow” “scATAC_CD34_BMMC_R1.arrow” &gt;&gt; “scATAC_PBMC_R1.arrow” This step will create a folder called “QualityControl” in your current working directory that will contain 2 plots associated with each of your samples: 1. TSS Enrichment Score by log10(Unique Fragments) 2. Fragment Size Distribution For BMMC: For CD34 BMMC: For PBMC: "],
["session-information.html", "1.8 Session Information", " 1.8 Session Information Sys.Date() sessionInfo() "],
["doublet-inference-with-archr.html", "Chapter 2 Doublet Inference with ArchR", " Chapter 2 Doublet Inference with ArchR One major source of trouble in single-cell data is the contribution of “doublets” to the analysis. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell that is effectively the average of the two cells. We remove these computationally and describe this doublet removal process in depth in this chapter. "],
["inferring-scatac-seq-doublets-with-archr.html", "2.1 Inferring scATAC-seq Doublets with ArchR", " 2.1 Inferring scATAC-seq Doublets with ArchR Single-cell data generated on essentially any platform is susceptible to the presence of doublets. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell. For 10x, the percentage of total “cells” that are actually doublets is proportional to the number of cells loaded into the reaction. Even at the lower levels of doublets that result from standard kit use, more than 5% of the data may come from doublets and this exerts substantial effects on clustering. This issue becomes particularly problematic in the context of developmental/trajectory data because doublets look like a mixture between two cell types and this can be confounded with intermediate cell types or cell states. To predict which “cells” are actually doublets, we synthesize in silico doublets from the data by mixing the reads from thousands of combinations of individual cells. We then project these synthetic doublets into the UMAP embedding and identify their nearest neighbor. By iterating this procedure thousands of times, we can identify “cells” in our data whose signal looks very similar to synthetic doublets. By default ArchR uses the doublet parameters described in the ArchR manuscript. This is likely a good place to start but we encourage all users to inspect the pre- and post-doublet removal data to understand how doublet removal is affecting the cells. We show some of the main adjustable features below to illustrate how this can be customized to a given application. In ArchR, doublet removal is performed in a single step using addDoubletScores(). #Add Infered Doublet Scores to each Arrow File (~2-5 min per sample) #Try ?addDoubletScores to see further documentation on parameters for doublet identification. doubScores &lt;- addDoubletScores( input = ArrowFiles, k = 10, #Refers to how many cells near a &quot;pseudo-doublet&quot; to count. knnMethod = &quot;UMAP&quot;, #Refers to embedding to use for nearest neighbor search with doublet projection. LSIMethod = 1 ) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-addDoubletScores-e60f2395c3f7-Date-2020-04-15_Time-09-28-44.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; 2020-04-15 09:28:44 : Batch Execution w/ safelapply!, 0 mins elapsed. &gt;&gt; 2020-04-15 09:28:44 : scATAC_BMMC_R1 (1 of 3) : Computing Doublet Statistics, 0.001 mins elapsed. &gt;&gt; scATAC_BMMC_R1 (1 of 3) : UMAP Projection R^2 = 0.9736 &gt;&gt; scATAC_BMMC_R1 (1 of 3) : UMAP Projection R^2 = 0.9736 &gt;&gt; 2020-04-15 09:31:15 : scATAC_CD34_BMMC_R1 (2 of 3) : Computing Doublet Statistics, 2.511 mins elapsed. &gt;&gt; scATAC_CD34_BMMC_R1 (2 of 3) : UMAP Projection R^2 = 0.99046 &gt;&gt; scATAC_CD34_BMMC_R1 (2 of 3) : UMAP Projection R^2 = 0.99046 &gt;&gt; 2020-04-15 09:32:40 : scATAC_PBMC_R1 (3 of 3) : Computing Doublet Statistics, 3.936 mins elapsed. &gt;&gt; scATAC_PBMC_R1 (3 of 3) : UMAP Projection R^2 = 0.97507 &gt;&gt; scATAC_PBMC_R1 (3 of 3) : UMAP Projection R^2 = 0.97507 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-addDoubletScores-e60f2395c3f7-Date-2020-04-15_Time-09-28-44.log This command will create plots in the “QualityControl” directory. There are 3 plots associated with each of your samples in this folder: 1. Doublet Enrichments - These represent the enrichment of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. Doublet Scores - These represent the significance (-log10(binomial adjusted p-value)) of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. We have found this value to be less consistent than the doublet enrichments and therefore use doublet enrichments for doublet identification. Doublet Density - This represents the density of the simulated doublet projections so you can visualize where the synthetic doublets were located after projection into your 2-dimensional embedding. For BMMC : For CD34 BMMC : For PBMC : "],
["session-information-1.html", "2.2 Session Information", " 2.2 Session Information Sys.Date() &gt;&gt; [1] “2020-04-15” sessionInfo() "],
["creating-an-archrproject.html", "Chapter 3 Creating an ArchRProject", " Chapter 3 Creating an ArchRProject An ArchRProject allows us to group multiple Arrow files together into a single project. This ArchRProject is small and is stored in memory. By interacting with the ArchRProject we can rapidly push and pull data from the Arrow files. As such, it forms the basis of nearly all ArchR functions and analytical workflows. This chapter describes how to create and interact with an ArchRProject object. "],
["creating-an-archrproject-1.html", "3.1 Creating An ArchRProject", " 3.1 Creating An ArchRProject First, we must create our ArchRProject by providing a list of Arrow files and a few other parameters. The outputDirectory here describes where all downstream analyses and plots will be saved. ArchR will automatically associate the geneAnnotation and genomeAnnotation with the new ArchRProject. These were stored when we ran addArchRGenome(\"hg19\") in a previous chapter. #Create ArchRProject projHeme1 &lt;- ArchRProject( ArrowFiles = ArrowFiles, outputDirectory = &quot;HemeTutorial&quot;, copyArrows = TRUE #This is recommened so that if you modify the ArrowFiles you have an original copy for later usage. ) &gt;&gt; Using GeneAnnotation set by addArchRGenome(Hg19)! &gt;&gt; Using GeneAnnotation set by addArchRGenome(Hg19)! &gt;&gt; Validating Arrows… &gt;&gt; Getting SampleNames… &gt;&gt; &gt;&gt; Copying ArrowFiles to Ouptut Directory! If you want to save disk space set copyArrows = FALSE &gt;&gt; 1 2 3 &gt;&gt; Getting Cell Metadata… &gt;&gt; &gt;&gt; Merging Cell Metadata… &gt;&gt; Initializing ArchRProject… We call this ArchRProject “projHeme1” because it is the first iteration of our hematopoiesis project. Throughout this walkthrough we will modify and update this ArchRProject and keep track of which version of the project we are using by iterating the project number (i.e. “projHeme2”). Lets look at our ArchRProject: projHeme1 &gt;&gt; class: ArchRProject &gt;&gt; outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial &gt;&gt; samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 &gt;&gt; sampleColData names(1): ArrowFiles &gt;&gt; cellColData names(11): Sample TSSEnrichment … DoubletScore &gt;&gt; DoubletEnrichment &gt;&gt; numberOfCells(1): 10661 &gt;&gt; medianTSS(1): 16.832 &gt;&gt; medianFrags(1): 3050 We can see from the above that our ArchRProject has been initialized with a few important attributes: The specified outputDirectory. The sampleNames of each sample which were obtained from the Arrow files. A matrix called sampleColData which contains data associated with each sample. A matrix called cellColData which contains data associated with each cell. Because we already computed doublet enrichment scores (using addDoubletScores()), which added those values to each cell in the Arrow files, we can see columns corresponding to the “DoubletEnrichment” and “DoubletScore” in the cellColData matrix. The total number of cells in our project which represents all samples after doublet identification and removal. The median TSS enrichment score and the median number of fragments across all cells and all samples. We can check how much memory is used to store the ArchRProject in memory within R: paste0(&quot;Memory Size = &quot;, round(object.size(projHeme1) / 10^6, 3), &quot; MB&quot;) &gt;&gt; [1] “Memory Size = 37.135 MB” We can also ask which data matrices are available within the ArchRProject which will be useful downstream once we start adding to this project: getAvailableMatrices(projHeme1) &gt;&gt; [1] “GeneScoreMatrix” “TileMatrix” "],
["manipulating-an-archrproject.html", "3.2 Manipulating An ArchRProject", " 3.2 Manipulating An ArchRProject Now that we have created an ArchRProject, there are many things that we can do to easily access or manipulate the associated data. Example 1. The $ accessor allows direct access to cellColData #A. Access cell names associated with each cell head(projHeme1$cellNames) &gt;&gt; [1] “scATAC_BMMC_R1#TTATGTCAGTGATTAG-1” “scATAC_BMMC_R1#AAGATAGTCACCGCGA-1” &gt;&gt; [3] “scATAC_BMMC_R1#GCATTGAAGATTCCGT-1” “scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1” &gt;&gt; [5] “scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1” “scATAC_BMMC_R1#AGTTACGAGAACGTCG-1” #B. Access sample names associated with each cell head(projHeme1$Sample) &gt;&gt; [1] “scATAC_BMMC_R1” “scATAC_BMMC_R1” “scATAC_BMMC_R1” “scATAC_BMMC_R1” &gt;&gt; [5] “scATAC_BMMC_R1” “scATAC_BMMC_R1” #C. Access TSS Enrichment Scores for each cell quantile(projHeme1$TSSEnrichment) &gt;&gt; 0% 25% 50% 75% 100% &gt;&gt; 4.027 13.922 16.832 19.937 41.782 Example 2. Subsetting an ArchRProject by cells #A. Subset the project numerically projHeme1[1:100, ] #First 100 cells &gt;&gt; class: ArchRProject &gt;&gt; outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial &gt;&gt; samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 &gt;&gt; sampleColData names(1): ArrowFiles &gt;&gt; cellColData names(11): Sample TSSEnrichment … DoubletScore &gt;&gt; DoubletEnrichment &gt;&gt; numberOfCells(1): 100 &gt;&gt; medianTSS(1): 10.7725 &gt;&gt; medianFrags(1): 10200.5 #B. Subset the project using cellNames projHeme1[projHeme1$cellNames[1:100], ] &gt;&gt; class: ArchRProject &gt;&gt; outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial &gt;&gt; samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 &gt;&gt; sampleColData names(1): ArrowFiles &gt;&gt; cellColData names(11): Sample TSSEnrichment … DoubletScore &gt;&gt; DoubletEnrichment &gt;&gt; numberOfCells(1): 100 &gt;&gt; medianTSS(1): 10.7725 &gt;&gt; medianFrags(1): 10200.5 #C. Subset the project to return all cells corresponding to a specific sample idxSample &lt;- BiocGenerics::which(projHeme1$Sample %in% &quot;scATAC_BMMC_R1&quot;) cellsSample &lt;- projHeme1$cellNames[idxSample] projHeme1[cellsSample, ] &gt;&gt; class: ArchRProject &gt;&gt; outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial &gt;&gt; samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 &gt;&gt; sampleColData names(1): ArrowFiles &gt;&gt; cellColData names(11): Sample TSSEnrichment … DoubletScore &gt;&gt; DoubletEnrichment &gt;&gt; numberOfCells(1): 4932 &gt;&gt; medianTSS(1): 15.254 &gt;&gt; medianFrags(1): 2771 #D. Subset the project based on a specific TSS enrichment score cutoff idxPass &lt;- which(projHeme1$TSSEnrichment &gt;= 8) cellsPass &lt;- projHeme1$cellNames[idxPass] projHeme1[cellsPass, ] &gt;&gt; class: ArchRProject &gt;&gt; outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial &gt;&gt; samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 &gt;&gt; sampleColData names(1): ArrowFiles &gt;&gt; cellColData names(11): Sample TSSEnrichment … DoubletScore &gt;&gt; DoubletEnrichment &gt;&gt; numberOfCells(1): 10500 &gt;&gt; medianTSS(1): 16.9275 &gt;&gt; medianFrags(1): 3042 Example 3. Adding data to an ArchRProject #Add a column to cellColData that contains more legible sample names by removing excess info from the original sample names bioNames &lt;- gsub(&quot;_R2|_R1|scATAC_&quot;,&quot;&quot;,projHeme1$Sample) head(bioNames) &gt;&gt; [1] “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” &gt;&gt; [7] “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” projHeme1$bioNames &lt;- bioNames #Add a column to cellColData that only contains information for a subset of cells bioNames &lt;- bioNames[1:10] cellNames &lt;- projHeme1$cellNames[1:10] projHeme1 &lt;- addCellColData(ArchRProj = projHeme1, data = paste0(bioNames), cells = cellNames, name = &quot;bioNames2&quot;) #We can compare these two columns to see &quot;NA&quot; filled in where data wasnt available for bioNames2 getCellColData(projHeme1, select = c(&quot;bioNames&quot;, &quot;bioNames2&quot;)) &gt;&gt; DataFrame with 10661 rows and 2 columns &gt;&gt; bioNames bioNames2 &gt;&gt; &gt;&gt; scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 BMMC BMMC &gt;&gt; scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 BMMC BMMC &gt;&gt; scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 BMMC BMMC &gt;&gt; scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 BMMC BMMC &gt;&gt; scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 BMMC BMMC &gt;&gt; … … … &gt;&gt; scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 PBMC NA &gt;&gt; scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 PBMC NA &gt;&gt; scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 PBMC NA &gt;&gt; scATAC_PBMC_R1#TTCGTTACATTGAACC-1 PBMC NA &gt;&gt; scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 PBMC NA Example 4. Obtaining unique fragment counts #Select the column from cellColData corresponding to the number of unique #nuclear (non-mitochondrial) fragments per cell df &lt;- getCellColData(projHeme1, select = &quot;nFrags&quot;) df &gt;&gt; DataFrame with 10661 rows and 1 column &gt;&gt; nFrags &gt;&gt; &gt;&gt; scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 26189 &gt;&gt; scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 20648 &gt;&gt; scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 18991 &gt;&gt; scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 18296 &gt;&gt; scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 17458 &gt;&gt; … … &gt;&gt; scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 1038 &gt;&gt; scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 1037 &gt;&gt; scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 1033 &gt;&gt; scATAC_PBMC_R1#TTCGTTACATTGAACC-1 1033 &gt;&gt; scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 1002 #Or, instead of selecting a column by name, we can actually perform operations on a given #column using its column name df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;nFrags - 1&quot;)) df &gt;&gt; DataFrame with 10661 rows and 2 columns &gt;&gt; log10(nFrags) nFrags - 1 &gt;&gt; &gt;&gt; scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 26188 &gt;&gt; scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 20647 &gt;&gt; scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 18990 &gt;&gt; scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 18295 &gt;&gt; scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 17457 &gt;&gt; … … … &gt;&gt; scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 1037 &gt;&gt; scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 1036 &gt;&gt; scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 1032 &gt;&gt; scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 1032 &gt;&gt; scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 1001 Example 5. Plotting QC metrics - log10(Unique Fragments) vs TSS enrichment score df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;TSSEnrichment&quot;)) df &gt;&gt; DataFrame with 10661 rows and 2 columns &gt;&gt; log10(nFrags) TSSEnrichment &gt;&gt; &gt;&gt; scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 7.149 &gt;&gt; scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 7.911 &gt;&gt; scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 4.505 &gt;&gt; scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 6.946 &gt;&gt; scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 4.799 &gt;&gt; … … … &gt;&gt; scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 24.356 &gt;&gt; scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 22.537 &gt;&gt; scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 20.146 &gt;&gt; scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 30.198 &gt;&gt; scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 21.485 Now lets plot the number of unique nuclear fragments (log10) by the TSS enrichment score. This type of plot is key for identifying high quality cells. We can further adjust our cutoffs based on this plot if need be. p &lt;- ggPoint( x = df[,1], y = df[,2], colorDensity = TRUE, continuousSet = &quot;sambaNight&quot;, xlabel = &quot;Log10 Unique Fragments&quot;, ylabel = &quot;TSS Enrichment&quot;, xlim = c(log10(500), quantile(df[,1], probs = 0.99)), ylim = c(0, quantile(df[,2], probs = 0.99)) ) + geom_hline(yintercept = 4, lty = &quot;dashed&quot;) + geom_vline(xintercept = 3, lty = &quot;dashed&quot;) p To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p, name = &quot;TSS-vs-Frags.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : TSS-vs-Frags.pdf "],
["plotting-sample-statistics-from-an-archrproject.html", "3.3 Plotting Sample Statistics from an ArchRProject", " 3.3 Plotting Sample Statistics from an ArchRProject When working with multiple distinct samples in a single integrated data set, it can be important to compare various metrics across all samples. ArchR provides two main plotting mechanisms for grouped data: ridge plots and violin plots. These are both accessed through the plotGroups() function. Of course, this plot type is not limited to sample-level data and can be used for plotting of downstream group-level information for groups such as clusters. Example 1. Make a ridge plot for each sample for the TSS enrichment scores. To make a ridge plot, we set plotAs = \"ridges\". p1 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;ridges&quot; ) &gt;&gt; 1 p1 &gt;&gt; Picking joint bandwidth of 0.882 Example 2. Make a violin plot for each sample for the TSS enrichment scores. To make a violin plot, we set plotAs = \"violin\". p2 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) &gt;&gt; 1 p2 Example 3. Make a ridge plot for each sample for the log10(unique nuclear fragments). p3 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;ridges&quot; ) &gt;&gt; 1 p3 &gt;&gt; Picking joint bandwidth of 0.05 Example 4. Make a violin plot for each sample for the log10(unique nuclear fragments). p4 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) &gt;&gt; 1 p4 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;QC-Sample-Statistics.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 4, height = 4) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; Picking joint bandwidth of 0.882 &gt;&gt; Picking joint bandwidth of 0.882 &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; Picking joint bandwidth of 0.05 &gt;&gt; Picking joint bandwidth of 0.05 &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : QC-Sample-Statistics.pdf "],
["plotting-sample-fragment-size-distribution-and-tss-enrichment-profiles-.html", "3.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles.", " 3.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles. Because of how the data is stored and accessed, ArchR can compute fragment size distributions and TSS enrichment profiles from Arrow files very quickly. Fragment size distributions: p1 &lt;- plotFragmentSizes(ArchRProj = projHeme1) p1 TSS enrichment profiles: p2 &lt;- plotTSSEnrichment(ArchRProj = projHeme1) p2 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2, name = &quot;QC-Sample-FragSizes-TSSProfile.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 5, height = 5) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : QC-Sample-FragSizes-TSSProfile.pdf "],
["filtering-doublets-from-an-archrproject.html", "3.5 Filtering Doublets from an ArchRProject", " 3.5 Filtering Doublets from an ArchRProject After we have added information on the predicted doublets using addDoubletScores(), we can remove these predicted doublets using filterDoublets(). One of the key elements of this filtering step is the filterRatio which is the maximum ratio of predicted doublets to filter based on the number of pass-filter cells. For example, if there are 5000 cells, the maximum number of filtered predicted doublets would be filterRatio * 5000^2 / (100000) (which simplifies to filterRatio * 5000 * 0.05). This filterRatio allows you to apply a consistent filter across multiple different samples that may have different percentages of doublets because they were run with different cell loading concentrations. The higher the filterRatio, the greater the number of cells potentially removed as doublets. #Remove doublets as normal projHeme2 &lt;- filterDoublets(projHeme1) &gt;&gt; Filtering 410 cells from ArchRProject! &gt;&gt; scATAC_BMMC_R1 : 243 of 4932 (4.9%) &gt;&gt; scATAC_CD34_BMMC_R1 : 107 of 3275 (3.3%) &gt;&gt; scATAC_PBMC_R1 : 60 of 2454 (2.4%) #Lets see the project now projHeme2 &gt;&gt; class: ArchRProject &gt;&gt; outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial &gt;&gt; samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 &gt;&gt; sampleColData names(1): ArrowFiles &gt;&gt; cellColData names(13): Sample TSSEnrichment … bioNames bioNames2 &gt;&gt; numberOfCells(1): 10251 &gt;&gt; medianTSS(1): 16.856 &gt;&gt; medianFrags(1): 2991 If you wanted to filter more cells from the ArchR Project, you would try a higher filterRatio. To see additional arguments that can be tweaked, try ?filterDoublets. projHemeTmp &lt;- filterDoublets(projHeme1, filterRatio = 1.5) &gt;&gt; Filtering 614 cells from ArchRProject! &gt;&gt; scATAC_BMMC_R1 : 364 of 4932 (7.4%) &gt;&gt; scATAC_CD34_BMMC_R1 : 160 of 3275 (4.9%) &gt;&gt; scATAC_PBMC_R1 : 90 of 2454 (3.7%) rm(projHemeTmp) We can now save our updated projHeme2 using saveArchRProject() which will allow us to use this project in future chapters. saveArchRProject(ArchRProj = projHeme1, outputDirectory = &quot;Save-ProjHeme1&quot;, load = FALSE) &gt;&gt; Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme1 &gt;&gt; Copying Arrow Files… &gt;&gt; Copying Arrow Files (1 of 3) &gt;&gt; Copying Arrow Files (2 of 3) &gt;&gt; Copying Arrow Files (3 of 3) &gt;&gt; Getting ImputeWeights &gt;&gt; No imputeWeights found, returning NULL &gt;&gt; Copying Other Files… &gt;&gt; Copying Other Files (1 of 1): Plots &gt;&gt; Saving ArchRProject… "],
["session-information-2.html", "3.6 Session Information", " 3.6 Session Information Sys.Date() &gt;&gt; [1] “2020-04-15” sessionInfo() "],
["dimensionality-reduction-with-archr.html", "Chapter 4 Dimensionality Reduction with ArchR", " Chapter 4 Dimensionality Reduction with ArchR Dimensionality reduction with scATAC-seq is challenging due to the sparsity of the data. In scATAC-seq, a particular site can either be accessible on one allele, both alleles, or no alleles. Even in higher-quality scATAC-seq data, the majority of accesible regions are not transposed and this leads to many loci having 0 accessibile alleles. Moreover, when we see (for example) three Tn5 insertions within a single peak region in a single cell, the sparsity of the data prevents us from confidently determining that this site in this cell is actually three times more accessible than another cell that only has one insertion in the same site. For this reason a lot of analytical strategies work on a binarized scATAC-seq data matrix. This binarized matrix still ends up being mostly 0s because transposition is rare. However, it is important to note that a 0 in scATAC-seq could mean “non-accessible” or “not sampled” and these two inferences are very different from a biological standpoint. Because of this, the 1s have information and the 0s do not. This low information content is what makes our scATAC-seq data sparse. If you were to perform a standard dimensionality reduction, like Principal Component Analysis, on this sparse insertion counts matrix and plot the top two principal components, you would not obtain the desired result because the sparsity causes high inter-cell similarity at all of the 0 positions. To get around this issue, we use a layered dimensionality reduction approach. First, we use Latent Semantic Indexing (LSI), an approach from natural language processing that was originally designed to assess document similarity based on word counts. This solution was created for natural language processing because the data is sparse and noisy (many different words and many low frequency words). LSI was first introduced for scATAC-seq by Cusanovich et al. (Science 2015). In the case of scATAC-seq, different samples are the documents and different regions/peaks are the words. First, we calculate the term frequency by depth normalization per single cell. These values are then normalized by the inverse document frequency which weights features by how often they occur to identify featres that are more “specific” rather than commonly accessible. The resultant term frequency-inverse document frequency (TF-IDF) matrix reflects how important a word (aka region/peak) is to a document (aka sample). Then, through a technique called singular value decomposition (SVD), the most valuable information across samples is identified and represented in a lower dimensional space. LSI allows you to reduce the dimensionality of the sparse insertion counts matrix from many thousands to tens or hundreds. Then, a more conventional dimensionality reduction technique, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE) can be used to visualize the data. In ArchR, these visualization methods are referred to as embeddings. "],
["archrs-lsi-implementation.html", "4.1 ArchR’s LSI Implementation", " 4.1 ArchR’s LSI Implementation ArchR implements a few different LSI implementations and we have benchmarked many of these methods across multiple different test data sets. ArchR’s default LSI implementation is related to the method introduced by Timothy Stuart in Signac, which uses a term frequency that has been depth normalized to a constant (10,000) followed by normalization with the inverse document frequency and then log-transforming the resultant matrix (aka log(TF-IDF)). One of the key inputs to LSI dimensionality reduction is the starting matrix. Thus far, the main two strategies in scATAC-seq have been to (1) use peak regions or (2) genome-wide tiles. However, using peak regions for LSI is inherently challenging because we do not have clusters or cluster-specific peaks prior to dimensionality reduction. Moreover, calling peaks on aggregated cells prior to clustering obscures cell type-specific peaks. Moreover, any union peak set will change when new samples are added to an experiment, making this strategy less stable. The second strategy, using genome-wide tiles, mitigates these issues by using a consistent and unbiased feature set (genome-wide tiles). However, a genome-wide tile matrix of all cells by all regions can become prohibitively large. For this reason, most implementations use tiles that are greater than or equal to 5 kilobases in size. This drastically reduces the resolution of the approach because most accessible regions are only a few hundred basepairs long. Because of the way that Arrow files are designed, ArchR is able to perform LSI very rapidly using genome-wide 500-bp tiles. This solves the problem of resolution and allows for the identification of clusters prior to calling peaks. The challenge is that 500-bp bins generate around 6 million features to be included in the cell by tile matrix. While ArchR is able to read this large amount of data into R by chunking the relevant matrices, we have also implemented an “estimated LSI” approach that performs the initial dimensionality reduction on a subset of the total cells. This estimated LSI approach has two main utilities - (i) it speeds up dimensionality reduction (ii) as you decrease the number of cells used in the intial dimensionality reduction, this decreases the granularity of the data. This reduction in granularity can be used to your advantage to reduce batch effects in your data. However, it can also obscure true biology so estimated LSI approaches should be used under close manual supervision. "],
["iterative-latent-semantic-indexing-lsi.html", "4.2 Iterative Latent Semantic Indexing (LSI)", " 4.2 Iterative Latent Semantic Indexing (LSI) In scRNA-seq identifying variable genes is a common way to compute dimensionality reduction (such as PCA). This is done because these genes are more likely to be biologically important and this reduces experimental noise. In scATAC-seq the data is binary and thus you cannot identify variable peaks for dimensionality reduction. Rather than identifying the most variable peaks, we have tried using the most accessible features as input to LSI; however, the results when running multiple samples have shown high degrees of noise and low reproducibility. To remedy this we introduced the “iterative LSI” approach (Satpathy*, Granja* et al. Nature Biotechnology 2019 and Granja*, Klemm* and McGinnis* et al. Nature Biotechnology 2019). This approach computes an inital LSI transformation on the most accessible tiles and identifies lower resolution clusters that are not batch confounded. For example, when performed on peripheral blood mononuclear cells, this will identify clusters corresponding to the major cell types (T cells, B cells, and monocytes). Then ArchR computes the average accessibility for each of these clusters across all features creating “pseudo-bulks”. ArchR then identifies the most variable peaks across these pseudo-bulks and uses these features for LSI again. In this second iteration, the most variable peaks are more similar to the variable genes used in scRNA-seq LSI implementations. The user can set how many iterations of LSI should be performed. QQQ add new info on LSI implementation. We have found this approach to be very good for batch minimization and allows operations on a more reasonably sized feature matrix. To perform iterative LSI in ArchR, we use the addIterativeLSI() function. The default parameters which should cover most cases but we encourage you to explore the available parameters and how they each affect your particular data set. See ?addIterativeLSI for more details on inputs. projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( #See Seurat::FindClusters resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) &gt;&gt; Checking Inputs… &gt;&gt; ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-ea2d75dd89ad-Date-2020-04-15_Time-09-36-28.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; 2020-04-15 09:36:29 : Computing Total Accessibility Across All Features, 0.003 mins elapsed. &gt;&gt; 2020-04-15 09:36:35 : Computing Top Features, 0.102 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:36:35 : Running LSI (1 of 2) on Top Features, 0.111 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:36:35 : Sampling Cells (N = 10002) for Estimated LSI, 0.112 mins elapsed. &gt;&gt; 2020-04-15 09:36:35 : Creating Sampled Partial Matrix, 0.112 mins elapsed. &gt;&gt; 2020-04-15 09:36:45 : Computing Estimated LSI (projectAll = FALSE), 0.276 mins elapsed. &gt;&gt; 2020-04-15 09:37:22 : Identifying Clusters, 0.887 mins elapsed. &gt;&gt; 2020-04-15 09:37:53 : Identified 5 Clusters, 1.407 mins elapsed. &gt;&gt; 2020-04-15 09:37:53 : Saving LSI Iteration, 1.407 mins elapsed. &gt;&gt; 2020-04-15 09:38:10 : Creating Cluster Matrix on the total Group Features, 1.696 mins elapsed. &gt;&gt; 2020-04-15 09:38:21 : Computing Variable Features, 1.867 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:38:21 : Running LSI (2 of 2) on Variable Features, 1.871 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:38:21 : Creating Partial Matrix, 1.871 mins elapsed. &gt;&gt; 2020-04-15 09:38:30 : Computing LSI, 2.018 mins elapsed. &gt;&gt; 2020-04-15 09:39:05 : Finished Running IterativeLSI, 2.606 mins elapsed. If you see downstream that you have subtle batch effects, another option is to add more LSI iterations and to start from a lower intial clustering resolution as shown below. Additionally the number of variable features can be lowered to increase focus on the more variable features. QQQ would be nice to see an example of what these batch effects look like and how this corrects them projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI2&quot;, iterations = 4, clusterParams = list( #See Seurat::FindClusters resolution = c(0.1, 0.2, 0.4), sampleCells = 10000, n.start = 10 ), varFeatures = 15000, dimsToUse = 1:30 ) &gt;&gt; Checking Inputs… &gt;&gt; ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-ea2d349ff558-Date-2020-04-15_Time-09-39-05.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; 2020-04-15 09:39:06 : Computing Total Accessibility Across All Features, 0.004 mins elapsed. &gt;&gt; 2020-04-15 09:39:09 : Computing Top Features, 0.06 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:39:10 : Running LSI (1 of 4) on Top Features, 0.07 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:39:10 : Sampling Cells (N = 10002) for Estimated LSI, 0.071 mins elapsed. &gt;&gt; 2020-04-15 09:39:10 : Creating Sampled Partial Matrix, 0.071 mins elapsed. &gt;&gt; 2020-04-15 09:39:17 : Computing Estimated LSI (projectAll = FALSE), 0.192 mins elapsed. &gt;&gt; 2020-04-15 09:39:42 : Identifying Clusters, 0.611 mins elapsed. &gt;&gt; 2020-04-15 09:40:05 : Identified 4 Clusters, 0.987 mins elapsed. &gt;&gt; 2020-04-15 09:40:05 : Saving LSI Iteration, 0.987 mins elapsed. &gt;&gt; 2020-04-15 09:40:26 : Creating Cluster Matrix on the total Group Features, 1.343 mins elapsed. &gt;&gt; 2020-04-15 09:40:38 : Computing Variable Features, 1.54 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:40:38 : Running LSI (2 of 4) on Variable Features, 1.542 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:40:38 : Sampling Cells (N = 10002) for Estimated LSI, 1.544 mins elapsed. &gt;&gt; 2020-04-15 09:40:38 : Creating Sampled Partial Matrix, 1.544 mins elapsed. &gt;&gt; 2020-04-15 09:40:47 : Computing Estimated LSI (projectAll = FALSE), 1.687 mins elapsed. &gt;&gt; 2020-04-15 09:41:09 : Identifying Clusters, 2.048 mins elapsed. &gt;&gt; 2020-04-15 09:41:31 : Identified 7 Clusters, 2.421 mins elapsed. &gt;&gt; 2020-04-15 09:41:31 : Saving LSI Iteration, 2.421 mins elapsed. &gt;&gt; 2020-04-15 09:41:54 : Creating Cluster Matrix on the total Group Features, 2.807 mins elapsed. &gt;&gt; 2020-04-15 09:42:05 : Computing Variable Features, 2.995 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:42:06 : Running LSI (3 of 4) on Variable Features, 3 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:42:06 : Sampling Cells (N = 10002) for Estimated LSI, 3.001 mins elapsed. &gt;&gt; 2020-04-15 09:42:06 : Creating Sampled Partial Matrix, 3.001 mins elapsed. &gt;&gt; 2020-04-15 09:42:13 : Computing Estimated LSI (projectAll = FALSE), 3.121 mins elapsed. &gt;&gt; 2020-04-15 09:42:33 : Identifying Clusters, 3.461 mins elapsed. &gt;&gt; 2020-04-15 09:42:55 : Identified 9 Clusters, 3.829 mins elapsed. &gt;&gt; 2020-04-15 09:42:55 : Saving LSI Iteration, 3.829 mins elapsed. &gt;&gt; 2020-04-15 09:43:13 : Creating Cluster Matrix on the total Group Features, 4.129 mins elapsed. &gt;&gt; 2020-04-15 09:43:26 : Computing Variable Features, 4.341 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:43:26 : Running LSI (4 of 4) on Variable Features, 4.346 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:43:26 : Creating Partial Matrix, 4.347 mins elapsed. &gt;&gt; 2020-04-15 09:43:33 : Computing LSI, 4.462 mins elapsed. &gt;&gt; 2020-04-15 09:43:55 : Finished Running IterativeLSI, 4.829 mins elapsed. For the purposes of this tutorial, we will compute the iterative LSI for the ArchRProject that still contains doublets. projHeme1 &lt;- addIterativeLSI( ArchRProj = projHeme1, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( #See Seurat::FindClusters resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) &gt;&gt; Checking Inputs… &gt;&gt; ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-ea2d717d926a-Date-2020-04-15_Time-09-43-55.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; 2020-04-15 09:43:57 : Computing Total Accessibility Across All Features, 0.005 mins elapsed. &gt;&gt; 2020-04-15 09:44:00 : Computing Top Features, 0.071 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:44:01 : Running LSI (1 of 2) on Top Features, 0.079 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:44:01 : Sampling Cells (N = 10001) for Estimated LSI, 0.081 mins elapsed. &gt;&gt; 2020-04-15 09:44:01 : Creating Sampled Partial Matrix, 0.081 mins elapsed. &gt;&gt; 2020-04-15 09:44:10 : Computing Estimated LSI (projectAll = FALSE), 0.237 mins elapsed. &gt;&gt; 2020-04-15 09:44:50 : Identifying Clusters, 0.899 mins elapsed. &gt;&gt; 2020-04-15 09:45:11 : Identified 5 Clusters, 1.253 mins elapsed. &gt;&gt; 2020-04-15 09:45:11 : Saving LSI Iteration, 1.253 mins elapsed. &gt;&gt; 2020-04-15 09:45:30 : Creating Cluster Matrix on the total Group Features, 1.568 mins elapsed. &gt;&gt; 2020-04-15 09:45:44 : Computing Variable Features, 1.804 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:45:45 : Running LSI (2 of 2) on Variable Features, 1.808 mins elapsed. &gt;&gt; ########### &gt;&gt; 2020-04-15 09:45:45 : Creating Partial Matrix, 1.808 mins elapsed. &gt;&gt; 2020-04-15 09:45:54 : Computing LSI, 1.96 mins elapsed. &gt;&gt; 2020-04-15 09:46:28 : Finished Running IterativeLSI, 2.523 mins elapsed. "],
["estimated-lsi.html", "4.3 Estimated LSI", " 4.3 Estimated LSI "],
["batch-effect-correction-wtih-harmony.html", "4.4 Batch Effect Correction wtih Harmony", " 4.4 Batch Effect Correction wtih Harmony Sometimes the iterative LSI approach isnt enough of a correction for strong batch effect differences. For this reason, ArchR implements a commonly used batch effect correction tool called Harmony which was originally designed for scRNA-seq. We provide a wrapper that will pass a dimensionality reduction object from ArchR directly to the HarmonyMatrix() function. Additional arguments can be directly passed to HarmonyMatrix() in the function via the additional parameters (...) . See ?addHarmony() for more details. Users should be aware of the caveats of batch correction for their particular application. projHeme2 &lt;- addHarmony( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;Harmony&quot;, groupBy = &quot;Sample&quot; ) &gt;&gt; Harmony 1/10 &gt;&gt; Harmony 2/10 &gt;&gt; Harmony 3/10 &gt;&gt; Harmony converged after 3 iterations "],
["session-information-3.html", "4.5 Session Information", " 4.5 Session Information Sys.Date() &gt;&gt; [1] “2020-04-15” sessionInfo() "],
["clustering-with-archr.html", "Chapter 5 Clustering with ArchR", " Chapter 5 Clustering with ArchR Most single-cell clustering methods focus on computing nearest neighbor graphs in reduced dimensions and then identifying “communities” or clusters of cells. These approaches work extremely well and are a standard practice in scRNA-seq. For this reason, ArchR uses existing state-of-the-art clustering methods from scRNA-seq packages for clustering. "],
["clustering-using-seurats-findclusters-function.html", "5.1 Clustering using Seurat’s FindClusters() function", " 5.1 Clustering using Seurat’s FindClusters() function We have had the most success using the graph clustering approach implemented by Seurat. In ArchR, clustering is performed using the addClusters() function which permits additional clustering parameters to be passed to the Seurat::FindClusters() function. projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;Seurat&quot;, name = &quot;Clusters&quot;, resolution = 0.8 ) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-addClusters-ee735fb26d4a-Date-2020-04-15_Time-09-46-59.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; 2020-04-15 09:47:08 : Running Seurats FindClusters (Stuart et al. Cell 2019), 0.142 mins elapsed. &gt;&gt; Computing nearest neighbor graph &gt;&gt; Computing SNN &gt;&gt; Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck &gt;&gt; &gt;&gt; Number of nodes: 10251 &gt;&gt; Number of edges: 496637 &gt;&gt; &gt;&gt; Running Louvain algorithm… &gt;&gt; Maximum modularity in 10 random starts: 0.8554 &gt;&gt; Number of communities: 12 &gt;&gt; Elapsed time: 1 seconds &gt;&gt; 2020-04-15 09:47:29 : Testing Outlier Clusters, 0.483 mins elapsed. &gt;&gt; 2020-04-15 09:47:29 : Assigning Cluster Names to 12 Clusters, 0.483 mins elapsed. To access these clusters we can use the $ accessor head(projHeme2$Clusters) &gt;&gt; [1] “C3” “C8” “C4” “C3” “C11” “C3” table(projHeme2$Clusters) &gt;&gt; C1 C10 C11 C12 C2 C3 C4 C5 C6 C7 C8 C9 &gt;&gt; 1547 879 793 1650 1085 439 351 320 387 851 1271 678 To better understand which samples reside in which clusters, we can create a cluster confusion matrix across each sample. JJJ cM &lt;- confusionMatrix(paste0(projHeme2$Clusters), paste0(projHeme2$Sample)) cM &gt;&gt; 12 x 3 sparse Matrix of class “dgCMatrix” &gt;&gt; scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 &gt;&gt; C3 251 6 182 &gt;&gt; C8 1219 . 52 &gt;&gt; C4 351 . . &gt;&gt; C11 251 541 1 &gt;&gt; C1 1508 9 30 &gt;&gt; C12 172 1478 . &gt;&gt; C10 194 677 8 &gt;&gt; C9 117 1 560 &gt;&gt; C7 301 . 550 &gt;&gt; C5 161 150 9 &gt;&gt; C2 82 1 1002 &gt;&gt; C6 82 305 . An example of plotting this confusion matrix as a heatmap library(pheatmap) cM &lt;- cM / Matrix::rowSums(cM) p &lt;- pheatmap::pheatmap( mat = as.matrix(cM), color = paletteContinuous(&quot;whiteBlue&quot;), border_color = &quot;black&quot; ) p Determining the appropriate cluster parameters is useful once you have computed a 2-dimensional embedding. This is because you should be adjusting both the clustering and embedding parameters to where they both agree. 5.1.1 Clustering using scran Additionally, ArchR allows for the identification of clusters with scran by changing the method parameter in addClusters(). projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;scran&quot;, name = &quot;ScranClusters&quot;, k = 15 ) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-addClusters-ee735ec9887a-Date-2020-04-15_Time-09-47-32.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; 2020-04-15 09:47:39 : Running Scran SNN Graph (Lun et al. F1000Res. 2016), 0.103 mins elapsed. &gt;&gt; 2020-04-15 09:47:49 : Identifying Clusters (Lun et al. F1000Res. 2016), 0.27 mins elapsed. &gt;&gt; 2020-04-15 09:50:31 : Testing Outlier Clusters, 2.98 mins elapsed. &gt;&gt; 2020-04-15 09:50:31 : Assigning Cluster Names to 9 Clusters, 2.98 mins elapsed. "],
["session-information-4.html", "5.2 Session Information", " 5.2 Session Information Sys.Date() &gt;&gt; [1] “2020-04-15” sessionInfo() "],
["single-cell-embeddings.html", "Chapter 6 Single Cell Embeddings", " Chapter 6 Single Cell Embeddings In ArchR, embeddings, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE), are used to visualize single cells in reduced dimension space. These embeddings each have distinct advantages and disadvantages. We call these “embeddings” because they are strictly used to visualize the clusters and are not used to identify clusters which is done using LSI as mentioned in previous chapters. The primary difference between UMAP and t-SNE is the interpretatino of the distance between cells or clusters. t-SNE is designed to preserve the local structure in the data while UMAP is designed to preserve both the local and most of the global structure in the data. In theory, this means that the distance between two clusters is not informative in t-SNE but is informative in UMAP. For example, t-SNE does not allow you to say that Cluster A is more similar to Cluster B than it is to Cluster C based on the observation that Cluster A is located closer to Cluster B than Cluster C on the t-SNE. UMAP, on the other hand, is designed to permit this type of comparison, though it is worth noting that UMAP is a new enough method that this is still being flushed out in the literature. It is important to note that neither t-SNE nor UMAP are deterministic. Moreover, tweaking the input parameters will lead to different results. In the context of t-SNE and UMAP, you can effectively make the algorithm deterministic by using the same random seed. However, the remaining input parameters still have drastic effects on the resulting embedding. Because of this, it is important to understand the various input parameters and to tweak these to best meet the needs of your own data. ArchR implements a default set of input parameters that work for most applications but there is really no single set of parameters that will produce the desired results for datasets that vary greatly in cell number, complexity, and quality. "],
["umap.html", "6.1 UMAP", " 6.1 UMAP projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;UMAP&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) &gt;&gt; 09:50:55 UMAP embedding parameters a = 0.583 b = 1.334 &gt;&gt; 09:50:56 Read 10251 rows and found 30 numeric columns &gt;&gt; 09:50:56 Using Annoy for neighbor search, n_neighbors = 30 &gt;&gt; 09:50:57 Building Annoy index with metric = cosine, n_trees = 50 &gt;&gt; 0% 10 20 30 40 50 60 70 80 90 100% &gt;&gt; [—-|—-|—-|—-|—-|—-|—-|—-|—-|—-| &gt;&gt; **************************************************| &gt;&gt; 09:50:59 Writing NN index file to temp file /tmp/RtmpXb8qQa/fileefeefe9c02c &gt;&gt; 09:50:59 Searching Annoy index using 10 threads, search_k = 3000 &gt;&gt; 09:51:00 Annoy recall = 100% &gt;&gt; 09:51:01 Commencing smooth kNN distance calibration using 10 threads &gt;&gt; 09:51:03 Initializing from normalized Laplacian + noise &gt;&gt; 09:51:03 Commencing optimization for 200 epochs, with 467652 positive edges &gt;&gt; 09:51:14 Optimization finished p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee4e054106-Date-2020-04-15_Time-09-51-17.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee4e054106-Date-2020-04-15_Time-09-51-17.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee3f232286-Date-2020-04-15_Time-09-51-18.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee3f232286-Date-2020-04-15_Time-09-51-18.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : Plot-UMAP-Sample-Clusters.pdf We can also see the results from scran clustering p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee6f4b8b88-Date-2020-04-15_Time-09-51-38.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee6f4b8b88-Date-2020-04-15_Time-09-51-38.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;UMAP&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee6c73b6da-Date-2020-04-15_Time-09-51-39.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee6c73b6da-Date-2020-04-15_Time-09-51-39.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : Plot-UMAP-Sample-ScranClusters.pdf "],
["tsne.html", "6.2 tSNE", " 6.2 tSNE projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;TSNE&quot;, perplexity = 30 ) &gt;&gt; Read the 10251 x 30 data matrix successfully! &gt;&gt; OpenMP is working. 9 threads. &gt;&gt; Using no_dims = 2, perplexity = 30.000000, and theta = 0.500000 &gt;&gt; Computing input similarities… &gt;&gt; Building tree… &gt;&gt; - point 10000 of 10251 &gt;&gt; - point 10000 of 10251 &gt;&gt; Done in 9.33 seconds (sparsity = 0.013318)! &gt;&gt; Learning embedding… &gt;&gt; Iteration 50: error is 96.116599 (50 iterations in 7.59 seconds) &gt;&gt; Iteration 100: error is 84.202047 (50 iterations in 7.93 seconds) &gt;&gt; Iteration 150: error is 81.634548 (50 iterations in 6.24 seconds) &gt;&gt; Iteration 200: error is 80.924221 (50 iterations in 6.33 seconds) &gt;&gt; Iteration 250: error is 80.681514 (50 iterations in 6.60 seconds) &gt;&gt; Iteration 300: error is 3.272456 (50 iterations in 5.98 seconds) &gt;&gt; Iteration 350: error is 3.003011 (50 iterations in 5.69 seconds) &gt;&gt; Iteration 400: error is 2.860067 (50 iterations in 5.58 seconds) &gt;&gt; Iteration 450: error is 2.771029 (50 iterations in 5.53 seconds) &gt;&gt; Iteration 500: error is 2.708926 (50 iterations in 5.58 seconds) &gt;&gt; Iteration 550: error is 2.662250 (50 iterations in 5.49 seconds) &gt;&gt; Iteration 600: error is 2.626274 (50 iterations in 5.53 seconds) &gt;&gt; Iteration 650: error is 2.597377 (50 iterations in 5.48 seconds) &gt;&gt; Iteration 700: error is 2.573140 (50 iterations in 5.48 seconds) &gt;&gt; Iteration 750: error is 2.553895 (50 iterations in 5.43 seconds) &gt;&gt; Iteration 800: error is 2.540270 (50 iterations in 5.46 seconds) &gt;&gt; Iteration 850: error is 2.531147 (50 iterations in 5.64 seconds) &gt;&gt; Iteration 900: error is 2.524095 (50 iterations in 5.73 seconds) &gt;&gt; Iteration 950: error is 2.517901 (50 iterations in 5.63 seconds) &gt;&gt; Iteration 1000: error is 2.511794 (50 iterations in 5.47 seconds) &gt;&gt; Fitting performed in 118.39 seconds. p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee11770af1-Date-2020-04-15_Time-09-52-22.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee11770af1-Date-2020-04-15_Time-09-52-22.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee339a10ad-Date-2020-04-15_Time-09-52-23.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee339a10ad-Date-2020-04-15_Time-09-52-23.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-TSNE-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : Plot-TSNE-Sample-Clusters.pdf We can also see the results from scran clustering p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efeeb55d566-Date-2020-04-15_Time-09-52-45.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efeeb55d566-Date-2020-04-15_Time-09-52-45.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;TSNE&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee4843c8ed-Date-2020-04-15_Time-09-52-46.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee4843c8ed-Date-2020-04-15_Time-09-52-46.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-tSNE-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : Plot-tSNE-Sample-ScranClusters.pdf "],
["umap-of-previous-reduced-dimensions.html", "6.3 UMAP of previous Reduced Dimensions", " 6.3 UMAP of previous Reduced Dimensions projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI2&quot;, name = &quot;UMAP2&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) &gt;&gt; 09:53:07 UMAP embedding parameters a = 0.583 b = 1.334 &gt;&gt; 09:53:07 Read 10251 rows and found 30 numeric columns &gt;&gt; 09:53:07 Using Annoy for neighbor search, n_neighbors = 30 &gt;&gt; 09:53:07 Building Annoy index with metric = cosine, n_trees = 50 &gt;&gt; 0% 10 20 30 40 50 60 70 80 90 100% &gt;&gt; [—-|—-|—-|—-|—-|—-|—-|—-|—-|—-| &gt;&gt; **************************************************| &gt;&gt; 09:53:10 Writing NN index file to temp file /tmp/RtmpXb8qQa/fileefee233dd970 &gt;&gt; 09:53:10 Searching Annoy index using 10 threads, search_k = 3000 &gt;&gt; 09:53:11 Annoy recall = 100% &gt;&gt; 09:53:12 Commencing smooth kNN distance calibration using 10 threads &gt;&gt; 09:53:13 Initializing from normalized Laplacian + noise &gt;&gt; 09:53:14 Commencing optimization for 200 epochs, with 478078 positive edges &gt;&gt; 09:53:27 Optimization finished p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP2&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee1a41702a-Date-2020-04-15_Time-09-53-28.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee1a41702a-Date-2020-04-15_Time-09-53-28.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP2&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee328899a4-Date-2020-04-15_Time-09-53-29.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee328899a4-Date-2020-04-15_Time-09-53-29.log ggAlignPlots(p1, p2, type = &quot;h&quot;) projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;UMAPHarmony&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) &gt;&gt; 09:53:44 UMAP embedding parameters a = 0.583 b = 1.334 &gt;&gt; 09:53:44 Read 10251 rows and found 30 numeric columns &gt;&gt; 09:53:44 Using Annoy for neighbor search, n_neighbors = 30 &gt;&gt; 09:53:44 Building Annoy index with metric = cosine, n_trees = 50 &gt;&gt; 0% 10 20 30 40 50 60 70 80 90 100% &gt;&gt; [—-|—-|—-|—-|—-|—-|—-|—-|—-|—-| &gt;&gt; **************************************************| &gt;&gt; 09:53:47 Writing NN index file to temp file /tmp/RtmpXb8qQa/fileefee55b054c6 &gt;&gt; 09:53:47 Searching Annoy index using 10 threads, search_k = 3000 &gt;&gt; 09:53:48 Annoy recall = 100% &gt;&gt; 09:53:49 Commencing smooth kNN distance calibration using 10 threads &gt;&gt; 09:53:50 Initializing from normalized Laplacian + noise &gt;&gt; 09:53:51 Commencing optimization for 200 epochs, with 472754 positive edges &gt;&gt; 09:54:01 Optimization finished p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAPHarmony&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efeea6eac67-Date-2020-04-15_Time-09-54-03.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efeea6eac67-Date-2020-04-15_Time-09-54-03.log p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAPHarmony&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee76ae6a66-Date-2020-04-15_Time-09-54-04.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee76ae6a66-Date-2020-04-15_Time-09-54-04.log ggAlignPlots(p3, p4, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2,p3,p4, name = &quot;Plot-UMAP2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : Plot-UMAP2Harmony-Sample-Clusters.pdf "],
["tsne-of-previous-reduced-dimensions.html", "6.4 tSNE of previous Reduced Dimensions", " 6.4 tSNE of previous Reduced Dimensions projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI2&quot;, name = &quot;TSNE2&quot;, perplexity = 30 ) &gt;&gt; Read the 10251 x 30 data matrix successfully! &gt;&gt; OpenMP is working. 9 threads. &gt;&gt; Using no_dims = 2, perplexity = 30.000000, and theta = 0.500000 &gt;&gt; Computing input similarities… &gt;&gt; Building tree… &gt;&gt; - point 10000 of 10251 &gt;&gt; Done in 9.63 seconds (sparsity = 0.013618)! &gt;&gt; Learning embedding… &gt;&gt; Iteration 50: error is 95.772700 (50 iterations in 6.87 seconds) &gt;&gt; Iteration 100: error is 83.923080 (50 iterations in 7.81 seconds) &gt;&gt; Iteration 150: error is 81.348909 (50 iterations in 6.31 seconds) &gt;&gt; Iteration 200: error is 80.912996 (50 iterations in 6.82 seconds) &gt;&gt; Iteration 250: error is 80.714465 (50 iterations in 7.05 seconds) &gt;&gt; Iteration 300: error is 3.324795 (50 iterations in 6.23 seconds) &gt;&gt; Iteration 350: error is 3.087512 (50 iterations in 5.69 seconds) &gt;&gt; Iteration 400: error is 2.960654 (50 iterations in 5.52 seconds) &gt;&gt; Iteration 450: error is 2.882221 (50 iterations in 5.44 seconds) &gt;&gt; Iteration 500: error is 2.826578 (50 iterations in 5.41 seconds) &gt;&gt; Iteration 550: error is 2.785697 (50 iterations in 5.34 seconds) &gt;&gt; Iteration 600: error is 2.752606 (50 iterations in 5.40 seconds) &gt;&gt; Iteration 650: error is 2.725781 (50 iterations in 5.44 seconds) &gt;&gt; Iteration 700: error is 2.705748 (50 iterations in 5.46 seconds) &gt;&gt; Iteration 750: error is 2.689941 (50 iterations in 5.48 seconds) &gt;&gt; Iteration 800: error is 2.678175 (50 iterations in 5.48 seconds) &gt;&gt; Iteration 850: error is 2.669356 (50 iterations in 5.54 seconds) &gt;&gt; Iteration 900: error is 2.662153 (50 iterations in 5.68 seconds) &gt;&gt; Iteration 950: error is 2.654785 (50 iterations in 5.67 seconds) &gt;&gt; Iteration 1000: error is 2.647983 (50 iterations in 5.61 seconds) &gt;&gt; Fitting performed in 118.25 seconds. p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE2&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee7100bd0c-Date-2020-04-15_Time-09-54-51.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee7100bd0c-Date-2020-04-15_Time-09-54-51.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE2&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee65156ac0-Date-2020-04-15_Time-09-54-52.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee65156ac0-Date-2020-04-15_Time-09-54-52.log ggAlignPlots(p1, p2, type = &quot;h&quot;) projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;TSNEHarmony&quot;, perplexity = 30 ) &gt;&gt; Read the 10251 x 30 data matrix successfully! &gt;&gt; OpenMP is working. 9 threads. &gt;&gt; Using no_dims = 2, perplexity = 30.000000, and theta = 0.500000 &gt;&gt; Computing input similarities… &gt;&gt; Building tree… &gt;&gt; - point 10000 of 10251 &gt;&gt; Done in 12.20 seconds (sparsity = 0.013705)! &gt;&gt; Learning embedding… &gt;&gt; Iteration 50: error is 95.841545 (50 iterations in 9.09 seconds) &gt;&gt; Iteration 100: error is 86.878252 (50 iterations in 10.44 seconds) &gt;&gt; Iteration 150: error is 84.458350 (50 iterations in 6.52 seconds) &gt;&gt; Iteration 200: error is 84.214403 (50 iterations in 6.81 seconds) &gt;&gt; Iteration 250: error is 84.119663 (50 iterations in 6.93 seconds) &gt;&gt; Iteration 300: error is 3.435665 (50 iterations in 6.05 seconds) &gt;&gt; Iteration 350: error is 3.186510 (50 iterations in 5.82 seconds) &gt;&gt; Iteration 400: error is 3.055847 (50 iterations in 5.83 seconds) &gt;&gt; Iteration 450: error is 2.971219 (50 iterations in 5.78 seconds) &gt;&gt; Iteration 500: error is 2.911368 (50 iterations in 5.75 seconds) &gt;&gt; Iteration 550: error is 2.867716 (50 iterations in 5.70 seconds) &gt;&gt; Iteration 600: error is 2.833307 (50 iterations in 5.75 seconds) &gt;&gt; Iteration 650: error is 2.806291 (50 iterations in 5.72 seconds) &gt;&gt; Iteration 700: error is 2.784594 (50 iterations in 5.68 seconds) &gt;&gt; Iteration 750: error is 2.767633 (50 iterations in 5.68 seconds) &gt;&gt; Iteration 800: error is 2.754284 (50 iterations in 5.72 seconds) &gt;&gt; Iteration 850: error is 2.743628 (50 iterations in 5.71 seconds) &gt;&gt; Iteration 900: error is 2.735122 (50 iterations in 5.71 seconds) &gt;&gt; Iteration 950: error is 2.727634 (50 iterations in 5.67 seconds) &gt;&gt; Iteration 1000: error is 2.721500 (50 iterations in 5.69 seconds) &gt;&gt; Fitting performed in 126.05 seconds. p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNEHarmony&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee50fc7167-Date-2020-04-15_Time-09-55-42.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee50fc7167-Date-2020-04-15_Time-09-55-42.log p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNEHarmony&quot;) &gt;&gt; ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee8ad75d2-Date-2020-04-15_Time-09-55-42.log &gt;&gt; If there is an issue, please report to github with logFile! &gt;&gt; Getting UMAP Embedding &gt;&gt; ColorBy = cellColData &gt;&gt; Plotting Embedding &gt;&gt; 1 &gt;&gt; ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee8ad75d2-Date-2020-04-15_Time-09-55-42.log ggAlignPlots(p3, p4, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2,p3,p4, name = &quot;Plot-TSNE2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] “plotting ggplot!” &gt;&gt; [1] 0 Download PDF : Plot-TSNE2Harmony-Sample-Clusters.pdf "],
["session-information-5.html", "6.5 Session Information", " 6.5 Session Information Sys.Date() &gt;&gt; [1] “2020-04-15” sessionInfo() "],
["marker-genes-with-archr.html", "Chapter 7 Marker Genes with ArchR ", " Chapter 7 Marker Genes with ArchR "],
["identification-of-marker-genes.html", "7.1 Identification of Marker Genes", " 7.1 Identification of Marker Genes Identify Marker Gene through Pairwise Test vs Bias-Matched Background markersGS &lt;- getMarkerFeatures( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, groupBy = &quot;Clusters&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-f4e4232fa80b-Date-2020-04-15_Time-10-04-48.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Double.Matrix ## 2020-04-15 10:04:49 : Matching Known Biases, 0.009 mins elapsed. ## ## ########### ## 2020-04-15 10:05:23 : Completed Pairwise Tests, 0.585 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-f4e4232fa80b-Date-2020-04-15_Time-10-04-48.log markerList &lt;- getMarkers(markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;) markerList$C6 ## DataFrame with 291 rows and 9 columns ## seqnames start end strand name idx ## ## 8362 chr16 49891830 49524515 2 ZNF423 539 ## 7025 chr14 105714879 105717430 1 BTBD6 764 ## 8726 chr16 89043504 88941263 2 CBFA2T3 903 ## 7024 chr14 105781914 105675623 2 BRF1 763 ## 17158 chr5 997455 988425 2 LOC100506688 18 ## … … … … … … … ## 19084 chr6 119812467 119773712 2 LOC285762 925 ## 18913 chr6 83072923 83077133 1 TPBG 754 ## 12814 chr2 124782864 125672863 1 CNTNAP5 755 ## 20390 chr7 150147962 150176483 1 GIMAP8 1028 ## 7384 chr15 52569397 52569314 2 MIR1266 347 ## Log2FC FDR MeanDiff ## ## 8362 1.94888141545084 2.95473053609015e-21 2.08129078745695 ## 7025 1.88748443360838 3.25360925877231e-15 2.29925343722754 ## 8726 1.5858058377813 3.25360925877231e-15 2.11727644857422 ## 7024 1.41061475820385 2.00400144783449e-14 1.9923490244715 ## 17158 3.16686924437513 2.00400144783449e-14 0.693424444489265 ## … … … … ## 19084 1.36625245611966 0.00853516274073803 0.211727000065234 ## 18913 2.30499450627443 0.00854168013784213 0.544454051635953 ## 12814 2.28305835231306 0.00893526022954534 0.82240450922043 ## 20390 1.52933035478039 0.00910586862792073 0.516763460205267 ## 7384 2.16292224987129 0.00986664274558125 0.22839476831448 We can then plot this as a heatmap markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;EBF1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;CEBPB&quot;, &quot;MPO&quot;, #Monocytes &quot;IRF8&quot;, &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) heatmapGS &lt;- markerHeatmap( seMarker = markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;, labelMarkers = markerGenes, transpose = TRUE ) ## Printing Top Marker Genes: ## C1: ## PADI4, PADI6, CDA, LINC01226, TMEM61, RPE65, PIN1P1, GNAT2, HSD3BP4, SRGAP2D, SNX27, THEM5, S100A8, FCAMR, UCN3, MIR604, MIR938, MIR4679-2, OR56B4, OR52B2 ## C2: ## HES4, FHAD1, PLA2G2C, CELA3A, RHD, FGR, MYCL, BTBD19, TCTEX1D4, SLC5A9, L1TD1, PALMD, FRRS1, GPR88, MYBPHL, CASQ2, NHLH2, SLC22A15, CTSS, S100A11 ## C3: ## PLEKHM2, MIR4422, CLCA3P, LOC729970, ALG14, TMEM56, SLC16A4, FCRL3, AIM2, SLAMF6, C1orf220, MIR4424, RALGPS2, RHEX, FCMR, BPNT1, KMO, LINC00700, ARID5B, MIR548AV ## C4: ## LINC01342, LINC01346, SERINC2, RIMS3, SLFNL1-AS1, EDN2, ROR1, C1orf141, CACNA1S, KLHDC8A, SLC16A9, MIR346, GLYATL2, FAM111B, OR5AN1, RAB30-AS1, BTG4, TEAD4, CD9, PIANP ## C5: ## LRRC38, FAM131C, PLA2G2D, LOC653160, TSPAN1, TTC39A, GBP1P1, LOC100129046, HAO2, RORC, S100A5, S100A4, ILDR2, FMO1, ANGPTL1, LAD1, TNNI1, VASH2, GJC2, KCNK1 ## C6: ## TTLL10, ATP13A2, PAX7, CSMD2, MIR3659, TRABD2B, ERICH3, ABCA4, NTNG1, LOR, FAM189B, UCK2, PHLDA3, LEMD1, SERTAD4-AS1, ESRRG, TRIM67, LOC149373, C1orf131, DEPP1 ## C7: ## TNFRSF4, RUNX3, LEXM, IL12RB2, VCAM1, CHIA, BCL2L15, CD160, PDZK1, SH2D2A, NTRK1, PYHIN1, SLAMF7, FCGR3A, CD247, LOC100505918, FASLG, GAS5-AS1, ATP6V1G3, GREM2 ## C8: ## RCAN3, HPCAL4, ANKRD13C, HHLA3, ZRANB2, PLPPR5, PRMT6, AMIGO1, CHI3L2, CD2, PTGFRN, ACP6, NIT1, NUF2, MIR557, IL19, MIR1265, ANKRD26, ZEB1, ZEB1-AS1 ## C9: ## ESPN, MIR4252, RCAN3AS, HOOK1, ZNF37BP, ZNF239, SLC10A1, TMEM202, RRN3P1, TP53TG3D, MT1F, ZNF286B, FOXO3B, TRIM16L, PEX12, LOC729966, PDCD2L, ZNF283, ZNF610, TLX2 ## C10: ## MIR4689, HES2, NPPA-AS1, MFN2, FBLIM1, KLHDC7A, RPS14P3, FAM43B, MIR378F, GRHL3, TRIM63, GJB3, GJA4, EPHA10, RHBDL2, PPIE, RIMKLA, FAM183A, LINC00853, PDZK1IP1 ## C11: ## NPPA, SFTA1P, WT1-AS, MIR4488, LRRC10B, CACNA1C-AS4, LOC728739, CCNA1, LPO, MPO, TTR, PRTN3, ELANE, OR10H2, NCAN, OXER1, INSM1, BPIFA1, EMILIN3, COL9A3 ## C12: ## LINC02593, VWA1, CHD5, TMEM51-AS1, MFAP2, PADI3, HSPG2, C1QB, MIR4253, KIAA1522, C1orf94, LINC01343, KNCN, DMRTB1, CDCP2, ACOT11, ASB17, CYR61, SLC6A17, LOC643441 ## Identified 2662 markers! ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapGS, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this to a pdf plotPDF(heatmapGS, name = &quot;GeneScores-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE) ## [1] 0 Download PDF : GeneScores-Marker-Heatmap.pdf "],
["marker-genes.html", "7.2 Marker Genes", " 7.2 Marker Genes markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;MPO&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;#TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, quantCut = c(0.01, 0.95), imputeWeights = NULL ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f4e44c020f3e-Date-2020-04-15_Time-10-05-43.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f4e44c020f3e-Date-2020-04-15_Time-10-05-43.log To plot a specific gene try p$CD14 To plot all genes we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-WO-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-UMAP-Marker-Genes-WO-Imputation.pdf "],
["marker-genes-imputation-with-magic.html", "7.3 Marker Genes Imputation with Magic", " 7.3 Marker Genes Imputation with Magic projHeme2 &lt;- addImputeWeights(projHeme2) ## 2020-04-15 10:06:25 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 10:06:36 : Completed Getting Magic Weights!, 0.19 mins elapsed. Now lets see how this effects our marker gene scores overlayed on our 2-d embedding. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;MPO&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;#TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme2) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f4e41cd9b447-Date-2020-04-15_Time-10-06-36.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f4e41cd9b447-Date-2020-04-15_Time-10-06-36.log To plot a specific gene try p$CD14 To plot all genes we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-W-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-UMAP-Marker-Genes-W-Imputation.pdf "],
["track-plotting-with-archrbrowser.html", "7.4 Track Plotting with ArchRBrowser", " 7.4 Track Plotting with ArchRBrowser markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- ArchRBrowserTrack( ArchRProj = projHeme2, groupBy = &quot;Clusters&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000 ) ## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-f4e46f9da45e-Date-2020-04-15_Time-10-07-24.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:07:24 : Validating Region, 0.006 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 10:07:25 : Adding Bulk Tracks (1 of 9), 0.009 mins elapsed. ## 2020-04-15 10:07:27 : Adding Gene Tracks (1 of 9), 0.044 mins elapsed. ## 2020-04-15 10:07:27 : Plotting, 0.054 mins elapsed. ## 2020-04-15 10:07:29 : Adding Bulk Tracks (2 of 9), 0.09 mins elapsed. ## 2020-04-15 10:07:31 : Adding Gene Tracks (2 of 9), 0.108 mins elapsed. ## 2020-04-15 10:07:31 : Plotting, 0.117 mins elapsed. ## 2020-04-15 10:07:34 : Adding Bulk Tracks (3 of 9), 0.157 mins elapsed. ## 2020-04-15 10:07:35 : Adding Gene Tracks (3 of 9), 0.175 mins elapsed. ## 2020-04-15 10:07:35 : Plotting, 0.183 mins elapsed. ## 2020-04-15 10:07:37 : Adding Bulk Tracks (4 of 9), 0.221 mins elapsed. ## 2020-04-15 10:07:38 : Adding Gene Tracks (4 of 9), 0.239 mins elapsed. ## 2020-04-15 10:07:39 : Plotting, 0.249 mins elapsed. ## 2020-04-15 10:07:41 : Adding Bulk Tracks (5 of 9), 0.279 mins elapsed. ## 2020-04-15 10:07:42 : Adding Gene Tracks (5 of 9), 0.295 mins elapsed. ## 2020-04-15 10:07:42 : Plotting, 0.301 mins elapsed. ## 2020-04-15 10:07:44 : Adding Bulk Tracks (6 of 9), 0.339 mins elapsed. ## 2020-04-15 10:07:46 : Adding Gene Tracks (6 of 9), 0.358 mins elapsed. ## 2020-04-15 10:07:46 : Plotting, 0.367 mins elapsed. ## 2020-04-15 10:07:49 : Adding Bulk Tracks (7 of 9), 0.409 mins elapsed. ## 2020-04-15 10:07:50 : Adding Gene Tracks (7 of 9), 0.429 mins elapsed. ## 2020-04-15 10:07:50 : Plotting, 0.44 mins elapsed. ## 2020-04-15 10:07:54 : Adding Bulk Tracks (8 of 9), 0.502 mins elapsed. ## 2020-04-15 10:07:55 : Adding Gene Tracks (8 of 9), 0.52 mins elapsed. ## 2020-04-15 10:07:56 : Plotting, 0.528 mins elapsed. ## 2020-04-15 10:07:58 : Adding Bulk Tracks (9 of 9), 0.567 mins elapsed. ## 2020-04-15 10:07:59 : Adding Gene Tracks (9 of 9), 0.585 mins elapsed. ## 2020-04-15 10:08:00 : Plotting, 0.593 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-f4e46f9da45e-Date-2020-04-15_Time-10-07-24.log To plot a track we can simply print one from the list grid::grid.newpage() grid::grid.draw(p$CD14) We can save pdfs with plotPDF plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## [1] 0 Download PDF : Plot-Tracks-Marker-Genes.pdf "],
["launching-the-archrbrowser.html", "7.5 Launching the ArchRBrowser", " 7.5 Launching the ArchRBrowser #ArchRBrowser(projHeme2) "],
["session-information-6.html", "7.6 Session Information", " 7.6 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["labeling-clusters-with-scrna.html", "Chapter 8 Labeling Clusters with scRNA ", " Chapter 8 Labeling Clusters with scRNA "],
["labeling-scatac-cells-with-scrna-clusters.html", "8.1 Labeling scATAC cells with scRNA clusters", " 8.1 Labeling scATAC cells with scRNA clusters First we need to download scRNA data for hematopoiesis from Granja* et al (2019). #111 MB Download if(!file.exists(&quot;scRNA-Hematopoiesis-Granja-2019.rds&quot;)){ download.file( url = &quot;https://jeffgranja.s3.amazonaws.com/ArchR/TestData/scRNA-Hematopoiesis-Granja-2019.rds&quot;, destfile = &quot;scRNA-Hematopoiesis-Granja-2019.rds&quot; ) } seRNA &lt;- readRDS(&quot;scRNA-Hematopoiesis-Granja-2019.rds&quot;) seRNA ## class: RangedSummarizedExperiment ## dim: 20287 35582 ## metadata(0): ## assays(1): counts ## rownames(20287): FAM138A OR4F5 … S100B PRMT2 ## rowData names(3): gene_name gene_id exonLength ## colnames(35582): CD34_32_R5:AAACCTGAGTATCGAA-1 ## CD34_32_R5:AAACCTGAGTCGTTTG-1 … ## BMMC_10x_GREENLEAF_REP2:TTTGTTGCATGTGTCA-1 ## BMMC_10x_GREENLEAF_REP2:TTTGTTGCATTGAAAG-1 ## colData names(10): Group nUMI_pre … BioClassification Barcode colnames(colData(seRNA)) ## [1] “Group” “nUMI_pre” “nUMI” ## [4] “nGene” “initialClusters” “UMAP1” ## [7] “UMAP2” “Clusters” “BioClassification” ## [10] “Barcode” table(colData(seRNA)$BioClassification) ## 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP ## 1425 1653 446 111 2260 ## 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC ## 903 2097 1050 544 325 ## 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 ## 1800 4222 292 520 377 ## 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 ## 710 1711 62 1521 2470 ## 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK ## 2364 3539 796 2080 2143 ## 26_Unk ## 161 Unconstrained Integration (not-recommended) #~5 minutes projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = FALSE, groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell_Un&quot;, #Name of column where cell from scRNA is matched to each cell nameGroup = &quot;predictedGroup_Un&quot;, #Name of column where group from scRNA is matched to each cell nameScore = &quot;predictedScore_Un&quot; #Name of column where prediction score from scRNA ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f6635e453cfd-Date-2020-04-15_Time-10-08-55.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:08:56 : Running Seurat’s Integration Stuart* et al 2019, 0.005 mins elapsed. ## 2020-04-15 10:09:06 : Checking ATAC Input, 0.172 mins elapsed. ## 2020-04-15 10:09:06 : Checking RNA Input, 0.173 mins elapsed. ## 2020-04-15 10:09:17 : Creating Integration Blocks, 0.367 mins elapsed. ## 2020-04-15 10:09:18 : Prepping Interation Data, 0.372 mins elapsed. ## 2020-04-15 10:09:19 : Computing Integration in 1 Integration Blocks!, 0 mins elapsed. ## 2020-04-15 10:09:19 : Block (1 of 1) : Computing Integration, 0 mins elapsed. ## 2020-04-15 10:09:23 : Block (1 of 1) : Identifying Variable Genes, 0.071 mins elapsed. ## 2020-04-15 10:09:28 : Block (1 of 1) : Getting GeneScoreMatrix, 0.146 mins elapsed. ## 2020-04-15 10:09:37 : Block (1 of 1) : Imputing GeneScoreMatrix, 0.298 mins elapsed. ## 2020-04-15 10:09:37 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 10:09:37 : Computing Partial Diffusion Matrix with Magic (1 of 2), 0 mins elapsed. ## 2020-04-15 10:09:44 : Computing Partial Diffusion Matrix with Magic (2 of 2), 0.122 mins elapsed. ## 2020-04-15 10:09:51 : Completed Getting Magic Weights!, 0.242 mins elapsed. ## Getting ImputeWeights ## Using weights on disk ## Using weights on disk ## Getting ImputeWeights ## 2020-04-15 10:10:17 : Block (1 of 1) : Seurat FindTransferAnchors, 0.968 mins elapsed. ## 2020-04-15 10:12:00 : Block (1 of 1) : Seurat TransferData Cell Labels, 2.681 mins elapsed. ## 2020-04-15 10:12:34 : Block (1 of 1) : Completed Integration, 3.243 mins elapsed. ## 2020-04-15 10:12:34 : Completed Integration with RNA Matrix, 3.256 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f6635e453cfd-Date-2020-04-15_Time-10-08-55.log Constrained Integration (recommended) #We can use the unconstrained fits to help identify which are T/NK Cells cM &lt;- as.matrix(confusionMatrix(projHeme2$Clusters, projHeme2$predictedGroup_Un)) preClust &lt;- colnames(cM)[apply(cM, 1 , which.max)] cbind(preClust, rownames(cM)) #Assignments ## preClust ## [1,] “17_B” “C3” ## [2,] “20_CD4.N1” “C8” ## [3,] “16_Pre.B” “C4” ## [4,] “08_GMP.Neut” “C11” ## [5,] “11_CD14.Mono.1” “C1” ## [6,] “01_HSC” “C12” ## [7,] “03_Late.Eryth” “C10” ## [8,] “22_CD4.M” “C9” ## [9,] “25_NK” “C7” ## [10,] “09_pDC” “C5” ## [11,] “12_CD14.Mono.2” “C2” ## [12,] “15_CLP.2” “C6” #From scRNA cTNK &lt;- paste0(paste0(19:25), collapse=&quot;|&quot;) cTNK ## [1] “19|20|21|22|23|24|25” cNonTNK &lt;- paste0(c(paste0(&quot;0&quot;, 1:9), 10:13, 15:18), collapse=&quot;|&quot;) cNonTNK ## [1] “01|02|03|04|05|06|07|08|09|10|11|12|13|15|16|17|18” #Assign scATAC to these categories clustTNK &lt;- rownames(cM)[grep(cTNK, preClust)] clustTNK ## [1] “C8” “C9” “C7” clustNonTNK &lt;- rownames(cM)[grep(cNonTNK, preClust)] clustNonTNK ## [1] “C3” “C4” “C11” “C1” “C12” “C10” “C5” “C2” “C6” #RNA get cells in these categories rnaTNK &lt;- colnames(seRNA)[grep(cTNK, colData(seRNA)$BioClassification)] head(rnaTNK) ## [1] “PBMC_10x_GREENLEAF_REP1:AAACCCAGTCGTCATA-1” ## [2] “PBMC_10x_GREENLEAF_REP1:AAACCCATCCGATGTA-1” ## [3] “PBMC_10x_GREENLEAF_REP1:AAACCCATCTCAACGA-1” ## [4] “PBMC_10x_GREENLEAF_REP1:AAACCCATCTCTCGAC-1” ## [5] “PBMC_10x_GREENLEAF_REP1:AAACGAACAATCGTCA-1” ## [6] “PBMC_10x_GREENLEAF_REP1:AAACGAACACGATTCA-1” rnaNonTNK &lt;- colnames(seRNA)[grep(cNonTNK, colData(seRNA)$BioClassification)] head(rnaNonTNK) ## [1] “CD34_32_R5:AAACCTGAGTATCGAA-1” “CD34_32_R5:AAACCTGAGTCGTTTG-1” ## [3] “CD34_32_R5:AAACCTGGTTCCACAA-1” “CD34_32_R5:AAACGGGAGCTTCGCG-1” ## [5] “CD34_32_R5:AAACGGGAGGGAGTAA-1” “CD34_32_R5:AAACGGGAGTTACGGG-1” groupList &lt;- SimpleList( TNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustTNK], RNA = rnaTNK ), NonTNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustNonTNK], RNA = rnaNonTNK ) ) #~5 minutes projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = FALSE, groupList = groupList, #Constrain List groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell_Co&quot;, #Name of column where cell from scRNA is matched to each cell nameGroup = &quot;predictedGroup_Co&quot;, #Name of column where group from scRNA is matched to each cell nameScore = &quot;predictedScore_Co&quot; #Name of column where prediction score from scRNA ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f663618b2629-Date-2020-04-15_Time-10-12-35.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:12:36 : Running Seurat’s Integration Stuart* et al 2019, 0.014 mins elapsed. ## 2020-04-15 10:12:36 : Checking ATAC Input, 0.027 mins elapsed. ## 2020-04-15 10:12:36 : Checking RNA Input, 0.027 mins elapsed. ## 2020-04-15 10:12:48 : Creating Integration Blocks, 0.218 mins elapsed. ## 2020-04-15 10:12:48 : Prepping Interation Data, 0.222 mins elapsed. ## 2020-04-15 10:12:49 : Computing Integration in 2 Integration Blocks!, 0 mins elapsed. ## 2020-04-15 10:15:24 : Completed Integration with RNA Matrix, 2.574 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f663618b2629-Date-2020-04-15_Time-10-12-35.log Compare results pal &lt;- paletteDiscrete(values = colData(seRNA)$BioClassification) ## Length of unique values greater than palette, interpolating.. pal ## 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP ## “#D51F26” “#502A59” “#235D55” “#3D6E57” “#8D2B8B” ## 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC ## “#DE6C3E” “#F9B712” “#D8CE42” “#8E9ACD” “#B774B1” ## 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 ## “#D69FC8” “#C7C8DE” “#8FD3D4” “#89C86E” “#CC9672” ## 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 ## “#CF7E96” “#A27AA4” “#CD4F32” “#6B977E” “#518AA3” ## 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK ## “#5A5297” “#0F707D” “#5E2E32” “#A95A3C” “#B28D5C” ## 26_Unk ## “#3D3D3D” p1 &lt;- plotEmbedding( projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup_Un&quot;, pal = pal ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f66351b51d5d-Date-2020-04-15_Time-10-15-31.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f66351b51d5d-Date-2020-04-15_Time-10-15-31.log p1 p2 &lt;- plotEmbedding( projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup_Co&quot;, pal = pal ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f6632ef266a4-Date-2020-04-15_Time-10-15-49.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f6632ef266a4-Date-2020-04-15_Time-10-15-49.log p2 To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-RNA-Integration.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 "],
["adding-pseudo-scrna-profiles-for-each-scatac-cell.html", "8.2 Adding Pseudo-scRNA profiles for each scATAC cell", " 8.2 Adding Pseudo-scRNA profiles for each scATAC cell We can save our original projHeme2 using saveArchRProject from ArchR. saveArchRProject(ArchRProj = projHeme2, outputDirectory = &quot;Save-ProjHeme2&quot;, load = FALSE) ## Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme2 ## Copying Arrow Files… ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights… ## Copying Other Files… ## Copying Other Files (1 of 4): Embeddings ## Copying Other Files (2 of 4): IterativeLSI ## Copying Other Files (3 of 4): IterativeLSI2 ## Copying Other Files (4 of 4): Plots ## Saving ArchRProject… Once you are satisfied with the results you can re-run with adding the gene expression to the Arrow Files groupList &lt;- SimpleList( TNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustTNK], RNA = rnaTNK ), NonTNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustNonTNK], RNA = rnaNonTNK ) ) groupList ## List of length 2 ## names(2): TNK NonTNK #~5 minutes projHeme3 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = TRUE, #Now we add gene expression to Arrow Files force= TRUE, groupList = groupList, #Constrain List groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell&quot;, #Name of column where cell from scRNA is matched to each cell nameGroup = &quot;predictedGroup&quot;, #Name of column where group from scRNA is matched to each cell nameScore = &quot;predictedScore&quot; #Name of column where prediction score from scRNA ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f66317d3557e-Date-2020-04-15_Time-10-16-26.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:16:26 : Running Seurat’s Integration Stuart* et al 2019, 0.009 mins elapsed. ## 2020-04-15 10:16:27 : Checking ATAC Input, 0.021 mins elapsed. ## 2020-04-15 10:16:27 : Checking RNA Input, 0.021 mins elapsed. ## 2020-04-15 10:16:38 : Creating Integration Blocks, 0.211 mins elapsed. ## 2020-04-15 10:16:39 : Prepping Interation Data, 0.215 mins elapsed. ## 2020-04-15 10:16:39 : Computing Integration in 2 Integration Blocks!, 0 mins elapsed. ## 2020-04-15 10:19:30 : Transferring Data to ArrowFiles, 2.843 mins elapsed. ## 2020-04-15 10:20:47 : Completed Integration with RNA Matrix, 4.133 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f66317d3557e-Date-2020-04-15_Time-10-16-26.log What matrices are available? getAvailableMatrices(projHeme3) ## [1] “GeneIntegrationMatrix” “GeneScoreMatrix” “TileMatrix” Now lets see how this effects our marker gene scores overlayed on our 2-d embedding. projHeme3 &lt;- addImputeWeights(projHeme3) ## 2020-04-15 10:20:49 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 10:20:59 : Completed Getting Magic Weights!, 0.176 mins elapsed. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p1 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneIntegrationMatrix&quot;, name = markerGenes, continuousSet = &quot;horizonExtra&quot;, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f66370e499ac-Date-2020-04-15_Time-10-20-59.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f66370e499ac-Date-2020-04-15_Time-10-20-59.log p2 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneScoreMatrix&quot;, continuousSet = &quot;horizonExtra&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f6632d4259ce-Date-2020-04-15_Time-10-21-15.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f6632d4259ce-Date-2020-04-15_Time-10-21-15.log To plot all marker genes we can use cowplot #Rearrange for grid plotting p1c &lt;- lapply(p1, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) #Rearrange for grid plotting p2c &lt;- lapply(p2, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3), p1c)) do.call(cowplot::plot_grid, c(list(ncol = 3), p2c)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p1, name = &quot;Plot-UMAP-Marker-Genes-RNA-W-Imputation.pdf&quot;, ArchRProj = projHeme3, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 "],
["labeling-scatac-clusters-with-scrna.html", "8.3 Labeling scATAC clusters with scRNA", " 8.3 Labeling scATAC clusters with scRNA Now that we have pretty good scRNA and scATAC correspondence we can label our clusters with scRNA ## [1] “plotting ggplot!” ## [1] 0 To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, name = &quot;Plot-UMAP-Remap-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) "],
["session-information-7.html", "8.4 Session Information", " 8.4 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["calling-peaks-with-archr.html", "Chapter 9 Calling Peaks with ArchR ", " Chapter 9 Calling Peaks with ArchR "],
["calling-peaks-w-macs2.html", "9.1 Calling Peaks w/ Macs2", " 9.1 Calling Peaks w/ Macs2 We can now save our original projHeme3 using saveArchRProject from ArchR. saveArchRProject(ArchRProj = projHeme3, outputDirectory = &quot;Save-ProjHeme3&quot;, load = FALSE) ## Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme3 ## Copying Arrow Files… ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights… ## Copying Other Files… ## Copying Other Files (1 of 4): Embeddings ## Copying Other Files (2 of 4): IterativeLSI ## Copying Other Files (3 of 4): IterativeLSI2 ## Copying Other Files (4 of 4): Plots ## Saving ArchRProject… #Create Group Coverage Files that can be used for downstream analysis (~5-10 minutes) projHeme4 &lt;- addGroupCoverages(ArchRProj = projHeme3, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-addGroupCoverages-faba40cd6ba1-Date-2020-04-15_Time-10-23-14.log ## If there is an issue, please report to github with logFile! ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## 2020-04-15 10:23:17 : Creating Coverage Files!, 0.046 mins elapsed. ## 2020-04-15 10:23:17 : Batch Execution w/ safelapply!, 0.046 mins elapsed. ## 2020-04-15 10:24:14 : Adding Kmer Bias to Coverage Files!, 0.996 mins elapsed. ## ## Completed Kmer Bias Calculation ## Adding Kmer Bias (1 of 22) ## Adding Kmer Bias (2 of 22) ## Adding Kmer Bias (3 of 22) ## Adding Kmer Bias (4 of 22) ## Adding Kmer Bias (5 of 22) ## Adding Kmer Bias (6 of 22) ## Adding Kmer Bias (7 of 22) ## Adding Kmer Bias (8 of 22) ## Adding Kmer Bias (9 of 22) ## Adding Kmer Bias (10 of 22) ## Adding Kmer Bias (11 of 22) ## Adding Kmer Bias (12 of 22) ## Adding Kmer Bias (13 of 22) ## Adding Kmer Bias (14 of 22) ## Adding Kmer Bias (15 of 22) ## Adding Kmer Bias (16 of 22) ## Adding Kmer Bias (17 of 22) ## Adding Kmer Bias (18 of 22) ## Adding Kmer Bias (19 of 22) ## Adding Kmer Bias (20 of 22) ## Adding Kmer Bias (21 of 22) ## Adding Kmer Bias (22 of 22) ## 2020-04-15 10:25:16 : Finished Creation of Coverage Files!, 2.022 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGroupCoverages-faba40cd6ba1-Date-2020-04-15_Time-10-23-14.log #Find Path to Macs2 binary. This function sometimes struggles if you are using conda environment #for installation of python packages. If this function fails try providing a direct path manually pathToMacs2 &lt;- findMacs2() ## Searching For MACS2.. ## Found with $path! #Call Reproducible Peaks w/ Macs2 (~5-10 minutes) projHeme4 &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters2&quot;, pathToMacs2 = pathToMacs2 ) ## ArchR logging to : ArchRLogs/ArchR-addReproduciblePeakSet-faba719c230c-Date-2020-04-15_Time-10-25-16.log ## If there is an issue, please report to github with logFile! ## Calling Peaks with Macs2 ## 2020-04-15 10:25:17 : Peak Calling Parameters!, 0.014 mins elapsed. ## Group nCells nCellsUsed nReplicates nMin nMax maxPeaks ## B B 439 433 2 182 251 150000 ## CD4.M CD4.M 678 617 2 117 500 150000 ## CD4.N CD4.N 1271 552 2 52 500 150000 ## CLP CLP 387 387 2 82 305 150000 ## Erythroid Erythroid 879 694 2 194 500 150000 ## GMP GMP 793 751 2 251 500 150000 ## Mono Mono 2632 1000 2 500 500 150000 ## NK NK 851 801 2 301 500 150000 ## pDC pDC 320 311 2 150 161 150000 ## PreB PreB 351 351 2 40 311 150000 ## Progenitor Progenitor 1650 672 2 172 500 150000 ## 2020-04-15 10:25:17 : Batching Peak Calls!, 0.014 mins elapsed. ## 2020-04-15 10:25:17 : Batch Execution w/ safelapply!, 0 mins elapsed. ## 2020-04-15 10:27:01 : Identifying Reproducible Peaks!, 1.74 mins elapsed. ## 2020-04-15 10:27:09 : Creating Union Peak Set!, 1.886 mins elapsed. ## Converged after 7 iterations! ## [1] “plotting ggplot!” ## 2020-04-15 10:27:15 : Finished Creating Union Peak Set (144009)!, 1.98 mins elapsed. getPeakSet(projHeme4) ## GRanges object with 144009 ranges and 12 metadata columns: ## seqnames ranges strand | score ## | ## Mono chr1 752499-752999 * | 24.54003 ## NK chr1 762651-763151 * | 141.22064 ## B chr1 801006-801506 * | 14.18461 ## B chr1 805039-805539 * | 37.30365 ## CLP chr1 845325-845825 * | 2.81281 ## … … … … . … ## Erythroid chrX 154664540-154665040 * | 7.09786 ## NK chrX 154807324-154807824 * | 9.38477 ## PreB chrX 154840785-154841285 * | 3.29501 ## PreB chrX 154842404-154842904 * | 7.68692 ## NK chrX 154862017-154862517 * | 12.44 ## replicateScoreQuantile groupScoreQuantile Reproducibility ## ## Mono 0.812 0.655 2 ## NK 0.887 0.797 2 ## B 0.7 0.418 2 ## B 0.959 0.9 2 ## CLP 0.706 0.311 2 ## … … … … ## Erythroid 0.69 0.279 2 ## NK 0.424 0.166 2 ## PreB 0.669 0.274 2 ## PreB 0.932 0.772 2 ## NK 0.492 0.202 2 ## GroupReplicate distToGeneStart nearestGene peakType ## ## Mono Mono._.scATAC_PBMC_R1 10152 LINC00115 Distal ## NK NK._.scATAC_PBMC_R1 0 LINC00115 Promoter ## B B._.scATAC_PBMC_R1 10925 FAM41C Distal ## B B._.scATAC_BMMC_R1 6892 FAM41C Intronic ## CLP CLP._.scATAC_BMMC_R1 9241 LINC02593 Distal ## … … … … … ## Erythroid Erythroid._.scATAC_BMMC_R1 100803 CLIC2 Distal ## NK NK._.scATAC_PBMC_R1 35047 TMLHE Intronic ## PreB PreB._.Rep2 1586 TMLHE Intronic ## PreB PreB._.Rep2 31 TMLHE Promoter ## NK NK._.scATAC_PBMC_R1 19644 TMLHE Distal ## distToTSS nearestTSS GC idx ## ## Mono 10152 uc001aau.3 0.483 1 ## NK 0 uc001aau.3 0.6906 2 ## B 10925 uc021oei.1 0.4371 3 ## B 6892 uc021oei.1 0.7285 4 ## CLP 1239 uc010nxu.2 0.7904 5 ## … … … … … ## Erythroid 22387 uc004cim.2 0.515 3462 ## NK 35047 uc004cin.3 0.525 3463 ## PreB 1586 uc004cin.3 0.485 3464 ## PreB 31 uc004cin.3 0.5888 3465 ## NK 19644 uc004cin.3 0.4212 3466 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths "],
["calling-peaks-w-tilematrix.html", "9.2 Calling Peaks w/ TileMatrix", " 9.2 Calling Peaks w/ TileMatrix #Call Reproducible Peaks w/ TileMatrix (~2 minutes) projHemeTmp &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters2&quot;, peakMethod = &quot;Tiles&quot;, method = &quot;p&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addReproduciblePeakSet-faba49485623-Date-2020-04-15_Time-10-27-15.log ## If there is an issue, please report to github with logFile! ## Calling Peaks with TileMatrix ## Group Coverages Already Computed Returning Groups, Set force = TRUE to Recompute! ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor ## 2020-04-15 10:27:16 : Peak Calling Parameters!, 0.012 mins elapsed. ## Group nCells nCellsUsed nReplicates nMin nMax maxPeaks ## B B 439 433 2 182 251 150000 ## CD4.M CD4.M 678 617 2 117 500 150000 ## CD4.N CD4.N 1271 552 2 52 500 150000 ## CLP CLP 387 387 2 82 305 150000 ## Erythroid Erythroid 879 694 2 194 500 150000 ## GMP GMP 793 751 2 251 500 150000 ## Mono Mono 2632 1000 2 500 500 150000 ## NK NK 851 801 2 301 500 150000 ## pDC pDC 320 311 2 150 161 150000 ## PreB PreB 351 351 2 40 311 150000 ## Progenitor Progenitor 1650 672 2 172 500 150000 ## 2020-04-15 10:27:24 : Computing Total Accessibility Across All Features, 0.138 mins elapsed. ## 2020-04-15 10:27:27 : Computing Pseudo-Grouped Tile Matrix, 0.19 mins elapsed. ## 2020-04-15 10:28:07 : Created Pseudo-Grouped Tile Matrix (0.474 GB), 0.866 mins elapsed. ## Expectation = 0.137769200114613Expectation = 0.170233276575844Expectation = 0.502430087836881Expectation = 0.0743484690298421Expectation = 0.231170400914268Expectation = 0.0293481232153502Expectation = 0.188425424281447Expectation = 0.0412872862125409Expectation = 0.369108556109225Expectation = 0.120760726012825Expectation = 0.33554874172927Expectation = 0.330837760307742Expectation = 0.41068352704434Expectation = 0.343789007051322Expectation = 0.571660173038985Expectation = 0.180700422552374Expectation = 0.126306931769154Expectation = 0.107652051338631Expectation = 0.200607316117261Expectation = 0.0248573103536859Expectation = 0.38762741617292Expectation = 0.0990605372969163 ## 2020-04-15 10:28:51 : Creating Group Peak Sets with Annotations!, 1.59 mins elapsed. ## 2020-04-15 10:29:03 : Creating Union Peak Set with Annotations!, 1.789 mins elapsed. ## Annotating Peaks : Nearest Gene ## Annotating Peaks : Gene ## Annotating Peaks : TSS ## Annotating Peaks : GC ## [1] “plotting ggplot!” ## 2020-04-15 10:29:22 : Finished Creating Union Peak Set (271917)!, 2.104 mins elapsed. getPeakSet(projHemeTmp) ## GRanges object with 271917 ranges and 9 metadata columns: ## seqnames ranges strand | mlog10p Group ## | ## [1] chr1 752000-752499 * | 0.742 Mono ## [2] chr1 752500-752999 * | 6.561 Mono ## [3] chr1 758500-758999 * | 1.11 NK ## [4] chr1 762000-762499 * | 2.461 NK ## [5] chr1 762500-762999 * | 22.536 NK ## … … … … . … … ## [271913] chrX 154862000-154862499 * | 1.966 NK ## [271914] chrX 154862500-154862999 * | 1.334 NK ## [271915] chrX 154912500-154912999 * | 2.01 Erythroid ## [271916] chrX 154997000-154997499 * | 1.349 Progenitor ## [271917] chrX 154998000-154998499 * | 1.227 Mono ## distToGeneStart nearestGene peakType distToTSS nearestTSS ## ## [1] 10652 LINC00115 Distal 10652 uc001aau.3 ## [2] 10152 LINC00115 Distal 10152 uc001aau.3 ## [3] 4152 LINC00115 Distal 4152 uc001aau.3 ## [4] 652 LINC00115 Promoter 652 uc001aau.3 ## [5] 152 LINC00115 Promoter 152 uc001aau.3 ## … … … … … … ## [271913] 19626 TMLHE Distal 19626 uc004cin.3 ## [271914] 20126 TMLHE Distal 20126 uc004cin.3 ## [271915] 70126 TMLHE Distal 70126 uc004cin.3 ## [271916] 154626 TMLHE Distal 201 uc004cin.3 ## [271917] 155626 TMLHE Distal 797 uc004cin.3 ## GC idx ## ## [1] 0.376 1 ## [2] 0.484 2 ## [3] 0.56 3 ## [4] 0.574 4 ## [5] 0.684 5 ## … … … ## [271913] 0.43 6212 ## [271914] 0.42 6213 ## [271915] 0.368 6214 ## [271916] 0.542 6215 ## [271917] 0.476 6216 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Lets see how well this compares to Macs2 #Peak Overlap length(subsetByOverlaps(getPeakSet(projHeme4), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) ## [1] 0.9627246 length(subsetByOverlaps(getPeakSet(projHemeTmp), getPeakSet(projHeme4))) / length(getPeakSet(projHemeTmp)) ## [1] 0.7533365 #Extend to 1kb length(subsetByOverlaps(resize(getPeakSet(projHeme4), 1000, &quot;center&quot;), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) ## [1] 0.9676687 length(subsetByOverlaps(getPeakSet(projHemeTmp), resize(getPeakSet(projHeme4), 1000, &quot;center&quot;))) / length(getPeakSet(projHemeTmp)) ## [1] 0.8287639 "],
["add-peak-matrix.html", "9.3 Add Peak Matrix", " 9.3 Add Peak Matrix We can now save our original projHeme4 using saveArchRProject from ArchR. saveArchRProject(ArchRProj = projHeme4, outputDirectory = &quot;Save-ProjHeme4&quot;, load = FALSE) ## Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme4 ## Copying Arrow Files… ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights… ## Copying Other Files… ## Copying Other Files (1 of 6): Embeddings ## Copying Other Files (2 of 6): GroupCoverages ## Copying Other Files (3 of 6): IterativeLSI ## Copying Other Files (4 of 6): IterativeLSI2 ## Copying Other Files (5 of 6): PeakCalls ## Copying Other Files (6 of 6): Plots ## Saving ArchRProject… getPeakSet(projHeme4) ## GRanges object with 144009 ranges and 12 metadata columns: ## seqnames ranges strand | score ## | ## Mono chr1 752499-752999 * | 24.54003 ## NK chr1 762651-763151 * | 141.22064 ## B chr1 801006-801506 * | 14.18461 ## B chr1 805039-805539 * | 37.30365 ## CLP chr1 845325-845825 * | 2.81281 ## … … … … . … ## Erythroid chrX 154664540-154665040 * | 7.09786 ## NK chrX 154807324-154807824 * | 9.38477 ## PreB chrX 154840785-154841285 * | 3.29501 ## PreB chrX 154842404-154842904 * | 7.68692 ## NK chrX 154862017-154862517 * | 12.44 ## replicateScoreQuantile groupScoreQuantile Reproducibility ## ## Mono 0.812 0.655 2 ## NK 0.887 0.797 2 ## B 0.7 0.418 2 ## B 0.959 0.9 2 ## CLP 0.706 0.311 2 ## … … … … ## Erythroid 0.69 0.279 2 ## NK 0.424 0.166 2 ## PreB 0.669 0.274 2 ## PreB 0.932 0.772 2 ## NK 0.492 0.202 2 ## GroupReplicate distToGeneStart nearestGene peakType ## ## Mono Mono._.scATAC_PBMC_R1 10152 LINC00115 Distal ## NK NK._.scATAC_PBMC_R1 0 LINC00115 Promoter ## B B._.scATAC_PBMC_R1 10925 FAM41C Distal ## B B._.scATAC_BMMC_R1 6892 FAM41C Intronic ## CLP CLP._.scATAC_BMMC_R1 9241 LINC02593 Distal ## … … … … … ## Erythroid Erythroid._.scATAC_BMMC_R1 100803 CLIC2 Distal ## NK NK._.scATAC_PBMC_R1 35047 TMLHE Intronic ## PreB PreB._.Rep2 1586 TMLHE Intronic ## PreB PreB._.Rep2 31 TMLHE Promoter ## NK NK._.scATAC_PBMC_R1 19644 TMLHE Distal ## distToTSS nearestTSS GC idx ## ## Mono 10152 uc001aau.3 0.483 1 ## NK 0 uc001aau.3 0.6906 2 ## B 10925 uc021oei.1 0.4371 3 ## B 6892 uc021oei.1 0.7285 4 ## CLP 1239 uc010nxu.2 0.7904 5 ## … … … … … ## Erythroid 22387 uc004cim.2 0.515 3462 ## NK 35047 uc004cin.3 0.525 3463 ## PreB 1586 uc004cin.3 0.485 3464 ## PreB 31 uc004cin.3 0.5888 3465 ## NK 19644 uc004cin.3 0.4212 3466 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths #~1-2 Minutes projHeme5 &lt;- addPeakMatrix(projHeme4) ## ArchR logging to : ArchRLogs/ArchR-addPeakMatrix-faba377aa2f2-Date-2020-04-15_Time-10-29-40.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:29:41 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeakMatrix-faba377aa2f2-Date-2020-04-15_Time-10-29-40.log getAvailableMatrices(projHeme5) ## [1] “GeneIntegrationMatrix” “GeneScoreMatrix” “PeakMatrix” ## [4] “TileMatrix” "],
["session-information-8.html", "9.4 Session Information", " 9.4 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["identifying-marker-peaks-with-archr.html", "Chapter 10 Identifying Marker Peaks with ArchR ", " Chapter 10 Identifying Marker Peaks with ArchR "],
["identifying-marker-peaks-with-archr-1.html", "10.1 Identifying Marker Peaks with ArchR", " 10.1 Identifying Marker Peaks with ArchR Often times, we are interested to know which peaks are unique to an individual cluster or a small group of clusters. We can do this in an unsupervised fashion in ArchR: addArchRThreads(8) ## Setting default number of Parallel threads to 8. #Our scRNA labels table(projHeme5$Clusters2) ## ## B CD4.M CD4.N CLP Erythroid GMP Mono ## 439 678 1271 387 879 793 2632 ## NK pDC PreB Progenitor ## 851 320 351 1650 #Identify Marker Peaks while controling for TSS and Depth Biases markersPeaks &lt;- getMarkerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-ff9f78e54080-Date-2020-04-15_Time-10-31-43.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Integer.Matrix ## 2020-04-15 10:31:44 : Matching Known Biases, 0.011 mins elapsed. ## ## ########### ## 2020-04-15 10:33:02 : Completed Pairwise Tests, 1.301 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-ff9f78e54080-Date-2020-04-15_Time-10-31-43.log markersPeaks ## class: SummarizedExperiment ## dim: 144009 11 ## metadata(2): MatchInfo Params ## assays(6): Log2FC Mean … AUC MeanBGD ## rownames(144009): 1 2 … 144008 144009 ## rowData names(4): seqnames idx start end ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): We can get the peak regions for each marker as DataFrame or GRanges. #DataFrame markerList &lt;- getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;) markerList ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor markerList$Erythroid ## DataFrame with 2267 rows and 7 columns ## seqnames idx start end Log2FC ## ## 6915 chr1 6915 110407005 110407505 6.13156087199941 ## 89187 chr22 1265 30129827 30130327 4.31793618061602 ## 2715 chr1 2715 27869127 27869627 8.81830883930008 ## 9273 chr1 9273 164681433 164681933 4.09761463117515 ## 46278 chr15 2875 74902688 74903188 5.94807465189627 ## … … … … … … ## 124072 chr7 2640 47608032 47608532 1.57044726023651 ## 13738 chr1 13738 248018421 248018921 2.18899218987721 ## 90192 chr22 2270 39632393 39632893 2.09633755722991 ## 30353 chr12 2227 47600919 47601419 1.98865307113263 ## 51935 chr16 3926 70729551 70730051 2.33056750082649 ## FDR MeanDiff ## ## 6915 8.5785377923846e-15 0.908051252811916 ## 89187 1.00297518036045e-13 1.0458579648286 ## 2715 3.96321274318867e-12 0.908093680025248 ## 9273 3.96321274318867e-12 0.743482307090926 ## 46278 3.96321274318867e-12 0.739990672777532 ## … … … ## 124072 0.00939699723029238 0.345440715489147 ## 13738 0.00940220652828868 0.214851028991864 ## 90192 0.00960407719383025 0.270261700407864 ## 30353 0.00978687988910092 0.348162927084217 ## 51935 0.00982181746221214 0.327156785147329 #GRanges markerList &lt;- getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE) markerList ## GRangesList object of length 11: ## $B ## GRanges object with 594 ranges and 3 metadata columns: ## seqnames ranges strand | Log2FC ## | ## [1] chr2 232537191-232537691 * | 4.60006288742652 ## [2] chr12 92566305-92566805 * | 4.3389825818619 ## [3] chr3 13152070-13152570 * | 4.44200650760392 ## [4] chr9 37409171-37409671 * | 3.32811859032542 ## [5] chr1 160759469-160759969 * | 5.66666023794885 ## … … … … . … ## [590] chr8 128222178-128222678 * | 6.1639699924098 ## [591] chr9 93643862-93644362 * | 6.57677988412609 ## [592] chrX 6656761-6657261 * | 6.4417508983755 ## [593] chr14 81425876-81426376 * | 4.62521198459712 ## [594] chr7 63765291-63765791 * | 4.10893943379989 ## FDR MeanDiff ## ## [1] 1.61183300601365e-12 1.09207677080711 ## [2] 9.91817474781581e-10 0.993976831608143 ## [3] 4.25560916639498e-09 1.20028559994278 ## [4] 1.45797719387195e-08 1.03421998926309 ## [5] 1.58046323198917e-08 0.80285226332275 ## … … … ## [590] 0.0098441599959607 0.20375624865997 ## [591] 0.0098441599959607 0.27221052581318 ## [592] 0.0098441599959607 0.247631445395118 ## [593] 0.00994427516588697 0.432810696716752 ## [594] 0.00998116335641915 0.326535661912967 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths ## ## … ## &lt;10 more elements&gt; markerList$Erythroid ## GRanges object with 2267 ranges and 3 metadata columns: ## seqnames ranges strand | Log2FC ## | ## [1] chr1 110407005-110407505 * | 6.13156087199941 ## [2] chr22 30129827-30130327 * | 4.31793618061602 ## [3] chr1 27869127-27869627 * | 8.81830883930008 ## [4] chr1 164681433-164681933 * | 4.09761463117515 ## [5] chr15 74902688-74903188 * | 5.94807465189627 ## … … … … . … ## [2263] chr7 47608032-47608532 * | 1.57044726023651 ## [2264] chr1 248018421-248018921 * | 2.18899218987721 ## [2265] chr22 39632393-39632893 * | 2.09633755722991 ## [2266] chr12 47600919-47601419 * | 1.98865307113263 ## [2267] chr16 70729551-70730051 * | 2.33056750082649 ## FDR MeanDiff ## ## [1] 8.5785377923846e-15 0.908051252811916 ## [2] 1.00297518036045e-13 1.0458579648286 ## [3] 3.96321274318867e-12 0.908093680025248 ## [4] 3.96321274318867e-12 0.743482307090926 ## [5] 3.96321274318867e-12 0.739990672777532 ## … … … ## [2263] 0.00939699723029238 0.345440715489147 ## [2264] 0.00940220652828868 0.214851028991864 ## [2265] 0.00960407719383025 0.270261700407864 ## [2266] 0.00978687988910092 0.348162927084217 ## [2267] 0.00982181746221214 0.327156785147329 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths We can visualize this as a heatmap #Visualize Markers as a heatmap heatmapPeaks &lt;- markerHeatmap( seMarker = markersPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot;, transpose = TRUE ) ## Identified 40034 markers! ## Preparing Main Heatmap.. draw(heatmapPeaks, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapPeaks, name = &quot;Peak-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 We can also plot an MA/Volcano Plot for any individual cluster #Marker Peaks for Erythroid pma &lt;- markerPlot(seMarker = markersPeaks, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma ## Warning: Removed 55 rows containing missing values (geom_point_rast). pv &lt;- markerPlot(seMarker = markersPeaks, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv ## Warning: Removed 55 rows containing missing values (geom_point_rast). We can then plot this as a nice pdf plotPDF(pma, pv, name = &quot;Erythroid-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## [1] “plotting ggplot!” ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## [1] 0 Additionally we can see these peak regions overlayed on our browser tracks p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = c(&quot;GATA1&quot;), features = getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE)[&quot;Erythroid&quot;], upstream = 50000, downstream = 50000 ) ## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-ff9f580fdbcb-Date-2020-04-15_Time-10-35-20.log ## If there is an issue, please report to github with logFile! ## Warning: ‘GenomicRangesList’ is deprecated. ## Use ‘GRangesList(…, compress=FALSE)’ instead. ## See help(“Deprecated”) ## 2020-04-15 10:35:23 : Validating Region, 0.045 mins elapsed. ## GRanges object with 1 range and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chrX 48644982-48652717 + | 2623 GATA1 ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 10:35:23 : Adding Bulk Tracks (1 of 1), 0.047 mins elapsed. ## 2020-04-15 10:35:26 : Adding Feature Tracks (1 of 1), 0.095 mins elapsed. ## 2020-04-15 10:35:26 : Adding Gene Tracks (1 of 1), 0.1 mins elapsed. ## 2020-04-15 10:35:27 : Plotting, 0.109 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-ff9f580fdbcb-Date-2020-04-15_Time-10-35-20.log grid::grid.newpage() grid::grid.draw(p$GATA1) We can then plot this as a nice pdf plotPDF(p, name = &quot;Plot-Tracks-With-Features&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## NULL ## [1] 0 "],
["pairwise-testing-groups.html", "10.2 Pairwise Testing Groups", " 10.2 Pairwise Testing Groups #Pairwise Test between Erythroid Cells (Cluster5) and Early Progenitors (HSC) markerTest &lt;- markerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, testMethod = &quot;wilcoxon&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), useGroups = &quot;Erythroid&quot;, bgdGroups = &quot;Progenitor&quot; ) ## Warning: ‘markerFeatures’ is deprecated. ## Use ‘getMarkerFeatures’ instead. ## See help(“Deprecated”) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-ff9f77b592d7-Date-2020-04-15_Time-10-35-37.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Integer.Matrix ## 2020-04-15 10:35:41 : Matching Known Biases, 0.057 mins elapsed. ## ## 2020-04-15 10:35:44 : Computing Pairwise Tests (1 of 1), 0.107 mins elapsed. ## ########### ## 2020-04-15 10:36:13 : Completed Pairwise Tests, 0.584 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-ff9f77b592d7-Date-2020-04-15_Time-10-35-37.log We can then plot an MA/Volcano Plot #Marker Peaks for Erythroid pma &lt;- markerPlot(seMarker = markerTest, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma ## Warning: Removed 57 rows containing missing values (geom_point_rast). pv &lt;- markerPlot(seMarker = markerTest, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv ## Warning: Removed 57 rows containing missing values (geom_point_rast). We can then plot this as a nice pdf plotPDF(pma, pv, name = &quot;Erythroid-vs-Progenitor-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## [1] “plotting ggplot!” ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## [1] 0 We can look for enriched motifs (see next chapter for more details) #Add Motif Peak Annotations if not already added! projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) ## No methods found in package ‘IRanges’ for request: ‘score’ when loading ‘TFBSTools’ ## 2020-04-15 10:38:11 : Gettting Motif Set, Species : Homo sapiens, 0 mins elapsed. ## Using version 2 motifs! ## 2020-04-15 10:38:13 : Finding Motif Positions with motifmatchr!, 0.027 mins elapsed. ## 2020-04-15 10:41:40 : Creating Motif Overlap Matrix, 3.48 mins elapsed. ## 2020-04-15 10:41:43 : Finished Getting Motif Info!, 3.523 mins elapsed. #Identify Motif Enrichments motifsUp &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:41:49 : Computing Enrichments 1 of 1, 0.066 mins elapsed. motifsUp ## class: SummarizedExperiment ## dim: 870 1 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 … TBX18_869 TBX22_870 ## rowData names(0): ## colnames(1): Erythroid ## colData names(0): #Create data.frame df &lt;- data.frame(TF = rownames(motifsUp), mlog10Padj = assay(motifsUp)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) head(df) ## TF mlog10Padj rank ## 388 GATA2_388 535.7098 1 ## 383 GATA1_383 523.8809 2 ## 384 GATA3_384 421.6064 3 ## 385 GATA5_385 407.2538 4 ## 386 GATA4_386 309.7756 5 ## 387 GATA6_387 216.7223 6 #Ggplot ggUp &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(P-adj) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggUp #Identify Motif Enrichments motifsDo &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &lt;= -0.5&quot; ) ## 2020-04-15 10:42:01 : Computing Enrichments 1 of 1, 0.053 mins elapsed. motifsDo ## class: SummarizedExperiment ## dim: 870 1 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 … TBX18_869 TBX22_870 ## rowData names(0): ## colnames(1): Erythroid ## colData names(0): #Create data.frame df &lt;- data.frame(TF = rownames(motifsDo), mlog10Padj = assay(motifsDo)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) head(df) ## TF mlog10Padj rank ## 326 ELF2_326 88.68056 1 ## 733 RUNX1_733 64.00586 2 ## 801 CBFB_801 53.55426 3 ## 732 RUNX2_732 53.14766 4 ## 734 ENSG00000250096_734 53.14766 5 ## 336 SPIB_336 52.79666 6 #Ggplot ggDo &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(FDR) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggDo We can then plot this as a nice pdf plotPDF(ggUp, ggDo, name = &quot;Erythroid-vs-Progenitor-Markers-Motifs-Enriched&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 "],
["session-information-9.html", "10.3 Session Information", " 10.3 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["peak-annotation-enrichment-with-archr.html", "Chapter 11 Peak Annotation Enrichment with ArchR ", " Chapter 11 Peak Annotation Enrichment with ArchR "],
["motif-enrichment.html", "11.1 Motif Enrichment", " 11.1 Motif Enrichment #Motif Search in Peak Set and add to Peak Annotations if(&quot;Motif&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) } #Identify Motif Enrichments enrichMotifs &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:43:01 : Computing Enrichments 1 of 11, 0.046 mins elapsed. ## 2020-04-15 10:43:01 : Computing Enrichments 2 of 11, 0.058 mins elapsed. ## 2020-04-15 10:43:02 : Computing Enrichments 3 of 11, 0.072 mins elapsed. ## 2020-04-15 10:43:03 : Computing Enrichments 4 of 11, 0.094 mins elapsed. ## 2020-04-15 10:43:04 : Computing Enrichments 5 of 11, 0.103 mins elapsed. ## 2020-04-15 10:43:05 : Computing Enrichments 6 of 11, 0.113 mins elapsed. ## 2020-04-15 10:43:05 : Computing Enrichments 7 of 11, 0.121 mins elapsed. ## 2020-04-15 10:43:06 : Computing Enrichments 8 of 11, 0.13 mins elapsed. ## 2020-04-15 10:43:06 : Computing Enrichments 9 of 11, 0.139 mins elapsed. ## 2020-04-15 10:43:07 : Computing Enrichments 10 of 11, 0.148 mins elapsed. ## 2020-04-15 10:43:08 : Computing Enrichments 11 of 11, 0.17 mins elapsed. enrichMotifs ## class: SummarizedExperiment ## dim: 870 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 … TBX18_869 TBX22_870 ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapEM &lt;- enrichHeatmap(enrichMotifs, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapEM, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapEM, name = &quot;Motifs-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 "],
["archr-enrichment.html", "11.2 ArchR Enrichment", " 11.2 ArchR Enrichment 11.2.1 Encode TFBS projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) ## Annotation ArchR-Hg19-v1.Anno does not exist! Downloading.. ## Annotating Chr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X #Identify EncodeTFBS Enrichments enrichEncode &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:43:34 : Computing Enrichments 1 of 11, 0.036 mins elapsed. ## 2020-04-15 10:43:34 : Computing Enrichments 2 of 11, 0.041 mins elapsed. ## 2020-04-15 10:43:34 : Computing Enrichments 3 of 11, 0.047 mins elapsed. ## 2020-04-15 10:43:35 : Computing Enrichments 4 of 11, 0.054 mins elapsed. ## 2020-04-15 10:43:35 : Computing Enrichments 5 of 11, 0.063 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 6 of 11, 0.066 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 7 of 11, 0.071 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 8 of 11, 0.075 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 9 of 11, 0.079 mins elapsed. ## 2020-04-15 10:43:37 : Computing Enrichments 10 of 11, 0.083 mins elapsed. ## 2020-04-15 10:43:37 : Computing Enrichments 11 of 11, 0.087 mins elapsed. enrichEncode ## class: SummarizedExperiment ## dim: 689 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(689): 1.CTCF-Dnd41… 2.EZH2_39-Dnd41… … ## 688.CTCF-WERI_Rb_1… 689.CTCF-WI_38… ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapEncode &lt;- enrichHeatmap(enrichEncode, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapEncode, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapEncode, name = &quot;EncodeTFBS-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 11.2.2 Bulk ATAC-seq projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) ## Annotating Chr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X #Identify ATAC Enrichments enrichATAC &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:43:53 : Computing Enrichments 1 of 11, 0.027 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 2 of 11, 0.028 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 3 of 11, 0.03 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 4 of 11, 0.034 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 5 of 11, 0.036 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 6 of 11, 0.038 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 7 of 11, 0.04 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 8 of 11, 0.043 mins elapsed. ## 2020-04-15 10:43:55 : Computing Enrichments 9 of 11, 0.045 mins elapsed. ## 2020-04-15 10:43:55 : Computing Enrichments 10 of 11, 0.047 mins elapsed. ## 2020-04-15 10:43:55 : Computing Enrichments 11 of 11, 0.049 mins elapsed. enrichATAC ## class: SummarizedExperiment ## dim: 96 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(96): Brain_Astrocytes Brain_Excitatory_neurons … Heme_MPP ## Heme_NK ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapATAC &lt;- enrichHeatmap(enrichATAC, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapATAC, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapATAC, name = &quot;ATAC-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 11.2.3 Codex TFBS projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;Codex&quot;) ## Annotating Chr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X #Identify Codex Enrichments enrichCodex &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Codex&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:44:11 : Computing Enrichments 1 of 11, 0.025 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 2 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 3 of 11, 0.029 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 4 of 11, 0.032 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 5 of 11, 0.034 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 6 of 11, 0.035 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 7 of 11, 0.036 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 8 of 11, 0.037 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 9 of 11, 0.038 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 10 of 11, 0.039 mins elapsed. ## 2020-04-15 10:44:12 : Computing Enrichments 11 of 11, 0.041 mins elapsed. enrichCodex ## class: SummarizedExperiment ## dim: 189 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(189): 1.STAT5-No_drug_(DMSO)… 2.RUNX3-GM12878_cell_fr… … ## 188.TP53-codex_Embryonic… 189.TP53-codex_Embryonic… ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapCodex &lt;- enrichHeatmap(enrichCodex, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapCodex, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapCodex, name = &quot;Codex-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 "],
["custom-enrichment.html", "11.3 Custom Enrichment", " 11.3 Custom Enrichment #Custom Peak Annotations EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) ## 2020-04-15 10:44:23 : Creating Peak Overlap Matrix, 0.036 mins elapsed. #Identify ChIP Enrichments enrichRegions &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:44:25 : Computing Enrichments 1 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 2 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 3 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 4 of 11, 0.028 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 5 of 11, 0.028 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 6 of 11, 0.029 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 7 of 11, 0.029 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 8 of 11, 0.03 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 9 of 11, 0.03 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 10 of 11, 0.03 mins elapsed. ## 2020-04-15 10:44:26 : Computing Enrichments 11 of 11, 0.033 mins elapsed. enrichRegions ## class: SummarizedExperiment ## dim: 4 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(4): Encode_K562_GATA1 Encode_GM12878_CEBPB Encode_K562_Ebf1 ## Encode_K562_Pax5 ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapRegions &lt;- enrichHeatmap(enrichRegions, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapRegions, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapRegions, name = &quot;Regions-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 "],
["session-information-10.html", "11.4 Session Information", " 11.4 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["chromvar-deviatons-enrichment-with-archr.html", "Chapter 12 ChromVAR Deviatons Enrichment with ArchR ", " Chapter 12 ChromVAR Deviatons Enrichment with ArchR "],
["motif-deviations.html", "12.1 Motif Deviations", " 12.1 Motif Deviations If you have not added motif annotations if(&quot;Motif&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) } If you have not added background peaks projHeme5 &lt;- addBgdPeaks(projHeme5) ## Identifying Background Peaks! ## No methods found in package ‘IRanges’ for request: ‘score’ when loading ‘TFBSTools’ Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-103741bce39ff-Date-2020-04-15_Time-10-45-35.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 10:45:40 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 10:57:19 : Completed Computing Deviations!, 11.734 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-103741bce39ff-Date-2020-04-15_Time-10-45-35.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## ## f388 z 388 GATA2_388 11.9292478607949 -0.034894792575792 ## f155 z 155 CEBPA_155 11.8070700579364 -0.174087405321135 ## f383 z 383 GATA1_383 11.8045825337775 -0.0378306234562619 ## f336 z 336 SPIB_336 11.3432739583017 -0.0819836042460723 ## f385 z 385 GATA5_385 10.8828679211543 -0.036867577013264 ## f651 z 651 SMARCC1_651 10.2885493109675 -0.131812047523969 ## rank ## ## f388 1 ## f155 2 ## f383 3 ## f336 4 ## f385 5 ## f651 6 plotVarDev ## Warning: Removed 1 rows containing missing values (geom_point). We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-Motif-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Removed 1 rows containing missing values (geom_point). ## [1] 0 If we want to get motif feature names for downstream plotting motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;MotifMatrix&quot;) ## [1] “z:TBX21_780” “z:PAX5_709” “z:IRF4_632” ## [4] “z:GATA1_383” “z:CEBPA_155” “z:EBF1_67” ## [7] “z:SREBF1_22” “deviations:TBX21_780” “deviations:PAX5_709” ## [10] “deviations:IRF4_632” “deviations:GATA1_383” “deviations:CEBPA_155” ## [13] “deviations:EBF1_67” “deviations:SREBF1_22” To get deviation z-scores markerMotifs &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;MotifMatrix&quot;) markerMotifs &lt;- grep(&quot;z:&quot;, markerMotifs, value = TRUE) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;z:SREBF1_22&quot;] markerMotifs ## [1] “z:TBX21_780” “z:PAX5_709” “z:IRF4_632” “z:GATA1_383” “z:CEBPA_155” ## [6] “z:EBF1_67” We can also now plot the distribution of chromVAR deviation scores for each cluster p &lt;- plotGroups(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, colorBy = &quot;MotifMatrix&quot;, name = markerMotifs, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## Getting Matrix Values… ## Getting Matrix Values… ## ## ArchR logging to : ArchRLogs/ArchR-imputeMatrix-103746efc5207-Date-2020-04-15_Time-10-57-40.log ## If there is an issue, please report to github with logFile! ## Using weights on disk ## Using weights on disk ## 1 2 3 4 5 6 To plot all genes we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(seq_along(p), function(x){ if(x != 1){ p[[x]] + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) }else{ p[[x]] + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) } }) do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2, rep(1, length(p2) - 1))),p2)) ## Picking joint bandwidth of 0.0181 ## Picking joint bandwidth of 0.02 ## Picking joint bandwidth of 0.07 ## Picking joint bandwidth of 0.109 ## Picking joint bandwidth of 0.102 ## Picking joint bandwidth of 0.0703 We can then plot this as a nice PDF plotPDF(p, name = &quot;Plot-Groups-Deviations-w-Imputation&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.0181 ## Picking joint bandwidth of 0.0181 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.02 ## Picking joint bandwidth of 0.02 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.07 ## Picking joint bandwidth of 0.07 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.109 ## Picking joint bandwidth of 0.109 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.102 ## Picking joint bandwidth of 0.102 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.0703 ## Picking joint bandwidth of 0.0703 ## [1] 0 We can now overlay these motif deviation scores on the UMAP embedding p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;MotifMatrix&quot;, name = sort(markerMotifs), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374bec190f-Date-2020-04-15_Time-10-58-03.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = MotifMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374bec190f-Date-2020-04-15_Time-10-58-03.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneScoreMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA ## [1] “TBX21” “CEBPA” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneScoreMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-1037475e6dc52-Date-2020-04-15_Time-10-58-30.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-1037475e6dc52-Date-2020-04-15_Time-10-58-30.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneIntegrationMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA ## [1] “TBX21” “CEBPA” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneIntegrationMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, continuousSet = &quot;blueYellow&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374438d3144-Date-2020-04-15_Time-10-58-56.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374438d3144-Date-2020-04-15_Time-10-58-56.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) "],
["archr-deviations.html", "12.2 ArchR Deviations", " 12.2 ArchR Deviations 12.2.1 Encode TFBS If you have not added motif annotations if(&quot;EncodeTFBS&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) } Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-10374737762a7-Date-2020-04-15_Time-10-59-20.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 10:59:26 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 11:08:11 : Completed Computing Deviations!, 8.864 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-10374737762a7-Date-2020-04-15_Time-10-59-20.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;EncodeTFBSMatrix&quot;) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars ## ## f222 z 222 222.GATA2_S-K562… 13.6382687713858 ## f41 z 41 41.EZH2_39-NHEK… 12.9150554355261 ## f542 z 542 542.TAL1_SC-K562… 11.5490744327685 ## f584 z 584 584.GATA_1-PBDEFetal… 10.7653053700024 ## f498 z 498 498.GATA_2-K562… 10.2384173319845 ## f44 z 44 44.EZH2_39-NHLF… 9.92292044310219 ## combinedMeans rank ## ## f222 -0.0312421757573656 1 ## f41 0.113221166775704 2 ## f542 -0.0155915927183644 3 ## f584 -0.00997025022971285 4 ## f498 -0.0317577572129743 5 ## f44 0.0707460230932926 6 plotVarDev ## Warning: Removed 7 rows containing missing values (geom_point). We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-EncodeTFBS-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 7 rows containing missing values (geom_point). ## Warning: Removed 7 rows containing missing values (geom_point). ## [1] 0 If we want to get TF feature names for downstream plotting tfs &lt;- c(&quot;GATA_1&quot;, &quot;CEBPB&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) ## [1] “z:584.GATA_1-PBDEFetal…” “z:582.GATA_1-PBDE…” ## [3] “z:497.GATA_1-K562…” “z:477.CEBPB-K562…” ## [5] “z:462.CEBPB-IMR90…” “z:427.CEBPB-HepG2…” ## [7] “z:426.CEBPB-HepG2…” “z:379.CEBPB-HeLa_S3…” ## [9] “z:344.CEBPB-H1_hESC…” “z:293.EBF1_SC-GM12878…” ## [11] “z:278.CEBPB-A549…” “z:213.CEBPB_S-K562…” ## [13] “z:173.CEBPB_S-HepG2…” “z:130.PAX5_C2-GM12892…” ## [15] “z:123.PAX5_C2-GM12891…” “z:102.PAX5_N1-GM12878…” ## [17] “z:101.PAX5_C2-GM12878…” “z:93.IRF4_SC-GM12878…” ## [19] “z:87.EBF1_SC-GM12878…” “z:86.CEBPB_S-GM12878…” ## [21] “deviations:584.GATA_1-PBDEFetal…” “deviations:582.GATA_1-PBDE…” ## [23] “deviations:497.GATA_1-K562…” “deviations:477.CEBPB-K562…” ## [25] “deviations:462.CEBPB-IMR90…” “deviations:427.CEBPB-HepG2…” ## [27] “deviations:426.CEBPB-HepG2…” “deviations:379.CEBPB-HeLa_S3…” ## [29] “deviations:344.CEBPB-H1_hESC…” “deviations:293.EBF1_SC-GM12878…” ## [31] “deviations:278.CEBPB-A549…” “deviations:213.CEBPB_S-K562…” ## [33] “deviations:173.CEBPB_S-HepG2…” “deviations:130.PAX5_C2-GM12892…” ## [35] “deviations:123.PAX5_C2-GM12891…” “deviations:102.PAX5_N1-GM12878…” ## [37] “deviations:101.PAX5_C2-GM12878…” “deviations:93.IRF4_SC-GM12878…” ## [39] “deviations:87.EBF1_SC-GM12878…” “deviations:86.CEBPB_S-GM12878…” To get deviation z-scores markerTFs &lt;- getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) markerTFs &lt;- sort(grep(&quot;z:&quot;, markerTFs, value = TRUE)) TFnames &lt;- stringr::str_split(stringr::str_split(markerTFs, pattern = &quot;\\\\.&quot;, simplify=TRUE)[,2], pattern = &quot;-&quot;, simplify = TRUE)[,1] markerTFs &lt;- markerTFs[!duplicated(TFnames)] markerTFs ## [1] “z:101.PAX5_C2-GM12878…” “z:102.PAX5_N1-GM12878…” ## [3] “z:173.CEBPB_S-HepG2…” “z:278.CEBPB-A549…” ## [5] “z:293.EBF1_SC-GM12878…” “z:497.GATA_1-K562…” ## [7] “z:93.IRF4_SC-GM12878…” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;EncodeTFBSMatrix&quot;, name = markerTFs, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-103747b681a1c-Date-2020-04-15_Time-11-08-26.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = EncodeTFBSMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-103747b681a1c-Date-2020-04-15_Time-11-08-26.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(gsub(&quot;_&quot;,&quot;&quot;,tfs), collapse=&quot;|&quot;), useMatrix = &quot;GeneScoreMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;)] markerRNA ## [1] “TBX21” “CEBPB” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneScoreMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-103747bae5e9f-Date-2020-04-15_Time-11-08-53.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-103747bae5e9f-Date-2020-04-15_Time-11-08-53.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(gsub(&quot;_&quot;,&quot;&quot;,tfs), collapse=&quot;|&quot;), useMatrix = &quot;GeneIntegrationMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA ## [1] “TBX21” “CEBPB” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneIntegrationMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, continuousSet = &quot;blueYellow&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-103746f7eeb66-Date-2020-04-15_Time-11-09-21.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-103746f7eeb66-Date-2020-04-15_Time-11-09-21.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) 12.2.2 Bulk ATAC-seq If you have not added motif annotations if(&quot;ATAC&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) } Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-103743481be2a-Date-2020-04-15_Time-11-09-46.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 11:09:52 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 11:13:09 : Completed Computing Deviations!, 3.376 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-103743481be2a-Date-2020-04-15_Time-11-09-46.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ATACMatrix&quot;) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## ## f22 z 22 IAtlas_T_CD8posCenMem 12.8413703976471 -0.0972946574781075 ## f86 z 86 Heme_CD8 12.5070480860108 -0.079462324469343 ## f85 z 85 Heme_CD4 12.2753260246254 -0.0561621531675016 ## f23 z 23 IAtlas_T_CD8posEffMem 12.2250185804317 -0.104389732164243 ## f21 z 21 IAtlas_T_CD8pos 12.1998071900673 -0.09178088897301 ## f33 z 33 IAtlas_T_Th1Precursor 12.1352640996498 -0.0819315630754632 ## rank ## ## f22 1 ## f86 2 ## f85 3 ## f23 4 ## f21 5 ## f33 6 plotVarDev We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-ATAC-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## [1] 0 If we want to get TF feature names for downstream plotting ATACPeaks &lt;- c(&quot;Heme_HSC&quot;, &quot;Heme_LMPP&quot;, &quot;Heme_Ery&quot;, &quot;Heme_Mono&quot;, &quot;Heme_CD4&quot;, &quot;Heme_CD8&quot;, &quot;Heme_B&quot;, &quot;Heme_NK&quot;, &quot;IAtlas_DC_Plasmacytoid&quot;) getFeatures(projHeme5, select = paste(ATACPeaks, collapse=&quot;|&quot;), useMatrix = &quot;ATACMatrix&quot;) ## [1] “z:Heme_NK” “z:Heme_Mono” ## [3] “z:Heme_LMPP” “z:Heme_HSC” ## [5] “z:Heme_Ery” “z:Heme_CD8” ## [7] “z:Heme_CD4” “z:Heme_B” ## [9] “z:IAtlas_DC_Plasmacytoid” “deviations:Heme_NK” ## [11] “deviations:Heme_Mono” “deviations:Heme_LMPP” ## [13] “deviations:Heme_HSC” “deviations:Heme_Ery” ## [15] “deviations:Heme_CD8” “deviations:Heme_CD4” ## [17] “deviations:Heme_B” “deviations:IAtlas_DC_Plasmacytoid” To get deviation z-scores markerATAC &lt;- getFeatures(projHeme5, select = paste(ATACPeaks, collapse=&quot;|&quot;), useMatrix = &quot;ATACMatrix&quot;) markerATAC &lt;- sort(grep(&quot;z:&quot;, markerATAC, value = TRUE)) markerATAC ## [1] “z:Heme_B” “z:Heme_CD4” ## [3] “z:Heme_CD8” “z:Heme_Ery” ## [5] “z:Heme_HSC” “z:Heme_LMPP” ## [7] “z:Heme_Mono” “z:Heme_NK” ## [9] “z:IAtlas_DC_Plasmacytoid” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ATACMatrix&quot;, name = markerATAC, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-1037416f3cb56-Date-2020-04-15_Time-11-13-23.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = ATACMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-1037416f3cb56-Date-2020-04-15_Time-11-13-23.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) "],
["custom-deviations.html", "12.3 Custom Deviations", " 12.3 Custom Deviations If you have not added motif annotations #Custom Peak Annotations EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) if(&quot;ChIP&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) } Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-10374246a529b-Date-2020-04-15_Time-11-13-54.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 11:13:59 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 11:14:24 : Completed Computing Deviations!, 0.505 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-10374246a529b-Date-2020-04-15_Time-11-13-54.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ChIPMatrix&quot;) ## DataFrame with 4 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## ## f1 z 1 Encode_K562_GATA1 6.33176528990239 -0.0165812177586936 ## f3 z 3 Encode_K562_Ebf1 3.41531511621115 0.0355188580388895 ## f4 z 4 Encode_K562_Pax5 3.24513143947069 -0.00960057929930531 ## f2 z 2 Encode_GM12878_CEBPB 0.822128491900276 0.00742820197777246 ## rank ## ## f1 1 ## f3 2 ## f4 3 ## f2 4 plotVarDev ## Warning: Removed 21 rows containing missing values (geom_label_repel). We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-ChIP-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 21 rows containing missing values (geom_label_repel). ## Warning: Removed 21 rows containing missing values (geom_label_repel). ## [1] 0 To get deviation z-scores markerChIP &lt;- getFeatures(projHeme5, useMatrix = &quot;ChIPMatrix&quot;) markerChIP &lt;- sort(grep(&quot;z:&quot;, markerChIP, value = TRUE)) markerChIP ## [1] “z:Encode_GM12878_CEBPB” “z:Encode_K562_Ebf1” “z:Encode_K562_GATA1” ## [4] “z:Encode_K562_Pax5” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ChIPMatrix&quot;, name = markerChIP, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374635d5970-Date-2020-04-15_Time-11-14-35.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = ChIPMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374635d5970-Date-2020-04-15_Time-11-14-35.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 2),p2)) "],
["session-information-11.html", "12.4 Session Information", " 12.4 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["footprinting-with-archr.html", "Chapter 13 Footprinting with ArchR ", " Chapter 13 Footprinting with ArchR "],
["motif-footprinting.html", "13.1 Motif Footprinting", " 13.1 Motif Footprinting Transcription factor footprinting can also be done in ArchR with a single command. We note that the footprints generated by the tutorial data are not as clean as would be desired but this is because of the small size of the tutorial dataset. motifPositions &lt;- getPositions(projHeme5) motifPositions ## GRangesList object of length 870: ## $TFAP2B_1 ## GRanges object with 16773 ranges and 1 metadata column: ## seqnames ranges strand | score ## | ## [1] chr1 852468-852479 + | 8.17731199746359 ## [2] chr1 873916-873927 + | 8.32673820065588 ## [3] chr1 873916-873927 - | 8.32673820065588 ## [4] chr1 896671-896682 + | 9.96223327271814 ## [5] chr1 896671-896682 - | 8.92408377606486 ## … … … … . … ## [16769] chrX 153991101-153991112 + | 8.39549159740639 ## [16770] chrX 154299568-154299579 + | 8.90119825654299 ## [16771] chrX 154664929-154664940 - | 8.16690864294221 ## [16772] chrX 154807684-154807695 + | 9.57636587154549 ## [16773] chrX 154807684-154807695 - | 10.6117355833828 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths ## ## … ## &lt;869 more elements&gt; Find TF-Motifs motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) markerMotifs &lt;- unlist(lapply(motifs, function(x) grep(x, names(motifPositions), value = TRUE))) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;SREBF1_22&quot;] markerMotifs ## [1] “GATA1_383” “CEBPA_155” “EBF1_67” “IRF4_632” “TBX21_780” “PAX5_709” #Create Group Coverage Files if you have not done so already projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) Now we can compute footprints #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set seFoot &lt;- getFootprints( ArchRProj = projHeme5, positions = motifPositions[markerMotifs], groupBy = &quot;Clusters2&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getFootprints-10b7a1d11042e-Date-2020-04-15_Time-11-15-50.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:15:51 : Computing Kmer Bias Table, 0.024 mins elapsed. ## 2020-04-15 11:16:13 : Finished Computing Kmer Tables, 0.361 mins elapsed. ## 2020-04-15 11:16:13 : Computing Footprints, 0.385 mins elapsed. ## 2020-04-15 11:16:22 : Computing Footprints Bias, 0.539 mins elapsed. ## 2020-04-15 11:16:28 : Summarizing Footprints, 0.642 mins elapsed. 13.1.1 No Normalization #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;None&quot;, plotName = &quot;Footprints-No-Normalization&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a22669572-Date-2020-04-15_Time-11-16-30.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:16:31 : Plotting Footprint : GATA1_383 (1 of 6), 0.009 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:35 : Plotting Footprint : CEBPA_155 (2 of 6), 0.077 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:38 : Plotting Footprint : EBF1_67 (3 of 6), 0.125 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:41 : Plotting Footprint : IRF4_632 (4 of 6), 0.173 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:44 : Plotting Footprint : TBX21_780 (5 of 6), 0.221 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:46 : Plotting Footprint : PAX5_709 (6 of 6), 0.27 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a22669572-Date-2020-04-15_Time-11-16-30.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. 13.1.2 Subtract Tn5 Bias #Re-Plot with different normalization method plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;Subtract&quot;, plotName = &quot;Footprints-Subtract-Bias&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a2038428-Date-2020-04-15_Time-11-16-59.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:16:59 : Plotting Footprint : GATA1_383 (1 of 6), 0.007 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:02 : Plotting Footprint : CEBPA_155 (2 of 6), 0.065 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:05 : Plotting Footprint : EBF1_67 (3 of 6), 0.109 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:08 : Plotting Footprint : IRF4_632 (4 of 6), 0.155 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:11 : Plotting Footprint : TBX21_780 (5 of 6), 0.199 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:13 : Plotting Footprint : PAX5_709 (6 of 6), 0.245 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a2038428-Date-2020-04-15_Time-11-16-59.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. 13.1.3 Divide Tn5 Bias #Re-Plot with different normalization method plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;Divide&quot;, plotName = &quot;Footprints-Divide-Bias&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a703225b0-Date-2020-04-15_Time-11-17-23.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:17:23 : Plotting Footprint : GATA1_383 (1 of 6), 0.008 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:27 : Plotting Footprint : CEBPA_155 (2 of 6), 0.073 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:30 : Plotting Footprint : EBF1_67 (3 of 6), 0.13 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:34 : Plotting Footprint : IRF4_632 (4 of 6), 0.189 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:38 : Plotting Footprint : TBX21_780 (5 of 6), 0.248 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:41 : Plotting Footprint : PAX5_709 (6 of 6), 0.307 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a703225b0-Date-2020-04-15_Time-11-17-23.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. "],
["feature-footprinting.html", "13.2 Feature Footprinting", " 13.2 Feature Footprinting #Create Group Coverage Files if you have not done so already projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) 13.2.1 No Normalization #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set seTSS &lt;- getFootprints( ArchRProj = projHeme5, positions = GRangesList(TSS = getTSS(projHeme5)), groupBy = &quot;Clusters2&quot;, flank = 2000 ) ## ArchR logging to : ArchRLogs/ArchR-getFootprints-10b7a47a82723-Date-2020-04-15_Time-11-17-52.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:17:52 : Computing Kmer Bias Table, 0.012 mins elapsed. ## 2020-04-15 11:18:24 : Finished Computing Kmer Tables, 0.535 mins elapsed. ## 2020-04-15 11:18:24 : Computing Footprints, 0.547 mins elapsed. ## 2020-04-15 11:18:36 : Computing Footprints Bias, 0.734 mins elapsed. ## 2020-04-15 11:18:43 : Summarizing Footprints, 0.852 mins elapsed. plotFootprints( seFoot = seTSS, ArchRProj = projHeme5, normMethod = &quot;None&quot;, plotName = &quot;TSS-No-Normalization&quot;, addDOC = FALSE, flank = 2000, flankNorm = 100 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a1b7faa1-Date-2020-04-15_Time-11-18-46.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:18:46 : Plotting Footprint : TSS (1 of 1), 0.007 mins elapsed. ## Normalizing by flanking regions ## NormMethod = None ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a1b7faa1-Date-2020-04-15_Time-11-18-46.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. "],
["session-information-12.html", "13.3 Session Information", " 13.3 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["integrative-analysis-with-archr.html", "Chapter 14 Integrative Analysis with ArchR ", " Chapter 14 Integrative Analysis with ArchR "],
["co-accessibility-with-archr.html", "14.1 Co-accessibility with ArchR", " 14.1 Co-accessibility with ArchR projHeme5 &lt;- addCoAccessibility( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addCoAccessibility-11a706a1e44aa-Date-2020-04-15_Time-11-54-46.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:54:46 : Computing KNN, 0.009 mins elapsed. ## 2020-04-15 11:54:48 : Identifying Non-Overlapping KNN pairs, 0.032 mins elapsed. ## 2020-04-15 11:54:51 : Identified 491 Groupings!, 0.084 mins elapsed. ## 2020-04-15 11:54:54 : Computing Co-Accessibility chr1 (1 of 23), 0.134 mins elapsed. ## 2020-04-15 11:55:00 : Computing Co-Accessibility chr2 (2 of 23), 0.245 mins elapsed. ## 2020-04-15 11:55:05 : Computing Co-Accessibility chr3 (3 of 23), 0.325 mins elapsed. ## 2020-04-15 11:55:09 : Computing Co-Accessibility chr4 (4 of 23), 0.386 mins elapsed. ## 2020-04-15 11:55:12 : Computing Co-Accessibility chr5 (5 of 23), 0.438 mins elapsed. ## 2020-04-15 11:55:15 : Computing Co-Accessibility chr6 (6 of 23), 0.493 mins elapsed. ## 2020-04-15 11:55:20 : Computing Co-Accessibility chr7 (7 of 23), 0.564 mins elapsed. ## 2020-04-15 11:55:24 : Computing Co-Accessibility chr8 (8 of 23), 0.634 mins elapsed. ## 2020-04-15 11:55:27 : Computing Co-Accessibility chr9 (9 of 23), 0.685 mins elapsed. ## 2020-04-15 11:55:30 : Computing Co-Accessibility chr10 (10 of 23), 0.737 mins elapsed. ## 2020-04-15 11:55:34 : Computing Co-Accessibility chr11 (11 of 23), 0.805 mins elapsed. ## 2020-04-15 11:55:38 : Computing Co-Accessibility chr12 (12 of 23), 0.874 mins elapsed. ## 2020-04-15 11:55:42 : Computing Co-Accessibility chr13 (13 of 23), 0.937 mins elapsed. ## 2020-04-15 11:55:44 : Computing Co-Accessibility chr14 (14 of 23), 0.979 mins elapsed. ## 2020-04-15 11:55:47 : Computing Co-Accessibility chr15 (15 of 23), 1.028 mins elapsed. ## 2020-04-15 11:55:51 : Computing Co-Accessibility chr16 (16 of 23), 1.085 mins elapsed. ## 2020-04-15 11:55:55 : Computing Co-Accessibility chr17 (17 of 23), 1.146 mins elapsed. ## 2020-04-15 11:55:58 : Computing Co-Accessibility chr18 (18 of 23), 1.206 mins elapsed. ## 2020-04-15 11:56:01 : Computing Co-Accessibility chr19 (19 of 23), 1.251 mins elapsed. ## 2020-04-15 11:56:05 : Computing Co-Accessibility chr20 (20 of 23), 1.327 mins elapsed. ## 2020-04-15 11:56:09 : Computing Co-Accessibility chr21 (21 of 23), 1.384 mins elapsed. ## 2020-04-15 11:56:11 : Computing Co-Accessibility chr22 (22 of 23), 1.424 mins elapsed. ## 2020-04-15 11:56:14 : Computing Co-Accessibility chrX (23 of 23), 1.468 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addCoAccessibility-11a706a1e44aa-Date-2020-04-15_Time-11-54-46.log cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = FALSE ) cA ## DataFrame with 64824 rows and 4 columns ## queryHits subjectHits seqnames correlation ## ## 1 5 10 chr1 0.63855416236086 ## 2 10 5 chr1 0.63855416236086 ## 3 21 22 chr1 0.551520040138677 ## 4 22 21 chr1 0.551520040138677 ## 5 25 37 chr1 0.535392737290744 ## … … … … … ## 64820 143907 143906 chrX 0.510896735395573 ## 64821 143932 143936 chrX 0.501021498357938 ## 64822 143936 143932 chrX 0.501021498357938 ## 64823 143977 143978 chrX 0.550319862774772 ## 64824 143978 143977 chrX 0.550319862774772 metadata(cA)[[1]] ## GRanges object with 144009 ranges and 0 metadata columns: ## seqnames ranges strand ## ## Mono chr1 752499-752999 * ## NK chr1 762651-763151 * ## B chr1 801006-801506 * ## B chr1 805039-805539 * ## CLP chr1 845325-845825 * ## … … … … ## Erythroid chrX 154664540-154665040 * ## NK chrX 154807324-154807824 * ## PreB chrX 154840785-154841285 * ## PreB chrX 154842404-154842904 * ## NK chrX 154862017-154862517 * ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = TRUE ) cA[[1]] ## GRanges object with 32412 ranges and 1 metadata column: ## seqnames ranges strand | value ## | ## [1] chr1 845575-856640 * | 0.63855416236086 ## [2] chr1 894704-895233 * | 0.551520040138677 ## [3] chr1 901499-940519 * | 0.535392737290744 ## [4] chr1 968584-1004206 * | 0.541750176412625 ## [5] chr1 974287-975116 * | 0.614286275264492 ## … … … … . … ## [32408] chrX 153306085-153342739 * | 0.54575277183448 ## [32409] chrX 153523581-153529374 * | 0.539921104229481 ## [32410] chrX 153582820-153583471 * | 0.510896735395573 ## [32411] chrX 153637615-153656023 * | 0.501021498357938 ## [32412] chrX 153980218-153990364 * | 0.550319862774772 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1000, returnLoops = TRUE ) cA[[1]] ## GRanges object with 30997 ranges and 1 metadata column: ## seqnames ranges strand | value ## | ## [1] chr1 845500-856500 * | 0.63855416236086 ## [2] chr1 894500-895500 * | 0.551520040138677 ## [3] chr1 901500-940500 * | 0.535392737290744 ## [4] chr1 968500-1004500 * | 0.541750176412625 ## [5] chr1 974500-975500 * | 0.614286275264492 ## … … … … . … ## [30993] chrX 153306500-153342500 * | 0.54575277183448 ## [30994] chrX 153523500-153529500 * | 0.539921104229481 ## [30995] chrX 153582500-153583500 * | 0.510896735395573 ## [30996] chrX 153637500-153656500 * | 0.501021498357938 ## [30997] chrX 153980500-153990500 * | 0.550319862774772 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 10000, returnLoops = TRUE ) cA[[1]] ## GRanges object with 21142 ranges and 1 metadata column: ## seqnames ranges strand | value ## | ## [1] chr1 845000-855000 * | 0.63855416236086 ## [2] chr1 895000 * | 0.551520040138677 ## [3] chr1 905000-945000 * | 0.535392737290744 ## [4] chr1 965000-1005000 * | 0.541750176412625 ## [5] chr1 975000 * | 0.614286275264492 ## … … … … . … ## [21138] chrX 153305000-153345000 * | 0.54575277183448 ## [21139] chrX 153525000 * | 0.539921104229481 ## [21140] chrX 153585000 * | 0.510896735395573 ## [21141] chrX 153635000-153655000 * | 0.501021498357938 ## [21142] chrX 153985000-153995000 * | 0.550319862774772 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Plotting browser tracks with CoAccessibility markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000, loops = getCoAccessibility(projHeme5) ) ## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-11a703dda2936-Date-2020-04-15_Time-11-56-18.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:56:18 : Validating Region, 0.007 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 11:56:18 : Adding Bulk Tracks (1 of 9), 0.01 mins elapsed. ## 2020-04-15 11:56:21 : Adding Feature Tracks (1 of 9), 0.053 mins elapsed. ## 2020-04-15 11:56:21 : Adding Loop Tracks (1 of 9), 0.056 mins elapsed. ## 2020-04-15 11:56:21 : Adding Gene Tracks (1 of 9), 0.059 mins elapsed. ## 2020-04-15 11:56:21 : Plotting, 0.065 mins elapsed. ## 2020-04-15 11:56:24 : Adding Bulk Tracks (2 of 9), 0.1 mins elapsed. ## 2020-04-15 11:56:26 : Adding Feature Tracks (2 of 9), 0.137 mins elapsed. ## 2020-04-15 11:56:26 : Adding Loop Tracks (2 of 9), 0.139 mins elapsed. ## 2020-04-15 11:56:26 : Adding Gene Tracks (2 of 9), 0.144 mins elapsed. ## 2020-04-15 11:56:27 : Plotting, 0.151 mins elapsed. ## 2020-04-15 11:56:28 : Adding Bulk Tracks (3 of 9), 0.181 mins elapsed. ## 2020-04-15 11:56:30 : Adding Feature Tracks (3 of 9), 0.202 mins elapsed. ## 2020-04-15 11:56:30 : Adding Loop Tracks (3 of 9), 0.205 mins elapsed. ## 2020-04-15 11:56:31 : Adding Gene Tracks (3 of 9), 0.217 mins elapsed. ## 2020-04-15 11:56:31 : Plotting, 0.223 mins elapsed. ## 2020-04-15 11:56:33 : Adding Bulk Tracks (4 of 9), 0.257 mins elapsed. ## 2020-04-15 11:56:34 : Adding Feature Tracks (4 of 9), 0.272 mins elapsed. ## 2020-04-15 11:56:34 : Adding Loop Tracks (4 of 9), 0.275 mins elapsed. ## 2020-04-15 11:56:34 : Adding Gene Tracks (4 of 9), 0.281 mins elapsed. ## 2020-04-15 11:56:35 : Plotting, 0.287 mins elapsed. ## 2020-04-15 11:56:36 : Adding Bulk Tracks (5 of 9), 0.31 mins elapsed. ## 2020-04-15 11:56:37 : Adding Feature Tracks (5 of 9), 0.327 mins elapsed. ## 2020-04-15 11:56:37 : Adding Loop Tracks (5 of 9), 0.329 mins elapsed. ## 2020-04-15 11:56:38 : Adding Gene Tracks (5 of 9), 0.335 mins elapsed. ## 2020-04-15 11:56:38 : Plotting, 0.339 mins elapsed. ## 2020-04-15 11:56:40 : Adding Bulk Tracks (6 of 9), 0.367 mins elapsed. ## 2020-04-15 11:56:41 : Adding Feature Tracks (6 of 9), 0.384 mins elapsed. ## 2020-04-15 11:56:41 : Adding Loop Tracks (6 of 9), 0.385 mins elapsed. ## 2020-04-15 11:56:41 : Adding Gene Tracks (6 of 9), 0.391 mins elapsed. ## 2020-04-15 11:56:41 : Plotting, 0.395 mins elapsed. ## 2020-04-15 11:56:43 : Adding Bulk Tracks (7 of 9), 0.422 mins elapsed. ## 2020-04-15 11:56:44 : Adding Feature Tracks (7 of 9), 0.443 mins elapsed. ## 2020-04-15 11:56:44 : Adding Loop Tracks (7 of 9), 0.447 mins elapsed. ## 2020-04-15 11:56:45 : Adding Gene Tracks (7 of 9), 0.455 mins elapsed. ## 2020-04-15 11:56:45 : Plotting, 0.459 mins elapsed. ## 2020-04-15 11:56:47 : Adding Bulk Tracks (8 of 9), 0.489 mins elapsed. ## 2020-04-15 11:56:48 : Adding Feature Tracks (8 of 9), 0.506 mins elapsed. ## 2020-04-15 11:56:48 : Adding Loop Tracks (8 of 9), 0.51 mins elapsed. ## 2020-04-15 11:56:49 : Adding Gene Tracks (8 of 9), 0.522 mins elapsed. ## 2020-04-15 11:56:49 : Plotting, 0.526 mins elapsed. ## 2020-04-15 11:56:51 : Adding Bulk Tracks (9 of 9), 0.562 mins elapsed. ## 2020-04-15 11:56:52 : Adding Feature Tracks (9 of 9), 0.578 mins elapsed. ## 2020-04-15 11:56:52 : Adding Loop Tracks (9 of 9), 0.58 mins elapsed. ## 2020-04-15 11:56:53 : Adding Gene Tracks (9 of 9), 0.589 mins elapsed. ## 2020-04-15 11:56:53 : Plotting, 0.594 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-11a703dda2936-Date-2020-04-15_Time-11-56-18.log To plot a track we can simply print one from the list grid::grid.newpage() grid::grid.draw(p$CD14) plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes-with-CoAccessibility.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## [1] 0 Download PDF : Plot-Tracks-Marker-Genes.pdf "],
["peak2genelinkage-with-archr.html", "14.2 Peak2GeneLinkage with ArchR", " 14.2 Peak2GeneLinkage with ArchR projHeme5 &lt;- addPeak2GeneLinks( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addPeak2GeneLinks-11a7017ae41d-Date-2020-04-15_Time-11-57-10.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:57:11 : Getting Available Matrices, 0.006 mins elapsed. ## 2020-04-15 11:57:11 : Filtered Low Prediction Score Cells (1049 of 10251, 0.102), 0.004 mins elapsed. ## 2020-04-15 11:57:12 : Computing KNN, 0.009 mins elapsed. ## 2020-04-15 11:57:12 : Identifying Non-Overlapping KNN pairs, 0.016 mins elapsed. ## 2020-04-15 11:57:15 : Identified 491 Groupings!, 0.07 mins elapsed. ## 2020-04-15 11:57:15 : Getting Group RNA Matrix, 0.071 mins elapsed. ## 2020-04-15 11:57:43 : Getting Group ATAC Matrix, 0.536 mins elapsed. ## 2020-04-15 11:58:18 : Normalizing Group Matrices, 1.112 mins elapsed. ## 2020-04-15 11:58:24 : Finding Peak Gene Pairings, 1.218 mins elapsed. ## 2020-04-15 11:58:25 : Computing Correlations, 1.227 mins elapsed. ## 2020-04-15 11:58:34 : Completed Peak2Gene Correlations!, 1.382 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeak2GeneLinks-11a7017ae41d-Date-2020-04-15_Time-11-57-10.log p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1, returnLoops = FALSE ) p2g ## DataFrame with 43754 rows and 6 columns ## idxATAC idxRNA Correlation FDR ## ## 1 47 5 0.549552663393716 1.34094093110629e-38 ## 2 3 6 0.487418258348982 2.1460798658766e-29 ## 3 3 7 0.821369314290254 1.70141157082175e-118 ## 4 47 7 0.569899085935183 4.61958766180263e-42 ## 5 59 7 0.549954043409585 1.15152278593831e-38 ## … … … … … ## 43750 143964 18590 0.520703047216992 4.37554114264876e-34 ## 43751 143977 18590 0.546301068655939 4.54936701954597e-38 ## 43752 144004 18594 0.47934214168793 2.47516776950818e-28 ## 43753 143999 18598 0.49092225993235 7.28579053551407e-30 ## 43754 144005 18598 0.493389088498317 3.37643947034054e-30 ## VarQATAC VarQRNA ## ## 1 0.948753202924817 0.793290683296597 ## 2 0.253206396822421 0.445890005913661 ## 3 0.253206396822421 0.42728885543788 ## 4 0.948753202924817 0.42728885543788 ## 5 0.916137185870328 0.42728885543788 ## … … … ## 43750 0.629044018082203 0.960701037578625 ## 43751 0.701518655084057 0.960701037578625 ## 43752 0.814587977140318 0.802537497983979 ## 43753 0.0392197709865356 0.901295629267244 ## 43754 0.158948399058392 0.901295629267244 metadata(p2g)[[1]] ## GRanges object with 144009 ranges and 0 metadata columns: ## seqnames ranges strand ## ## [1] chr1 752499-752999 * ## [2] chr1 762651-763151 * ## [3] chr1 801006-801506 * ## [4] chr1 805039-805539 * ## [5] chr1 845325-845825 * ## … … … … ## [144005] chrX 154664540-154665040 * ## [144006] chrX 154807324-154807824 * ## [144007] chrX 154840785-154841285 * ## [144008] chrX 154842404-154842904 * ## [144009] chrX 154862017-154862517 * ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 43695 ranges and 2 metadata columns: ## seqnames ranges strand | value ## | ## [1] chr1 762901-948847 * | 0.533350285896763 ## [2] chr1 801256-895967 * | 0.487418258348982 ## [3] chr1 801256-901877 * | 0.821369314290254 ## [4] chr1 852367-955503 * | 0.487693663181145 ## [5] chr1 894679-968584 * | 0.549552663393716 ## … … … … . … ## [43691] chrX 153962451-153979858 * | 0.453720046871409 ## [43692] chrX 153980218-153991031 * | 0.546301068655939 ## [43693] chrX 154255064-154493795 * | 0.47934214168793 ## [43694] chrX 154356425-154444701 * | 0.49092225993235 ## [43695] chrX 154444701-154664790 * | 0.493389088498317 ## FDR ## ## [1] 5.20045729958651e-36 ## [2] 2.1460798658766e-29 ## [3] 1.70141157082175e-118 ## [4] 1.97244775926907e-29 ## [5] 1.34094093110629e-38 ## … … ## [43691] 3.78754241443136e-25 ## [43692] 4.54936701954597e-38 ## [43693] 2.47516776950818e-28 ## [43694] 7.28579053551407e-30 ## [43695] 3.37643947034054e-30 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1000, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 42126 ranges and 2 metadata columns: ## seqnames ranges strand | value ## | ## [1] chr1 762500-948500 * | 0.533350285896763 ## [2] chr1 801500-895500 * | 0.487418258348982 ## [3] chr1 801500-901500 * | 0.821369314290254 ## [4] chr1 852500-955500 * | 0.487693663181145 ## [5] chr1 894500-968500 * | 0.549552663393716 ## … … … … . … ## [42122] chrX 153962500-153979500 * | 0.453720046871409 ## [42123] chrX 153980500-153991500 * | 0.546301068655939 ## [42124] chrX 154255500-154493500 * | 0.47934214168793 ## [42125] chrX 154356500-154444500 * | 0.49092225993235 ## [42126] chrX 154444500-154664500 * | 0.493389088498317 ## FDR ## ## [1] 5.20045729958651e-36 ## [2] 2.1460798658766e-29 ## [3] 1.70141157082175e-118 ## [4] 1.97244775926907e-29 ## [5] 1.34094093110629e-38 ## … … ## [42122] 3.78754241443136e-25 ## [42123] 4.54936701954597e-38 ## [42124] 2.47516776950818e-28 ## [42125] 7.28579053551407e-30 ## [42126] 3.37643947034054e-30 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 10000, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 33645 ranges and 2 metadata columns: ## seqnames ranges strand | value ## | ## [1] chr1 765000-945000 * | 0.533350285896763 ## [2] chr1 805000-895000 * | 0.487418258348982 ## [3] chr1 805000-905000 * | 0.821369314290254 ## [4] chr1 855000-955000 * | 0.487693663181145 ## [5] chr1 895000-965000 * | 0.549552663393716 ## … … … … . … ## [33641] chrX 153965000-153975000 * | 0.453720046871409 ## [33642] chrX 153985000-153995000 * | 0.546301068655939 ## [33643] chrX 154255000-154495000 * | 0.47934214168793 ## [33644] chrX 154355000-154445000 * | 0.49092225993235 ## [33645] chrX 154445000-154665000 * | 0.493389088498317 ## FDR ## ## [1] 5.20045729958651e-36 ## [2] 2.1460798658766e-29 ## [3] 1.70141157082175e-118 ## [4] 1.97244775926907e-29 ## [5] 1.34094093110629e-38 ## … … ## [33641] 3.78754241443136e-25 ## [33642] 4.54936701954597e-38 ## [33643] 2.47516776950818e-28 ## [33644] 7.28579053551407e-30 ## [33645] 3.37643947034054e-30 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Plotting browser tracks with Peak2Gene Links markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000, loops = getPeak2GeneLinks(projHeme5) ) ## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-11a7048fa912a-Date-2020-04-15_Time-11-58-35.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:58:36 : Validating Region, 0.012 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 11:58:36 : Adding Bulk Tracks (1 of 9), 0.015 mins elapsed. ## 2020-04-15 11:58:37 : Adding Feature Tracks (1 of 9), 0.038 mins elapsed. ## 2020-04-15 11:58:37 : Adding Loop Tracks (1 of 9), 0.039 mins elapsed. ## 2020-04-15 11:58:37 : Adding Gene Tracks (1 of 9), 0.041 mins elapsed. ## 2020-04-15 11:58:38 : Plotting, 0.045 mins elapsed. ## 2020-04-15 11:58:39 : Adding Bulk Tracks (2 of 9), 0.076 mins elapsed. ## 2020-04-15 11:58:40 : Adding Feature Tracks (2 of 9), 0.091 mins elapsed. ## 2020-04-15 11:58:41 : Adding Loop Tracks (2 of 9), 0.095 mins elapsed. ## 2020-04-15 11:58:41 : Adding Gene Tracks (2 of 9), 0.098 mins elapsed. ## 2020-04-15 11:58:41 : Plotting, 0.104 mins elapsed. ## 2020-04-15 11:58:43 : Adding Bulk Tracks (3 of 9), 0.134 mins elapsed. ## 2020-04-15 11:58:44 : Adding Feature Tracks (3 of 9), 0.151 mins elapsed. ## 2020-04-15 11:58:44 : Adding Loop Tracks (3 of 9), 0.153 mins elapsed. ## 2020-04-15 11:58:44 : Adding Gene Tracks (3 of 9), 0.157 mins elapsed. ## 2020-04-15 11:58:45 : Plotting, 0.162 mins elapsed. ## 2020-04-15 11:58:47 : Adding Bulk Tracks (4 of 9), 0.196 mins elapsed. ## 2020-04-15 11:58:48 : Adding Feature Tracks (4 of 9), 0.212 mins elapsed. ## 2020-04-15 11:58:48 : Adding Loop Tracks (4 of 9), 0.213 mins elapsed. ## 2020-04-15 11:58:48 : Adding Gene Tracks (4 of 9), 0.216 mins elapsed. ## 2020-04-15 11:58:48 : Plotting, 0.22 mins elapsed. ## 2020-04-15 11:58:49 : Adding Bulk Tracks (5 of 9), 0.242 mins elapsed. ## 2020-04-15 11:58:50 : Adding Feature Tracks (5 of 9), 0.258 mins elapsed. ## 2020-04-15 11:58:51 : Adding Loop Tracks (5 of 9), 0.26 mins elapsed. ## 2020-04-15 11:58:51 : Adding Gene Tracks (5 of 9), 0.268 mins elapsed. ## 2020-04-15 11:58:51 : Plotting, 0.273 mins elapsed. ## 2020-04-15 11:58:53 : Adding Bulk Tracks (6 of 9), 0.307 mins elapsed. ## 2020-04-15 11:58:54 : Adding Feature Tracks (6 of 9), 0.323 mins elapsed. ## 2020-04-15 11:58:54 : Adding Loop Tracks (6 of 9), 0.325 mins elapsed. ## 2020-04-15 11:58:55 : Adding Gene Tracks (6 of 9), 0.333 mins elapsed. ## 2020-04-15 11:58:55 : Plotting, 0.338 mins elapsed. ## 2020-04-15 11:58:57 : Adding Bulk Tracks (7 of 9), 0.369 mins elapsed. ## 2020-04-15 11:58:58 : Adding Feature Tracks (7 of 9), 0.389 mins elapsed. ## 2020-04-15 11:58:58 : Adding Loop Tracks (7 of 9), 0.391 mins elapsed. ## 2020-04-15 11:58:59 : Adding Gene Tracks (7 of 9), 0.397 mins elapsed. ## 2020-04-15 11:58:59 : Plotting, 0.403 mins elapsed. ## 2020-04-15 11:59:01 : Adding Bulk Tracks (8 of 9), 0.443 mins elapsed. ## 2020-04-15 11:59:03 : Adding Feature Tracks (8 of 9), 0.462 mins elapsed. ## 2020-04-15 11:59:03 : Adding Loop Tracks (8 of 9), 0.464 mins elapsed. ## 2020-04-15 11:59:03 : Adding Gene Tracks (8 of 9), 0.468 mins elapsed. ## 2020-04-15 11:59:03 : Plotting, 0.473 mins elapsed. ## 2020-04-15 11:59:06 : Adding Bulk Tracks (9 of 9), 0.515 mins elapsed. ## 2020-04-15 11:59:07 : Adding Feature Tracks (9 of 9), 0.533 mins elapsed. ## 2020-04-15 11:59:07 : Adding Loop Tracks (9 of 9), 0.536 mins elapsed. ## 2020-04-15 11:59:07 : Adding Gene Tracks (9 of 9), 0.543 mins elapsed. ## 2020-04-15 11:59:08 : Plotting, 0.549 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-11a7048fa912a-Date-2020-04-15_Time-11-58-35.log To plot a track we can simply print one from the list grid::grid.newpage() grid::grid.draw(p$CD14) plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes-with-Peak2GeneLinks.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## [1] 0 Download PDF : Plot-Tracks-Marker-Genes.pdf Lastly we can make a peak2gene heatmap p &lt;- peak2GeneHeatmap(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-peak2GeneHeatmap-11a707e40d64f-Date-2020-04-15_Time-11-59-30.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:59:34 : Determining KNN Groups!, 0.071 mins elapsed. ## 2020-04-15 11:59:39 : Ordering Peak2Gene Links!, 0.15 mins elapsed. ## 2020-04-15 11:59:48 : Constructing ATAC Heatmap!, 0.309 mins elapsed. ## Adding Annotations.. ## Preparing Main Heatmap.. ## 2020-04-15 11:59:49 : Constructing RNA Heatmap!, 0.32 mins elapsed. ## Adding Annotations.. ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-peak2GeneHeatmap-11a707e40d64f-Date-2020-04-15_Time-11-59-30.log p "],
["identification-of-positive-tf-regulators.html", "14.3 Identification of Positive TF-Regulators", " 14.3 Identification of Positive TF-Regulators Step 1. Identify Deviant TF Motifs seGroupMotif &lt;- exportGroupSE(ArchRProj = projHeme5, useMatrix = &quot;MotifMatrix&quot;, groupBy = &quot;Clusters2&quot;) ## 2020-04-15 12:03:08 : Successfully Created Group Matrix, 0.133 mins elapsed. seGroupMotif ## class: SummarizedExperiment ## dim: 1740 11 ## metadata(0): ## assays(1): MotifMatrix ## rownames(1740): f1 f2 … f1739 f1740 ## rowData names(3): seqnames idx name ## colnames(11): B CD4.M … PreB Progenitor ## colData names(16): TSSEnrichment ReadsInTSS … FRIP nCells #Get Deviation Z-Scores seZ &lt;- seGroupMotif[rowData(seGroupMotif)$seqnames==&quot;z&quot;,] #Max Delta rowData(seZ)$maxDelta &lt;- lapply(seq_len(ncol(seZ)), function(x){ rowMaxs(assay(seZ) - assay(seZ)[,x]) }) %&gt;% Reduce(&quot;cbind&quot;, .) %&gt;% rowMaxs Step 2. Identify Correlated TF Motifs and TF Gene Score/Expression corGSM_MM &lt;- correlateMatrices( ArchRProj = projHeme5, useMatrix1 = &quot;GeneScoreMatrix&quot;, useMatrix2 = &quot;MotifMatrix&quot;, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-correlateMatrices-11a7038ad0163-Date-2020-04-15_Time-12-03-11.log ## If there is an issue, please report to github with logFile! ## When accessing features from a matrix of class Sparse.Assays.Matrix it requires 1 seqname! ## Continuing with first seqname ‘z’! ## If confused, try getFeatures(ArchRProj, ‘MotifMatrix’) to list out available seqnames for input! ## 2020-04-15 12:03:16 : Testing 825 Mappings!, 0.091 mins elapsed. ## 2020-04-15 12:03:16 : Computing KNN, 0.091 mins elapsed. ## 2020-04-15 12:03:16 : Identifying Non-Overlapping KNN pairs, 0.095 mins elapsed. ## 2020-04-15 12:03:19 : Identified 491 Groupings!, 0.138 mins elapsed. ## 2020-04-15 12:03:21 : Getting Group Matrix 1, 0.17 mins elapsed. ## 2020-04-15 12:03:33 : Getting Group Matrix 2, 0.365 mins elapsed. ## Some entries in groupMat2 are less than 0, continuing without Log2 Normalization. ## Most likely this assay is a deviations matrix. ## Getting Correlations… ## 2020-04-15 12:03:40 : ## Computing Correlation (250 of 825) ## Computing Correlation (500 of 825) ## Computing Correlation (750 of 825) ## ArchR logging successful to : ArchRLogs/ArchR-correlateMatrices-11a7038ad0163-Date-2020-04-15_Time-12-03-11.log corGSM_MM ## DataFrame with 825 rows and 14 columns ## GeneScoreMatrix_name MotifMatrix_name cor ## ## 1 HES4 HES4_95 0.154455056755803 ## 2 HES5 HES5_98 0.337473683281965 ## 3 PRDM16 PRDM16_211 0.491297659378326 ## 4 TP73 TP73_705 0.528916107713827 ## 5 TP73-AS1 TP73_705 -0.0522225826610403 ## … … … … ## 821 TFDP3 TFDP3_309 -0.0747374184980152 ## 822 ZNF75D ZNF75D_272 -0.0515391773083338 ## 823 ZIC3 ZIC3_215 0.3158469818621 ## 824 SOX3 SOX3_759 -0.016068246967503 ## 825 MECP2 MECP2_645 0.0629645419544807 ## padj pval GeneScoreMatrix_seqnames ## ## 1 0.48577773775473 0.000593860315103582 chr1 ## 2 1.24697036872354e-11 1.52441365369626e-14 chr1 ## 3 2.77075935285262e-28 3.38723637268047e-31 chr1 ## 4 7.91605921989722e-34 9.6773340096543e-37 chr1 ## 5 1 0.248084710011419 chr1 ## … … … … ## 821 1 0.0980942700648066 chrX ## 822 1 0.254336826019648 chrX ## 823 6.35887872390377e-10 7.77369037152051e-13 chrX ## 824 1 0.722466734136741 chrX ## 825 1 0.163611488297825 chrX ## GeneScoreMatrix_start GeneScoreMatrix_end GeneScoreMatrix_strand ## ## 1 935552 934342 2 ## 2 2461684 2460184 2 ## 3 2985742 3355185 1 ## 4 3569129 3652765 1 ## 5 3663937 3652548 2 ## … … … … ## 821 132352376 132350697 2 ## 822 134429965 134419723 2 ## 823 136648346 136654259 1 ## 824 139587225 139585152 2 ## 825 153363188 153287264 2 ## GeneScoreMatrix_idx GeneScoreMatrix_matchName MotifMatrix_seqnames ## ## 1 15 HES4 z ## 2 74 HES5 z ## 3 82 PRDM16 z ## 4 89 TP73 z ## 5 90 TP73 z ## … … … … ## 821 697 TFDP3 z ## 822 728 ZNF75D z ## 823 753 ZIC3 z ## 824 765 SOX3 z ## 825 874 MECP2 z ## MotifMatrix_idx MotifMatrix_matchName ## ## 1 95 HES4 ## 2 98 HES5 ## 3 211 PRDM16 ## 4 705 TP73 ## 5 705 TP73 ## … … … ## 821 309 TFDP3 ## 822 272 ZNF75D ## 823 215 ZIC3 ## 824 759 SOX3 ## 825 645 MECP2 corGIM_MM &lt;- correlateMatrices( ArchRProj = projHeme5, useMatrix1 = &quot;GeneIntegrationMatrix&quot;, useMatrix2 = &quot;MotifMatrix&quot;, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-correlateMatrices-11a70642ae62f-Date-2020-04-15_Time-12-03-41.log ## If there is an issue, please report to github with logFile! ## When accessing features from a matrix of class Sparse.Assays.Matrix it requires 1 seqname! ## Continuing with first seqname ‘z’! ## If confused, try getFeatures(ArchRProj, ‘MotifMatrix’) to list out available seqnames for input! ## 2020-04-15 12:03:44 : Testing 798 Mappings!, 0.062 mins elapsed. ## 2020-04-15 12:03:44 : Computing KNN, 0.062 mins elapsed. ## 2020-04-15 12:03:45 : Identifying Non-Overlapping KNN pairs, 0.066 mins elapsed. ## 2020-04-15 12:03:47 : Identified 491 Groupings!, 0.108 mins elapsed. ## 2020-04-15 12:03:50 : Getting Group Matrix 1, 0.147 mins elapsed. ## 2020-04-15 12:04:03 : Getting Group Matrix 2, 0.368 mins elapsed. ## Some entries in groupMat2 are less than 0, continuing without Log2 Normalization. ## Most likely this assay is a deviations matrix. ## Getting Correlations… ## 2020-04-15 12:04:10 : ## Computing Correlation (250 of 798) ## Computing Correlation (500 of 798) ## Computing Correlation (750 of 798) ## ArchR logging successful to : ArchRLogs/ArchR-correlateMatrices-11a70642ae62f-Date-2020-04-15_Time-12-03-41.log corGIM_MM ## DataFrame with 798 rows and 14 columns ## GeneIntegrationMatrix_name MotifMatrix_name cor ## ## 1 HES4 HES4_95 -0.0623909761741224 ## 2 HES5 HES5_98 -0.130794628882194 ## 3 PRDM16 PRDM16_211 0.526453624653558 ## 4 TP73 TP73_705 NA ## 5 HES2 HES2_19 -0.267296043452788 ## … … … … ## 794 TFDP3 TFDP3_309 NA ## 795 ZNF75D ZNF75D_272 -0.253529703381296 ## 796 ZIC3 ZIC3_215 NA ## 797 SOX3 SOX3_759 NA ## 798 MECP2 MECP2_645 0.150328680116803 ## padj pval GeneIntegrationMatrix_seqnames ## ## 1 1 0.167490297051793 chr1 ## 2 1 0.00369241031157534 chr1 ## 3 1.23364764777334e-33 2.34533773340939e-36 chr1 ## 4 NA NA chr1 ## 5 9.31006760220939e-07 1.76997482931738e-09 chr1 ## … … … … ## 794 NA NA chrX ## 795 6.41888945797785e-06 1.22032118972963e-08 chrX ## 796 NA NA chrX ## 797 NA NA chrX ## 798 0.438175655348636 0.000833033565301589 chrX ## GeneIntegrationMatrix_start GeneIntegrationMatrix_end ## ## 1 935552 934342 ## 2 2461684 2460184 ## 3 2985742 3355185 ## 4 3569129 3652765 ## 5 6484730 6472498 ## … … … ## 794 132352376 132350697 ## 795 134429965 134419723 ## 796 136648346 136654259 ## 797 139587225 139585152 ## 798 153363188 153287264 ## GeneIntegrationMatrix_strand GeneIntegrationMatrix_idx ## ## 1 2 8 ## 2 2 53 ## 3 1 59 ## 4 1 64 ## 5 2 81 ## … … … ## 794 2 562 ## 795 2 576 ## 796 1 595 ## 797 2 602 ## 798 2 680 ## GeneIntegrationMatrix_matchName MotifMatrix_seqnames MotifMatrix_idx ## ## 1 HES4 z 95 ## 2 HES5 z 98 ## 3 PRDM16 z 211 ## 4 TP73 z 705 ## 5 HES2 z 19 ## … … … … ## 794 TFDP3 z 309 ## 795 ZNF75D z 272 ## 796 ZIC3 z 215 ## 797 SOX3 z 759 ## 798 MECP2 z 645 ## MotifMatrix_matchName ## ## 1 HES4 ## 2 HES5 ## 3 PRDM16 ## 4 TP73 ## 5 HES2 ## … … ## 794 TFDP3 ## 795 ZNF75D ## 796 ZIC3 ## 797 SOX3 ## 798 MECP2 Step 3. Add Maximum Delta Deviation to the Correlation Data Frame corGSM_MM$maxDelta &lt;- rowData(seZ)[match(corGSM_MM$MotifMatrix_name, rowData(seZ)$name), &quot;maxDelta&quot;] corGIM_MM$maxDelta &lt;- rowData(seZ)[match(corGIM_MM$MotifMatrix_name, rowData(seZ)$name), &quot;maxDelta&quot;] Step 4. Identify Positive TF Regulators For Gene Scores corGSM_MM &lt;- corGSM_MM[order(abs(corGSM_MM$cor), decreasing = TRUE), ] corGSM_MM &lt;- corGSM_MM[which(!duplicated(gsub(&quot;\\\\-.*&quot;,&quot;&quot;,corGSM_MM[,&quot;MotifMatrix_name&quot;]))), ] corGSM_MM$TFRegulator &lt;- &quot;NO&quot; corGSM_MM$TFRegulator[which(corGSM_MM$cor &gt; 0.5 &amp; corGSM_MM$padj &lt; 0.01 &amp; corGSM_MM$maxDelta &gt; quantile(corGSM_MM$maxDelta, 0.75))] &lt;- &quot;YES&quot; sort(corGSM_MM[corGSM_MM$TFRegulator==&quot;YES&quot;,1]) ## [1] “ATOH1” “BCL11A” “CEBPA-DT” “CEBPB” “CEBPD” “CREB1” ## [7] “CREB3L4” “EBF1” “EGR2” “EOMES” “ERF” “ESR1” ## [13] “ETS1” “ETV3” “FUBP1” “GATA1” “GATA2” “GATA5” ## [19] “GATA6” “IRF1” “JDP2” “KLF11” “KLF2” “LYL1” ## [25] “MECOM” “MITF” “NFE2” “NFIA” “NFIB” “NFIC” ## [31] “NFIX” “NHLH1” “POU2F1” “RUNX2” “SIX5” “SMAD1” ## [37] “SMAD9” “SP4” “SPI1” “SPIB” “TAL1” “TCF15” ## [43] “TCF23” “TCF4” “TFAP2C” “TWIST1” “TWIST2” “YY1” ## [49] “ZEB1-AS1” p &lt;- ggplot(data.frame(corGSM_MM), aes(cor, maxDelta, color = TFRegulator)) + geom_point() + theme_ArchR() + geom_vline(xintercept = 0, lty = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;NO&quot;=&quot;darkgrey&quot;, &quot;YES&quot;=&quot;firebrick3&quot;)) + xlab(&quot;Correlation To Gene Expression&quot;) + ylab(&quot;Max TF Motif Delta&quot;) + scale_y_continuous( expand = c(0,0), limits = c(0, max(corGSM_MM$maxDelta)*1.05) ) p ## Warning: Removed 7 rows containing missing values (geom_point). For Gene Expression corGIM_MM &lt;- corGIM_MM[order(abs(corGIM_MM$cor), decreasing = TRUE), ] corGIM_MM &lt;- corGIM_MM[which(!duplicated(gsub(&quot;\\\\-.*&quot;,&quot;&quot;,corGIM_MM[,&quot;MotifMatrix_name&quot;]))), ] corGIM_MM$TFRegulator &lt;- &quot;NO&quot; corGIM_MM$TFRegulator[which(corGIM_MM$cor &gt; 0.5 &amp; corGIM_MM$padj &lt; 0.01 &amp; corGIM_MM$maxDelta &gt; quantile(corGIM_MM$maxDelta, 0.75))] &lt;- &quot;YES&quot; sort(corGIM_MM[corGIM_MM$TFRegulator==&quot;YES&quot;,1]) ## [1] “ATF1” “BACH1” “CEBPA” “CEBPB” “CEBPD” “CEBPE” “CEBPG” “CTCF” ## [9] “EBF1” “ELK1” “EOMES” “ETS1” “FOS” “FOSB” “FOSL2” “GATA1” ## [17] “GATA2” “IRF1” “IRF2” “IRF9” “JDP2” “KLF2” “MECOM” “MITF” ## [25] “NFE2” “NFIA” “NFIB” “NFIC” “NFIX” “NR4A1” “POU2F2” “PRDM16” ## [33] “RUNX1” “SMAD1” “SPI1” “STAT2” “TCF3” “TCF4” “UBP1” p &lt;- ggplot(data.frame(corGIM_MM), aes(cor, maxDelta, color = TFRegulator)) + geom_point() + theme_ArchR() + geom_vline(xintercept = 0, lty = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;NO&quot;=&quot;darkgrey&quot;, &quot;YES&quot;=&quot;firebrick3&quot;)) + xlab(&quot;Correlation To Gene Expression&quot;) + ylab(&quot;Max TF Motif Delta&quot;) + scale_y_continuous( expand = c(0,0), limits = c(0, max(corGIM_MM$maxDelta)*1.05) ) p ## Warning: Removed 255 rows containing missing values (geom_point). "],
["session-information-13.html", "14.4 Session Information", " 14.4 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "],
["trajectory-analysis-with-archr.html", "Chapter 15 Trajectory Analysis with ArchR ", " Chapter 15 Trajectory Analysis with ArchR "],
["myeloid-trajectory.html", "15.1 Myeloid Trajectory", " 15.1 Myeloid Trajectory p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1326ab29a8-Date-2020-04-15_Time-14-59-47.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1326ab29a8-Date-2020-04-15_Time-14-59-47.log p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1339bfbfcf-Date-2020-04-15_Time-14-59-49.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1339bfbfcf-Date-2020-04-15_Time-14-59-49.log ggAlignPlots(p1, p2, type = &quot;h&quot;) #Trajectory to add trajectory &lt;- c(&quot;Progenitor&quot;, &quot;GMP&quot;, &quot;Mono&quot;) trajectory ## [1] “Progenitor” “GMP” “Mono” #First we need to create a Trajectory and add it to ArchRProj cellColData projHeme5 &lt;- addTrajectory( ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, groupBy = &quot;Clusters2&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE ) ## ArchR logging to : ArchRLogs/ArchR-addTrajectory-15e132f14b12b-Date-2020-04-15_Time-15-00-01.log ## If there is an issue, please report to github with logFile! ## Filtering outliers ## Initial Alignment Before Spline Fit ## Spline Fit ## KNN to Spline ## Aligning cells not in trajectory ## ArchR logging successful to : ArchRLogs/ArchR-addTrajectory-15e132f14b12b-Date-2020-04-15_Time-15-00-01.log head(projHeme5$MyeloidU[!is.na(projHeme5$MyeloidU)]) #NA means not in trajectory ## [1] 46.07479 53.75027 44.82834 43.18828 47.49617 43.21015 p &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;colData&quot;, name = &quot;MyeloidU&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e136ad2f619-Date-2020-04-15_Time-15-00-03.log ## If there is an issue, please report to github with logFile! ## Plotting ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e136ad2f619-Date-2020-04-15_Time-15-00-03.log p[[1]] ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p, name = &quot;Plot-MyeloidU-Traj-UMAP.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## [1] “plotting ggplot!” ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## [1] 0 We can overlay other features on the UMAP projHeme5 &lt;- addImputeWeights(projHeme5) ## 2020-04-15 15:00:28 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 15:00:40 : Completed Getting Magic Weights!, 0.206 mins elapsed. p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;horizonExtra&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e13179524ae-Date-2020-04-15_Time-15-00-40.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e13179524ae-Date-2020-04-15_Time-15-00-40.log p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;blueYellow&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e133644196a-Date-2020-04-15_Time-15-00-47.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e133644196a-Date-2020-04-15_Time-15-00-47.log ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ We can then make a heatmap for trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Some values are below 0, this could be a DeviationsMatrix in which scaleTo should be set = NULL. ## Continuing without depth normalization! ## Smoothing… p1 &lt;- trajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131c8ea2de-Date-2020-04-15_Time-15-01-31.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:01:31 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:01:31 : ## Removing rows with NA values… ## 2020-04-15 15:01:31 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131c8ea2de-Date-2020-04-15_Time-15-01-31.log trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p2 &lt;- trajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e132f1f4173-Date-2020-04-15_Time-15-01-51.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e132f1f4173-Date-2020-04-15_Time-15-01-51.log trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Smoothing… p3 &lt;- trajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1333158a4-Date-2020-04-15_Time-15-02-18.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1333158a4-Date-2020-04-15_Time-15-02-18.log trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p4 &lt;- trajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131ecfb872-Date-2020-04-15_Time-15-03-01.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131ecfb872-Date-2020-04-15_Time-15-03-01.log To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, p2, p3, p4, name = &quot;Plot-MyeloidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) ## [1] 0 We can also perform integrative analyses such as identifying positive regulators with RNA #Gene Scores corGSM_MM &lt;- correlateTrajectories(trajGSM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e13b9ca02a-Date-2020-04-15_Time-15-03-37.log ## If there is an issue, please report to github with logFile! ## Found 36 Correlated Pairings! ## 2020-04-15 15:03:56 : corGSM_MM[[1]]$matchname1 ## [1] “PRDM16” “TAL1” “JUN” “ATF3” “GATA3” “GATA3” “ZEB1” “NFKB2” ## [9] “IRF7” “KLF12” “FOS” “MEF2A” “IRF8” “NR1D1” “HOXB1” “JUNB” ## [17] “NFIX” “LYL1” “KLF2” “FOSB” “NR1H2” “KLF11” “GLI2” “NR4A2” ## [25] “TCF15” “CEBPB” “ETS2” “XBP1” “GATA2” “MECOM” “IRF1” “CEBPD” ## [33] “SNAI2” “NFIL3” “KLF4” “RXRA” corGSM_MM[[1]] ## DataFrame with 36 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 82 1081 PRDM16 PRDM16 chr1:PRDM16 z:PRDM16_211 ## 2 731 932 TAL1 TAL1 chr1:TAL1 z:TAL1_62 ## 3 818 1013 JUN JUN chr1:JUN z:JUN_143 ## 4 2034 1002 ATF3 ATF3 chr1:ATF3 z:ATF3_132 ## 5 2369 1254 GATA3 GATA3 chr10:GATA3 z:GATA3_384 ## … … … … … … … ## 32 20775 1022 CEBPD CEBPD chr8:CEBPD z:CEBPD_152 ## 33 20780 1031 SNAI2 SNAI2 chr8:SNAI2 z:SNAI2_161 ## 34 21658 1003 NFIL3 NFIL3 chr9:NFIL3 z:NFIL3_133 ## 35 21793 1078 KLF4 KLF4 chr9:KLF4 z:KLF4_208 ## 36 22097 1565 RXRA RXRA chr9:RXRA z:RXRA_695 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.859588836579798 0.999783802481948 0.860344827586207 16.6530781620713 ## 2 0.687938524545333 0.866735849872443 0.987931034482759 9.38348743943718 ## 3 0.530335586469274 0.993989708998141 0.963218390804598 6.19265152142139 ## 4 0.776280918431044 0.985168850261599 0.936781609195402 12.1905867620732 ## 5 0.714559116657296 0.801573917931422 0.989655172413793 10.111530171907 ## … … … … … ## 32 0.73809434207349 0.993816750983699 0.998275862068966 10.8296844080467 ## 33 0.643337129188769 0.87252994335625 0.983333333333333 8.31877485229719 ## 34 0.833740261914099 0.992303368357331 0.893103448275862 14.9479403447508 ## 35 0.82265894955927 0.998702814891685 0.905747126436782 14.3243696597426 ## 36 0.59509316489084 0.88640982401522 0.890229885057471 7.33039570155334 ## Pval FDR ## ## 1 2.47466579579935e-30 4.04855324192774e-27 ## 2 2.63756432350363e-15 1.00350121703533e-13 ## 3 1.38781951660218e-08 1.55511830764464e-07 ## 4 2.36537648993666e-21 3.22479661461365e-19 ## 5 6.9322610846337e-17 3.78039304482025e-15 ## … … … ## 32 1.93304822797782e-18 1.31769454207155e-16 ## 33 5.27319420246801e-13 1.3914428572964e-11 ## 34 5.06319064599113e-27 2.70186610322912e-24 ## 35 8.9984663184347e-26 2.45358181615986e-23 ## 36 6.60626612679289e-11 1.25672690505037e-09 #We can plot these identified regulators trajGSM2 &lt;- trajGSM[corGSM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGSM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGSM2 assay(trajCombined) &lt;- t(apply(assay(trajGSM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e136ff55add-Date-2020-04-15_Time-15-03-56.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e136ff55add-Date-2020-04-15_Time-15-03-56.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGSM2)) #Now we can plot the heatmaps ht1 &lt;- trajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e13aac5f3b-Date-2020-04-15_Time-15-03-57.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e13aac5f3b-Date-2020-04-15_Time-15-03-57.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1323caf784-Date-2020-04-15_Time-15-03-57.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:03:58 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:03:58 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1323caf784-Date-2020-04-15_Time-15-03-57.log ht1 + ht2 #Gene Expression corGIM_MM &lt;- correlateTrajectories(trajGIM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e13f7dfd04-Date-2020-04-15_Time-15-04-14.log ## If there is an issue, please report to github with logFile! ## Found 54 Correlated Pairings! ## 2020-04-15 15:04:30 : corGIM_MM[[1]]$matchname1 ## [1] “RUNX3” “NFIA” “MEF2D” “USF1” “ATF3” “ZEB1” “NFKB2” ## [8] “IRF7” “SPI1” “ESRRA” “STAT2” “FOS” “JDP2” “KLF13” ## [15] “CTCF” “IRF8” “RARA” “MLX” “MBD2” “TCF4” “HMG20B” ## [22] “JUNB” “LYL1” “KLF2” “JUND” “CEBPA” “USF2” “FOSB” ## [29] “FOSL2” “REL” “NR4A2” “SP3” “NFE2L2” “STAT1” “KLF7” ## [36] “TGIF2” “CEBPB” “BACH1” “RUNX1” “BHLHE40” “GATA2” “HLTF” ## [43] “REST” “MEF2C” “RREB1” “TFEB” “PLAGL1” “CREB5” “CEBPD” ## [50] “KLF10” “NFIL3” “KLF4” “RXRA” “TFE3” corGIM_MM[[1]] ## DataFrame with 54 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 295 1601 RUNX3 RUNX3 chr1:RUNX3 z:RUNX3_731 ## 2 680 1612 NFIA NFIA chr1:NFIA z:NFIA_742 ## 3 1227 1512 MEF2D MEF2D chr1:MEF2D z:MEF2D_642 ## 4 1317 930 USF1 USF1 chr1:USF1 z:USF1_60 ## 5 1664 1002 ATF3 ATF3 chr1:ATF3 z:ATF3_132 ## … … … … … … … ## 50 16981 1696 KLF10 KLF10 chr8:KLF10 z:KLF10_826 ## 51 17463 1003 NFIL3 NFIL3 chr9:NFIL3 z:NFIL3_133 ## 52 17560 1078 KLF4 KLF4 chr9:KLF4 z:KLF4_208 ## 53 17803 1565 RXRA RXRA chr9:RXRA z:RXRA_695 ## 54 18090 888 TFE3 TFE3 chrX:TFE3 z:TFE3_18 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.506721180509532 0.871189720982743 0.98448275862069 5.81861222342308 ## 2 0.899884055575892 0.878017310897264 0.919540229885057 20.4260514493749 ## 3 0.787682536829653 0.815493790656416 0.841379310344828 12.656866457322 ## 4 0.653303634000368 0.804204075049728 0.875287356321839 8.54234597517229 ## 5 0.847460093565636 0.813020805333047 0.936781609195402 15.8034906427774 ## … … … … … ## 50 0.57964654735637 0.953335842159024 0.864367816091954 7.04188649257934 ## 51 0.849563937747037 0.933928283425622 0.893103448275862 15.9440428922802 ## 52 0.820699669277503 0.98876404494382 0.905747126436782 14.2196070232556 ## 53 0.899871735441299 0.960485995376593 0.890229885057471 20.424581355724 ## 54 0.832322259515336 0.801247244771786 0.886206896551724 14.8650341763864 ## Pval FDR ## ## 1 7.47838268446286e-08 2.00835886256963e-07 ## 2 4.28849849649256e-37 2.40519926139511e-35 ## 3 2.45911764921563e-22 2.0096926995314e-21 ## 4 1.7427906036477e-13 7.90509804908143e-13 ## 5 1.05531067509617e-28 1.5631789374862e-27 ## … … … ## 50 2.63272438071192e-10 8.66605108651006e-10 ## 51 5.63648466586524e-29 9.05658892074619e-28 ## 52 1.46590261078753e-25 1.5687313439583e-24 ## 53 4.31312103836676e-37 2.40519926139511e-35 ## 54 7.4030081939147e-27 8.88360983269764e-26 #We can plot these identified regulators trajGIM2 &lt;- trajGIM[corGIM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGIM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGIM2 assay(trajCombined) &lt;- t(apply(assay(trajGIM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e137bbcc972-Date-2020-04-15_Time-15-04-30.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e137bbcc972-Date-2020-04-15_Time-15-04-30.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGIM2)) #Now we can plot the heatmaps ht1 &lt;- trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1331e06f29-Date-2020-04-15_Time-15-04-31.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1331e06f29-Date-2020-04-15_Time-15-04-31.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1345e2da25-Date-2020-04-15_Time-15-04-32.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:04:32 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:04:32 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1345e2da25-Date-2020-04-15_Time-15-04-32.log ht1 + ht2 "],
["lymphoid-trajectory.html", "15.2 Lymphoid Trajectory", " 15.2 Lymphoid Trajectory p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1340853c58-Date-2020-04-15_Time-15-04-41.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1340853c58-Date-2020-04-15_Time-15-04-41.log p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1326401e05-Date-2020-04-15_Time-15-04-42.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1326401e05-Date-2020-04-15_Time-15-04-42.log ggAlignPlots(p1, p2, type = &quot;h&quot;) #Trajectory to add trajectory &lt;- c(&quot;Progenitor&quot;, &quot;CLP&quot;, &quot;PreB&quot;, &quot;B&quot;) trajectory ## [1] “Progenitor” “CLP” “PreB” “B” #First we need to create a Trajectory and add it to ArchRProj cellColData projHeme5 &lt;- addTrajectory( ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, groupBy = &quot;Clusters2&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE ) ## ArchR logging to : ArchRLogs/ArchR-addTrajectory-15e1351d16b68-Date-2020-04-15_Time-15-04-55.log ## If there is an issue, please report to github with logFile! ## Filtering outliers ## Initial Alignment Before Spline Fit ## Spline Fit ## KNN to Spline ## Aligning cells not in trajectory ## ArchR logging successful to : ArchRLogs/ArchR-addTrajectory-15e1351d16b68-Date-2020-04-15_Time-15-04-55.log head(projHeme5$LymphoidU[!is.na(projHeme5$LymphoidU)]) #NA means not in trajectory ## [1] 87.630792 81.913303 84.342302 81.763827 83.632287 4.073244 p &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;colData&quot;, name = &quot;LymphoidU&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e1377b52455-Date-2020-04-15_Time-15-04-56.log ## If there is an issue, please report to github with logFile! ## Plotting ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e1377b52455-Date-2020-04-15_Time-15-04-56.log p[[1]] ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p, name = &quot;Plot-LymphoidU-Traj-UMAP.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## [1] “plotting ggplot!” ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## [1] 0 We can overlay other features on the UMAP p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;horizonExtra&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e13576dc585-Date-2020-04-15_Time-15-05-20.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e13576dc585-Date-2020-04-15_Time-15-05-20.log p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;blueYellow&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e13ed9c20a-Date-2020-04-15_Time-15-05-27.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e13ed9c20a-Date-2020-04-15_Time-15-05-27.log ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ We can then make a heatmap for trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Some values are below 0, this could be a DeviationsMatrix in which scaleTo should be set = NULL. ## Continuing without depth normalization! ## Smoothing… p1 &lt;- trajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e133830d097-Date-2020-04-15_Time-15-06-14.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:06:15 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:06:15 : ## Removing rows with NA values… ## 2020-04-15 15:06:15 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e133830d097-Date-2020-04-15_Time-15-06-14.log trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p2 &lt;- trajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e13357a3282-Date-2020-04-15_Time-15-06-36.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e13357a3282-Date-2020-04-15_Time-15-06-36.log trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Smoothing… p3 &lt;- trajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131325dad9-Date-2020-04-15_Time-15-07-06.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131325dad9-Date-2020-04-15_Time-15-07-06.log trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p4 &lt;- trajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1351d7cd4d-Date-2020-04-15_Time-15-07-48.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1351d7cd4d-Date-2020-04-15_Time-15-07-48.log To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, p2, p3, p4, name = &quot;Plot-LymphoidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) ## [1] 0 We can also perform integrative analyses such as identifying positive regulators with RNA #Gene Scores corGSM_MM &lt;- correlateTrajectories(trajGSM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e133e72f66-Date-2020-04-15_Time-15-08-26.log ## If there is an issue, please report to github with logFile! ## Found 16 Correlated Pairings! ## 2020-04-15 15:08:47 : corGSM_MM[[1]]$matchname1 ## [1] “CREM” “NFE2” “FOXO1” “JDP2” “MAFG” “MAFG” “RFX2” “KLF2” ## [9] “CEBPA” “CEBPA” “FOSL2” “BCL11A” “GATA2” “IRF2” “IRF4” “PAX5” corGSM_MM[[1]] ## DataFrame with 16 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 2503 978 CREM CREM chr10:CREM z:CREM_108 ## 2 5181 989 NFE2 NFE2 chr12:NFE2 z:NFE2_119 ## 3 5958 1231 FOXO1 FOXO1 chr13:FOXO1 z:FOXO1_361 ## 4 6721 995 JDP2 JDP2 chr14:JDP2 z:JDP2_125 ## 5 10077 1018 MAFG MAFG chr17:MAFG z:MAFG_148 ## … … … … … … … ## 12 12398 1064 BCL11A BCL11A chr2:BCL11A z:BCL11A_194 ## 13 15802 1258 GATA2 GATA2 chr3:GATA2 z:GATA2_388 ## 14 17102 1504 IRF2 IRF2 chr4:IRF2 z:IRF2_634 ## 15 18161 1502 IRF4 IRF4 chr6:IRF4 z:IRF4_632 ## 16 21499 1579 PAX5 PAX5 chr9:PAX5 z:PAX5_709 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.592000045415225 0.812340554330436 0.875287356321839 7.27165360687288 ## 2 0.762361661991419 0.993427595451204 0.989655172413793 11.6618731859923 ## 3 0.658467426103544 0.855580057940935 0.879310344827586 8.66119456905554 ## 4 0.649844641802372 0.819518311929779 0.991954022988506 8.46390278863183 ## 5 0.502090536187102 0.886798979547715 0.935632183908046 5.74740534991767 ## … … … … … ## 12 0.609993999834133 0.867557400441043 0.968965517241379 7.62062915462215 ## 13 0.549172289236984 0.945561464954382 0.986781609195402 6.5052874492361 ## 14 0.643963832332729 0.828685086695205 0.970114942528736 8.33261518735298 ## 15 0.536406221175027 0.8282526916591 0.952873563218391 6.2919464214338 ## 16 0.803092200275283 0.978942361741687 0.962068965517241 13.3425248033796 ## Pval FDR ## ## 1 8.76476821331047e-11 4.6198810517901e-09 ## 2 3.15171893793416e-20 1.02998174891688e-17 ## 3 9.66043618744996e-14 1.43501388457211e-11 ## 4 2.57124018372512e-13 3.50117205017237e-11 ## 5 1.02530728526766e-07 2.83957983750399e-06 ## … … … ## 12 1.62079037573397e-11 1.10348811414554e-09 ## 13 3.29134663353072e-09 1.25071172074167e-07 ## 14 4.92446003514203e-13 6.18966745955545e-11 ## 15 8.81247545774464e-09 2.93869079550097e-07 ## 16 9.15917087670499e-24 3.74152130313399e-21 #We can plot these identified regulators trajGSM2 &lt;- trajGSM[corGSM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGSM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGSM2 assay(trajCombined) &lt;- t(apply(assay(trajGSM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e136c64f4ee-Date-2020-04-15_Time-15-08-47.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e136c64f4ee-Date-2020-04-15_Time-15-08-47.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGSM2)) ht1 &lt;- trajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1344a2d751-Date-2020-04-15_Time-15-08-47.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1344a2d751-Date-2020-04-15_Time-15-08-47.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1365304b53-Date-2020-04-15_Time-15-08-48.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:08:49 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:08:49 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1365304b53-Date-2020-04-15_Time-15-08-48.log ht1 + ht2 #Gene Expression corGIM_MM &lt;- correlateTrajectories(trajGIM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e134c10b516-Date-2020-04-15_Time-15-09-05.log ## If there is an issue, please report to github with logFile! ## Found 37 Correlated Pairings! ## 2020-04-15 15:09:20 : corGIM_MM[[1]]$matchname1 ## [1] “NFIA” “NFKB2” “IRF7” “ETS1” “NFE2” “STAT2” “FOXO1” ## [8] “IRF9” “FOS” “MEF2A” “IRF8” “MAFG” “TCF4” “TCF3” ## [15] “NFIC” “KLF2” “CEBPA” “POU2F2” “FOSB” “FOSL2” “REL” ## [22] “NFE2L2” “CREB1” “RUNX1” “ATF4” “SMARCC1” “FOXP1” “GATA2” ## [29] “HLTF” “REST” “LEF1” “IRF2” “MEF2C” “IRF1” “EBF1” ## [36] “TFEB” “PAX5” corGIM_MM[[1]] ## DataFrame with 37 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 680 1612 NFIA NFIA chr1:NFIA z:NFIA_742 ## 2 2428 1584 NFKB2 NFKB2 chr10:NFKB2 z:NFKB2_714 ## 3 2625 1505 IRF7 IRF7 chr11:IRF7 z:IRF7_635 ## 4 3790 1202 ETS1 ETS1 chr11:ETS1 z:ETS1_332 ## 5 4287 989 NFE2 NFE2 chr12:NFE2 z:NFE2_119 ## … … … … … … … ## 33 14165 1510 MEF2C MEF2C chr5:MEF2C z:MEF2C_640 ## 34 14287 1499 IRF1 IRF1 chr5:IRF1 z:IRF1_629 ## 35 14558 937 EBF1 EBF1 chr5:EBF1 z:EBF1_67 ## 36 15164 902 TFEB TFEB chr6:TFEB z:TFEB_32 ## 37 17354 1579 PAX5 PAX5 chr9:PAX5 z:PAX5_709 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.776554032919386 0.895435729261868 0.955747126436782 12.2013882485613 ## 2 0.842642341279197 0.893070265039514 0.88735632183908 15.4914421620131 ## 3 0.829368082571345 0.919144132035912 0.91551724137931 14.6953411117392 ## 4 0.85457028998599 0.947529702704156 0.901724137931034 16.2896821299438 ## 5 0.710070464598055 0.928874791677867 0.989655172413793 9.98300419241652 ## … … … … … ## 33 0.65886205886934 0.990860706413634 0.904597701149425 8.67036514488553 ## 34 0.852573236159675 0.977151766034084 0.981609195402299 16.1498641717228 ## 35 0.947958169110169 0.986344820170959 0.992528735632184 29.4737987999312 ## 36 0.71455800087286 0.934842212784259 0.842528735632184 10.1114979100535 ## 37 0.835610609654717 0.968066232998226 0.962068965517241 15.0587807907066 ## Pval FDR ## ## 1 2.24403341264388e-21 3.40224420626652e-20 ## 2 4.28486739529724e-28 1.38888805226876e-26 ## 3 1.61521163596779e-26 4.05409887519786e-25 ## 4 1.21844806414286e-29 5.72670590147145e-28 ## 5 1.31753444224449e-16 1.51034436062174e-15 ## … … … ## 33 9.23012667696911e-14 7.74671346102765e-13 ## 34 2.25997962853195e-29 9.23643848182623e-28 ## 35 1.65431752552523e-50 3.88764618498429e-48 ## 36 6.93337834458196e-17 8.04614277025561e-16 ## 37 3.05084830514743e-27 8.43469825540759e-26 #We can plot these identified regulators trajGIM2 &lt;- trajGIM[corGIM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGIM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGIM2 assay(trajCombined) &lt;- t(apply(assay(trajGIM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131cd6b30f-Date-2020-04-15_Time-15-09-21.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131cd6b30f-Date-2020-04-15_Time-15-09-21.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGIM2)) #Now we can plot the heatmaps ht1 &lt;- trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e137c439868-Date-2020-04-15_Time-15-09-21.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e137c439868-Date-2020-04-15_Time-15-09-21.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e13755647e8-Date-2020-04-15_Time-15-09-22.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:09:23 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:09:23 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e13755647e8-Date-2020-04-15_Time-15-09-22.log ht1 + ht2 "],
["session-information-14.html", "15.3 Session Information", " 15.3 Session Information Sys.Date() ## [1] “2020-04-15” sessionInfo() "]
]
