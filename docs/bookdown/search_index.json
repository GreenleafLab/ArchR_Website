[
["index.html", "ArchR: Robust and scaleable analysis of single-cell chromatin accessibility data. ", " ArchR: Robust and scaleable analysis of single-cell chromatin accessibility data. Jeffrey Granja and Ryan Corces 2020-04-21 ArchR is a full-featured software suite for the analysis of single-cell chromatin accessibility data. It is designed to handle hundreds of thousands of single cells without large memory or computational requirements, keeping pace with the experimental scale that is achievable with commercial platforms such as the 10x Genomics Chromium system. This website is a complete user’s guide to ArchR. We explain how to use ArchR by walking through examples of every analysis we could think of. We also include some more extensive documention on some of the more salient points of scATAC-seq analysis such as dimensionality reduction and clustering. All of the chapters will utilize the same downsampled dataset of hematopoietic cells Granja* et al. Nature Biotechnology 2019. Each chapter will build on the previous and we provide intermediate files for you to jump in at any point. Importantly, these tutorials assume that you are running ArchR locally. This walkthrough assumes that you have already successfully installed ArchR and all dependencies. If that is not the case, please visit the home page for installation instructions. Cant find what you are looking for? There is a search feature that can be enabled using the magnifying glass in the navigation bar above which will help you find whatever it is you are looking for. If you dont find it in this book, or if you think the documentation on this website or in the function annotations is unclear, please submit an issue on Github with the documentation tag and we will do our best to clarify. If none of these options help, send us an email and we will do our best to respond in a timely fashion. "],
["getting-started-with-archr.html", "Chapter 1 Getting Started with ArchR", " Chapter 1 Getting Started with ArchR This chapter will introduce you to how to import data into ArchR and how to create ArrowFiles, the base unit of ArchR analysis. "],
["a-brief-primer-on-atac-seq-terminology.html", "1.1 A Brief Primer on ATAC-seq Terminology", " 1.1 A Brief Primer on ATAC-seq Terminology The most fundamental component of any ATAC-seq experiment is a “fragment”. In ATAC-seq, a fragment refers to a sequenceable DNA molecule created by two transposition events. Each end of that fragment is sequenced using paired-end sequencing. The inferred single-base position of the start and end of the fragment is adjusted based on the insertion offset of Tn5. As reported previously, Tn5 transposase binds to DNA as a homodimer with 9-bp of DNA between the two Tn5 molecules. Because of this, each Tn5 homodimer binding event creates two insertions, separated by 9 bp. Thus, the actual central point of the “accessible” site is in the very center of the Tn5 dimer, not the location of each Tn5 insertion. To account for this, we apply an offset to the individual Tn5 insertions, adjusting plus-stranded insertion events by +4 bp and minus-stranded insertion events by -5 bp. This is consistent with the convention put forth during the original description of ATAC-seq. Thus, in ArchR, “fragments” refers to a table or genomic ranges object containing the chromosome, offset-adjusted single-base chromosome start position, offset-adjusted single-base chromosome end position, and unique cellular barcode ID corresponding to each sequenced fragment. Similarly, “insertions” refer to the offset-adjusted single-base position at the very center of an accessible site. "],
["why-use-archr.html", "1.2 Why use ArchR?", " 1.2 Why use ArchR? There are multiple tools for single-cell ATAC-seq analysis out there so why should you use ArchR? Most importantly, ArchR provides features and enables analyses that other tools do not: Additionally, ArchR is faster and uses less memory than other available tools due to heavy optimization of the data structures and parallelization methods that form the basis of the ArchR software. When analyzing more than 70,000 cells, some tools require high-performance computing environments, exceeding 128 GB of available memory (OoM = out of memory). ArchR is designed to be used on a Unix-based laptop. For experiments of moderate size (fewer than 100,000 cells), ArchR is fast enough to perform ad hoc analysis and visualize results in real time, making it possible to interact with the data in a more in-depth and biologically meaningful way. Of course, for higher cell numbers or for users that prefer server-based analysis, ArchR provides fascile export of plots and projects that can be downloaded and used after generation on a server. Currently, ArchR is not optimized to run on Windows. It should work but parallelization in ArchR has not been enabled for Windows so the performance gains mentioned above will not translate. "],
["what-is-an-arrow-file-archrproject.html", "1.3 What is an Arrow file / ArchRProject?", " 1.3 What is an Arrow file / ArchRProject? The base unit of an analytical project in ArchR is called an Arrow file. Each Arrow file stores all of the data associated with an individual sample (i.e. metadata, accessible fragments, and data matrices). Here, an “individual sample” would be the most detailed unit of analysis desired (for ex. a single replicate of a particular condition). During creation and as additional analyses are performed, ArchR updates and edits each Arrow file to contain additional layers of information. It is worth noting that, to ArchR, an Arrow file is actually just a path to an external file stored on disk. More explicitly, an Arrow file is not an R-language object that is stored in memory but rather an HDF5-format file stored on disk. Because of this, we use an ArchRProject object to associate these Arrow files together into a single analytical framework that can be rapidly accessed in R. This ArchRProject object is small in size and is stored in memory. Certain actions can be taken directly on Arrow files while other actions are taken on an ArchRProject which in turn updates each associated Arrow file. Because Arrow files are stored as large HDF5-format files, “get-er” functions in ArchR retrieve data by interacting with the ArchRProject while “add-er” functions either (i) add data directly to Arrow files, (ii) add data directly to an ArchRProject, or (iii) add data to Arrow files by interacting with an ArchRProject. "],
["input-file-types-in-archr.html", "1.4 Input File Types in ArchR", " 1.4 Input File Types in ArchR ArchR can utilize multiple input formats of scATAC-seq data which is most frequently in the format of fragment files and BAM files. Fragment files are tabix-sorted text files containing each scATAC-seq fragment and the corresponding cell ID, one fragment per line. BAM files are binarized tabix-sorted files that contain each scATAC-seq fragment, raw sequence, cellular barcode id and other information. The input format used will depend on the pre-processing pipeline used. For example, the 10x Genomics Cell Ranger software returns fragment files while sci-ATAC-seq applications would use BAM files. ArchR uses “scanTabix” to read fragment files and “scanBam” to read BAM files. During this input process, inputs are chunked and each input chunk is converted into a compressed table-based representation of fragments containing each fragment chromosome, offset-adjusted chromosome start position, offset-adjusted chromosome end position, and cellular barcode ID. These chunk-wise fragments are then stored in a temporary HDF5-formatted file to preserve memory usage while maintaining rapid access to each chunk. Finally, all chunks associated with each chromosome are read, organized, and re-written to an Arrow file within a single HDF5 group called “fragments”. This pre-chunking procedure enables ArchR to process extremely large input files efficiently and with low memory usage, enabling full utilization of parallel processing. "],
["getting-set-up.html", "1.5 Getting Set Up", " 1.5 Getting Set Up The first thing we do is change to our desired our working directory, set the number of threads we would like to use, and load our gene and genome annotations. Depending on the configuration of your local environment, you may need to modify the number of threads used below in addArchRThreads(). By default ArchR uses half of the total number of threads available but you can adjust this manually as you see fit. If you are using Windows, the usable threads will automatically be set to 1 because the parallel processing in ArchR is built for Unix-based operating systems. First, we load the ArchR library. If this fails, you have not properly installed ArchR and should revisit the installation instructions. library(ArchR) Next, we set the default number of threads for ArchR functions. We recommend setting threads to 1/2 to 3/4 of the total available cores. The memory usage in ArchR will often scale with the number of threads used so allowing ArchR to use more threads will also lead to higher memory usage. addArchRThreads(threads = 16) ## Setting default number of Parallel threads to 16. Then, we set the genome to be used for gene and genome annotations. Of course, this genome version must match the genome version that was used for alignment. For the data used in this tutorial, we will use the hg19 reference genome but ArchR natively supports additional genome annotations and custome genome annotations as outlined in the next section. addArchRGenome(&quot;hg19&quot;) ## Setting default genome to Hg19. ## Setting a Genome and GeneAnnotation ArchR requires gene and genome annotations to do things such as calculate TSS enrichment scores, nucleotide content, and gene activity scores. Because our tutorial dataset uses scATAC-seq data that has already been aligned to the hg19 reference genome, we have set “hg19” as the default genome in the previous section. However, ArchR supports “hg19”, “hg38”, “mm9”, and “mm10” natively and you can create your own genome and gene annotations using the createGeneAnnotation() and createGenomeAnnotation() functions. Providing this information to ArchR is streamlined through the addArchRGenome() function. This function tells ArchR that, for all analyses in the current session, it should use the genomeAnnotation and geneAnnotation associated with the defined ArchRGenome. Each of the natively supported genomes are composed of a BSgenome object that defines the genomic coordinates and sequence of each chromosome, a GRanges object containing a set of blacklisted regions, a TxDb object that defines the positions and structures of all genes, and an OrgDb object that provides a central gene identifier and contains mappings between this identifier and other kinds of identifiers. Below are examples of how to load gene and genome annotations for the natively supported genomes as well as information on their BSgenome and blacklist components. The precompiled version of the hg19 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg19, TxDb.Hsapiens.UCSC.hg19.knownGene, org.Hs.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the hg19 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg19 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg19 genome: addArchRGenome(&quot;hg19&quot;) ## Setting default genome to Hg19. The precompiled version of the hg38 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg38, TxDb.Hsapiens.UCSC.hg38.knownGene, org.Hs.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the hg38 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg38 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg38 genome: addArchRGenome(&quot;hg38&quot;) ## Setting default genome to Hg38. The precompiled version of the mm9 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm9, TxDb.Mmusculus.UCSC.mm9.knownGene, org.Mm.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the mm9 v1 blacklist regions from Anshul Kundaje and from mitochondrial regions that show high mappability to the mm9 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled mm9 genome: addArchRGenome(&quot;mm9&quot;) ## Setting default genome to Mm9. The precompiled version of the mm10 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm10, TxDb.Mmusculus.UCSC.mm10.knownGene, org.Mm.eg.db, and a blacklist that was merged using ArchR::mergeGR() from the mm10 v2 blacklist regions and from mitochondrial regions that show high mappability to the mm10 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled mm10 genome: addArchRGenome(&quot;mm10&quot;) ## Setting default genome to Mm10. 1.5.1 Creating a Custom ArchRGenome As described above, an ArchRGenome consists of a genome annotation and a gene annotation. To create a custom genome annotation, we use createGenomeAnnotation(). To do this, you will need the following information: A BSgenome object which contains the sequence information for a genome. These are commonly Bioconductor packages (for example, BSgenome.Hsapiens.UCSC.hg38) that can be easily found with google. A GRanges genomic ranges object containing a set of blacklisted regions that will be used to filter out unwanted regions from downstream analysis. This is not required but is recommended. For information on how blacklists are created, see the publication on the ENCODE blacklists. For example, if we wanted to create a custom genome annotation from Drosophila melanogaster, we would first identify and install and load the relevant BSgenome object. if (!requireNamespace(&quot;BSgenome.Dmelanogaster.UCSC.dm6&quot;, quietly = TRUE)){ BiocManager::install(&quot;BSgenome.Dmelanogaster.UCSC.dm6&quot;) } library(BSgenome.Dmelanogaster.UCSC.dm6) ## Loading required package: BSgenome ## Loading required package: Biostrings ## Loading required package: XVector ## Attaching package: ‘Biostrings’ ## The following object is masked from ‘package:base’: strsplit Then we create a genome annotation from this BSgenome object. genomeAnnotation &lt;- createGenomeAnnotation(genome = BSgenome.Dmelanogaster.UCSC.dm6) ## Getting genome.. ## Getting chromSizes.. ## Getting blacklist.. ## Blacklist not downloaded! Continuing without, be careful for downstream biases.. Examining this object shows the constituent parts of an ArchR genome annotation. genomeAnnotation ## List of length 3 ## names(3): genome chromSizes blacklist To create a custom gene annotation, we use createGeneAnnotation(). To do this, you will need the following information: A TxDb object (transcript database) from Bioconductor which contains information for gene/transcript coordinates. An OrgDb object (organism database) from Bioconductor which provides a unified framework to map between gene names and various gene identifiers. Continuing with out example from Drosophila melanogaster, we first install and load the relevant TxDb and OrgDb objects. if (!requireNamespace(&quot;TxDb.Dmelanogaster.UCSC.dm6.ensGene&quot;, quietly = TRUE)){ BiocManager::install(&quot;TxDb.Dmelanogaster.UCSC.dm6.ensGene&quot;) } if (!requireNamespace(&quot;org.Dm.eg.db&quot;, quietly = TRUE)){ BiocManager::install(&quot;org.Dm.eg.db&quot;) } library(TxDb.Dmelanogaster.UCSC.dm6.ensGene) ## Loading required package: GenomicFeatures ## Loading required package: AnnotationDbi library(org.Dm.eg.db) Then we create the gene annotation object. geneAnnotation &lt;- createGeneAnnnotation(TxDb = TxDb.Dmelanogaster.UCSC.dm6.ensGene, OrgDb = org.Dm.eg.db) ## Getting Genes.. ## Determined Annotation Style = ENSEMBL ## Getting Exons.. ## Getting TSS.. Examining this object shows the constituent parts of an ArchR gene annotation. geneAnnotation ## List of length 3 ## names(3): genes exons TSS Alternatively, if you dont have a TxDb and OrgDb object, you can create a geneAnnotation object from the following information : A “genes” object - a GRanges object containing gene coordinates (start to end). This object must have a symbols column matching the symbols column of the “exons” object described below. An “exons” object - GRanges object containing gene exon coordinates. Must have a symbols column matching the symbols column of the “genes” object described above. A GRanges object containing standed transcription start site (TSS) coordinates. geneAnnotation &lt;- createGeneAnnnotation( TSS = geneAnnotation$TSS, exons = geneAnnotation$exons, genes = geneAnnotation$genes ) "],
["creating-arrow-files.html", "1.6 Creating Arrow Files", " 1.6 Creating Arrow Files For the remainder of this tutorial, we will use data from a downsampled dataset of hematopoietic cells from Granja* et al. Nature Biotechnology 2019. This includes data from bone marrow mononuclear cells (BMMC), peripheral blood mononuclear cells (PBMC), and CD34+ hematopoietic stem and progenitor cells from bone marrow (CD34 BMMC). This data is downloaded as fragment files which contain the start and end genomic coordinates of all aligned sequenced fragments. Fragment files are one of the base file types of the 10x Genomics analytical platform (and other platforms) and can be easily created from any BAM file. See the 10x Genomics website for information on making your own fragment files for input to ArchR. Once we have our fragment files, we provide their paths as a character vector to createArrowFiles(). During creation, some basic metadata and matrices are added to each Arrow file including a “TileMatrix” containing insertion counts across genome-wide 500-bp bins (see addTileMatrix()) and a “GeneScoreMatrix” that stores predicted gene expression based on weighting insertion counts in tiles nearby a gene promoter (see addGeneScoreMatrix()). The tutorial data can be downloaded using the getTutorialData() function. The tutorial data is approximately 0.5 GB in size. If you have already downloaded the tutorial in the current working directory, ArchR will bypass downloading. library(ArchR) inputFiles &lt;- getTutorialData(&quot;Hematopoiesis&quot;) inputFiles ## scATAC_BMMC_R1 ## “HemeFragments/scATAC_BMMC_R1.fragments.tsv.gz” ## scATAC_CD34_BMMC_R1 ## “HemeFragments/scATAC_CD34_BMMC_R1.fragments.tsv.gz” ## scATAC_PBMC_R1 ## “HemeFragments/scATAC_PBMC_R1.fragments.tsv.gz” As always, before starting a project we must set the ArchRGenome and default threads for parallelization. addArchRGenome(&quot;hg19&quot;) ## Setting default genome to Hg19. addArchRThreads(threads = 16) ## Setting default number of Parallel threads to 16. Now we will create our Arrow Files which will take 10-15 minutes. For each sample, this step will: Read accessible fragments from the provided input files. Calculate quality control information for each cell (i.e. TSS enrichment scores and nucleosome info). Filter cells based on quality control parameters. Create a genome-wide TileMatrix using 500-bp bins. Create a GeneScoreMatrix using the custom geneAnnotation that was defined when we called addArchRGenome(). ArrowFiles &lt;- createArrowFiles( inputFiles = inputFiles, sampleNames = names(inputFiles), filterTSS = 4, #Dont set this too high because you can always increase later filterFrags = 1000, addTileMat = TRUE, addGeneScoreMat = TRUE ) ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## ArchR logging to : ArchRLogs/ArchR-createArrows-dfa159ddbf6e-Date-2020-04-15_Time-09-21-27.log ## If there is an issue, please report to github with logFile! ## Cleaning Temporary Files ## 2020-04-15 09:21:28 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-createArrows-dfa159ddbf6e-Date-2020-04-15_Time-09-21-27.log We can inspect the ArrowFiles object to see that it is actually just a character vector of Arrow file paths. ArrowFiles ## “scATAC_BMMC_R1.arrow” “scATAC_CD34_BMMC_R1.arrow” ## “scATAC_PBMC_R1.arrow” "],
["per-cell-quality-control.html", "1.7 Per-cell Quality Control", " 1.7 Per-cell Quality Control Strict quality control (QC) of scATAC-seq data is essential to remove the contribution of low-quality cells. In ArchR, we consider three characteristics of data: The number of unique nuclear fragments (i.e. not mapping to mitochondrial DNA). The signal-to-background ratio. Low signal-to-background ratio is often attributed to dead or dying cells which have de-chromatinzed DNA which allows for random transposition genome-wide. The fragment size distribution. Due to nucleosomal periodicity, we expect to see depletion of fragments that are the length of DNA wrapped around a nucleosome (approximately 147 bp). The first metric, unique nuclear fragments, is straightforward - cells with very few usable fragments will not provide enough data to make useful interpretations and should therefore be excluded. The second metric, signal-to-background ratio, is calculated as the TSS enrichment score. Traditional bulk ATAC-seq analysis has used this TSS enrichment score as part of a standard workflow for determination of signal-to-background (for example, the ENCODE project). We and others have found the TSS enrichment to be representative across the majority of cell types tested in both bulk ATAC-seq and scATAC-seq. The idea behind the TSS enrichment score metric is that ATAC-seq data is universally enriched at gene TSS regions compared to other genomic regions, due to large protein complexes that bind to promoters. By looking at per-basepair accessibility centered at these TSS regions, we see a local enrichment relative to flanking regions (1900-2000 bp distal in both directions). The ratio between the peak of this enrichment (centered at the TSS) relative to these flanking regions represents the TSS enrichment score. Traditionally, the per-base-pair accessibility is computed for each bulk ATAC-seq sample and then this profile is used to determine the TSS enrichment score. Performing this operation on a per-cell basis in scATAC-seq is relatively slow and computationally expensive. To accurately approximate the TSS enrichment score per single cell, we count the average accessibility within a 50-bp region centered at each single-base TSS position and divide this by the average accessibility of the TSS flanking positions (+/- 1900 – 2000 bp). This approximation was highly correlated (R &gt; 0.99) with the original method and values were extremely close in magnitude. The third metric, fragment size distribution, is generally less important but always good to manually inspect. Because of the patterned way that DNA wraps around nucleosomes, we expect to see a nucleosomal periodicity in the distribution of fragment sizes in our data. These hills and valleys appear because fragments must span 0, 1, 2, etc. nucleosomes (Tn5 cannot cut DNA that is tightly wrapped around a nucleosome. By default in ArchR, pass-filter cells are identified as those cells having a TSS enrichment score greater than 4 and more than 1000 unique nuclear fragments. It is important to note that the actual numeric value of the TSS enrichment score depends on the set of TSSs used. The default values in ArchR were designed for human data and it may be important to change the default thresholds when running createArrowFiles(). Creation of Arrow files will create a folder in the current working directory called “QualityControl” which will contain 2 plots associated with each of your samples. The first plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines. The second shows the fragment size distribution. For our tutorial data, we have three samples as shown below: For BMMC: For CD34 BMMC: For PBMC: We are now ready to tidy up these Arrow files and then create an ArchRProject. "],
["doublet-inference-with-archr.html", "Chapter 2 Doublet Inference with ArchR", " Chapter 2 Doublet Inference with ArchR One major source of trouble in single-cell data is the contribution of “doublets” to the analysis. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell that is effectively the average of the two cells. We remove these computationally and describe this doublet removal process in depth in this chapter. "],
["how-does-doublet-identification-work-in-archr.html", "2.1 How does doublet identification work in ArchR?", " 2.1 How does doublet identification work in ArchR? Single-cell data generated on essentially any platform is susceptible to the presence of doublets. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell. For 10x, the percentage of total “cells” that are actually doublets is proportional to the number of cells loaded into the reaction. Even at the lower levels of doublets that result from standard kit use, more than 5% of the data may come from doublets and this exerts substantial effects on clustering. This issue becomes particularly problematic in the context of developmental/trajectory data because doublets look like a mixture between two cell types and this can be confounded with intermediate cell types or cell states. To predict which “cells” are actually doublets, we synthesize in silico doublets from the data by mixing the reads from thousands of combinations of individual cells. We then project these synthetic doublets into the UMAP embedding and identify their nearest neighbor. By iterating this procedure thousands of times, we can identify “cells” in our data whose signal looks very similar to synthetic doublets. To develop and validate ArchR’s doublet identification, we generated scATAC-seq data from pooled mixtures of 10 genetically distinct cell lines. In scATAC-seq space, these 10 cell lines should form 10 distinct clusters but when we deliberately overload the 10x Genomics scATAC-seq reaction, targetting 25,000 cells per reaction, we end up with many doublets. We know these are doublets because we use demuxlet to identify droplets that contain genotypes from two different cell types. This “ground truth” overlaps very strongly with the doublet predictions shown above, showing an area under the curve of the receiver opperating characteristic &gt;0.90. After we computationally remove these doublets with ArchR, the overall structure of our data changes dramatically and matches our expectation of 10 distinct cell types. "],
["inferring-scatac-seq-doublets-with-archr.html", "2.2 Inferring scATAC-seq Doublets with ArchR", " 2.2 Inferring scATAC-seq Doublets with ArchR By default ArchR uses the doublet parameters described in the ArchR manuscript. This is likely a good place to start but we encourage all users to inspect the pre- and post-doublet removal data to understand how doublet removal is affecting the cells. We show some of the main adjustable features below to illustrate how this can be customized to a given application. In ArchR, doublet removal is performed in a single step using addDoubletScores(). This adds the infered doublet scores to each Arrow file and will take approximately 2-5 minutes per sample of the tutorial data. You can always try ?addDoubletScores to see further documentation on parameters for doublet identification (or any ArchR function for that matter). doubScores &lt;- addDoubletScores( input = ArrowFiles, k = 10, #Refers to how many cells near a &quot;pseudo-doublet&quot; to count. knnMethod = &quot;UMAP&quot;, #Refers to the embedding to use for nearest neighbor search with doublet projection. LSIMethod = 1 ) ## ArchR logging to : ArchRLogs/ArchR-addDoubletScores-e60f2395c3f7-Date-2020-04-15_Time-09-28-44.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 09:28:44 : Batch Execution w/ safelapply!, 0 mins elapsed. ## 2020-04-15 09:28:44 : scATAC_BMMC_R1 (1 of 3) : Computing Doublet Statistics, 0.001 mins elapsed. ## scATAC_BMMC_R1 (1 of 3) : UMAP Projection R^2 = 0.9736 ## scATAC_BMMC_R1 (1 of 3) : UMAP Projection R^2 = 0.9736 ## 2020-04-15 09:31:15 : scATAC_CD34_BMMC_R1 (2 of 3) : Computing Doublet Statistics, 2.511 mins elapsed. ## scATAC_CD34_BMMC_R1 (2 of 3) : UMAP Projection R^2 = 0.99046 ## scATAC_CD34_BMMC_R1 (2 of 3) : UMAP Projection R^2 = 0.99046 ## 2020-04-15 09:32:40 : scATAC_PBMC_R1 (3 of 3) : Computing Doublet Statistics, 3.936 mins elapsed. ## scATAC_PBMC_R1 (3 of 3) : UMAP Projection R^2 = 0.97507 ## scATAC_PBMC_R1 (3 of 3) : UMAP Projection R^2 = 0.97507 ## ArchR logging successful to : ArchRLogs/ArchR-addDoubletScores-e60f2395c3f7-Date-2020-04-15_Time-09-28-44.log Adding doublet scores will create plots in the “QualityControl” directory. There are 3 plots associated with each of your samples in this folder: Doublet Enrichments - These represent the enrichment of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. Doublet Scores - These represent the significance (-log10(binomial adjusted p-value)) of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. We have found this value to be less consistent than the doublet enrichments and therefore use doublet enrichments for doublet identification. Doublet Density - This represents the density of the simulated doublet projections. This allows you to visualize where the synthetic doublets were located after projection into your 2-dimensional embedding. For BMMC : For CD34 BMMC : For PBMC : "],
["creating-an-archrproject.html", "Chapter 3 Creating an ArchRProject", " Chapter 3 Creating an ArchRProject An ArchRProject allows us to group multiple Arrow files together into a single project. This ArchRProject is small and is stored in memory. By interacting with the ArchRProject we can rapidly push and pull data from the Arrow files. As such, it forms the basis of nearly all ArchR functions and analytical workflows. Moreover, ArchRProject objects can be saved and re-loaded at a later date, providing continuity of analyses and facilitating sharing of analytical projects across collaborators. This chapter describes how to create and interact with an ArchRProject object. "],
["creating-an-archrproject-1.html", "3.1 Creating An ArchRProject", " 3.1 Creating An ArchRProject First, we must create our ArchRProject by providing a list of Arrow files and a few other parameters. The outputDirectory here describes where all downstream analyses and plots will be saved. ArchR will automatically associate the previously provided geneAnnotation and genomeAnnotation with the new ArchRProject. These were stored when we ran addArchRGenome(\"hg19\") in a previous chapter. projHeme1 &lt;- ArchRProject( ArrowFiles = ArrowFiles, outputDirectory = &quot;HemeTutorial&quot;, copyArrows = TRUE #This is recommened so that if you modify the Arrow files you have an original copy for later usage. ) ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## Using GeneAnnotation set by addArchRGenome(Hg19)! ## Validating Arrows… ## Getting SampleNames… ## ## Copying ArrowFiles to Ouptut Directory! If you want to save disk space set copyArrows = FALSE ## 1 2 3 ## Getting Cell Metadata… ## ## Merging Cell Metadata… ## Initializing ArchRProject… We call this ArchRProject “projHeme1” because it is the first iteration of our hematopoiesis project. Throughout this walkthrough we will modify and update this ArchRProject and keep track of which version of the project we are using by iterating the project number (i.e. “projHeme2”). We can examine the contents of our ArchRProject: projHeme1 ## class: ArchRProject ## outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(11): Sample TSSEnrichment … DoubletScore ## DoubletEnrichment ## numberOfCells(1): 10661 ## medianTSS(1): 16.832 ## medianFrags(1): 3050 We can see from the above that our ArchRProject has been initialized with a few important attributes: The specified outputDirectory. The sampleNames of each sample which were obtained from the Arrow files. A matrix called sampleColData which contains data associated with each sample. A matrix called cellColData which contains data associated with each cell. Because we already computed doublet enrichment scores using addDoubletScores(), which added those values to each cell in the Arrow files, we can see columns corresponding to the “DoubletEnrichment” and “DoubletScore” in the cellColData matrix. The total number of cells in our project which represents all samples after doublet identification and removal. The median TSS enrichment score and the median number of fragments across all cells and all samples. We can check how much memory is used to store the ArchRProject in memory within R: paste0(&quot;Memory Size = &quot;, round(object.size(projHeme1) / 10^6, 3), &quot; MB&quot;) ## [1] “Memory Size = 37.135 MB” We can also ask which data matrices are available within the ArchRProject which will be useful downstream once we start adding to this project: getAvailableMatrices(projHeme1) ## [1] “GeneScoreMatrix” “TileMatrix” "],
["manipulating-an-archrproject.html", "3.2 Manipulating An ArchRProject", " 3.2 Manipulating An ArchRProject Now that we have created an ArchRProject, there are many things that we can do to easily access or manipulate the associated data. Example 1. The $ accessor allows direct access to cellColData We can access the cell names associated with each cell: head(projHeme1$cellNames) ## [1] “scATAC_BMMC_R1#TTATGTCAGTGATTAG-1” “scATAC_BMMC_R1#AAGATAGTCACCGCGA-1” ## [3] “scATAC_BMMC_R1#GCATTGAAGATTCCGT-1” “scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1” ## [5] “scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1” “scATAC_BMMC_R1#AGTTACGAGAACGTCG-1” We can access the sample names associated with each cell: head(projHeme1$Sample) ## [1] “scATAC_BMMC_R1” “scATAC_BMMC_R1” “scATAC_BMMC_R1” “scATAC_BMMC_R1” ## [5] “scATAC_BMMC_R1” “scATAC_BMMC_R1” We can access the TSS Enrichment Scores for each cell: quantile(projHeme1$TSSEnrichment) ## 0% 25% 50% 75% 100% ## 4.027 13.922 16.832 19.937 41.782 Example 2. Subsetting an ArchRProject by cells There are many ways that we can subset an ArchRProject to obtain only a select set of cells. We can subset the project numerically, for example taking the first 100 cells in the project: projHeme1[1:100, ] ## class: ArchRProject ## outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(11): Sample TSSEnrichment … DoubletScore ## DoubletEnrichment ## numberOfCells(1): 100 ## medianTSS(1): 10.7725 ## medianFrags(1): 10200.5 We can subset the project based on certain cell names: projHeme1[projHeme1$cellNames[1:100], ] ## class: ArchRProject ## outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(11): Sample TSSEnrichment … DoubletScore ## DoubletEnrichment ## numberOfCells(1): 100 ## medianTSS(1): 10.7725 ## medianFrags(1): 10200.5 We can subset the project to keep all cells corresponding to a specific sample: idxSample &lt;- BiocGenerics::which(projHeme1$Sample %in% &quot;scATAC_BMMC_R1&quot;) cellsSample &lt;- projHeme1$cellNames[idxSample] projHeme1[cellsSample, ] ## class: ArchRProject ## outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(11): Sample TSSEnrichment … DoubletScore ## DoubletEnrichment ## numberOfCells(1): 4932 ## medianTSS(1): 15.254 ## medianFrags(1): 2771 We can subset the project to only keep cells that meet a specific cutoff for the TSS enrichment score: idxPass &lt;- which(projHeme1$TSSEnrichment &gt;= 8) cellsPass &lt;- projHeme1$cellNames[idxPass] projHeme1[cellsPass, ] ## class: ArchRProject ## outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(11): Sample TSSEnrichment … DoubletScore ## DoubletEnrichment ## numberOfCells(1): 10500 ## medianTSS(1): 16.9275 ## medianFrags(1): 3042 Example 3. Adding data to an ArchRProject We can add columns to cellColData to store any type of cell-specific metadata relevant to our project. For example, we can add a column to cellColData that contains more legible sample names by removing excess info from the original sample names: bioNames &lt;- gsub(&quot;_R2|_R1|scATAC_&quot;,&quot;&quot;,projHeme1$Sample) head(bioNames) ## [1] “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” ## [7] “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” “BMMC” We can also add a column to cellColData that only contains information for a subset of cells. projHeme1$bioNames &lt;- bioNames bioNames &lt;- bioNames[1:10] cellNames &lt;- projHeme1$cellNames[1:10] projHeme1 &lt;- addCellColData(ArchRProj = projHeme1, data = paste0(bioNames), cells = cellNames, name = &quot;bioNames2&quot;) By default, ArchR will fill in missing entries with NA. Because of this, when we can compare these two columns, we see NA filled in where data wasnt available for bioNames2: getCellColData(projHeme1, select = c(&quot;bioNames&quot;, &quot;bioNames2&quot;)) ## DataFrame with 10661 rows and 2 columns ## bioNames bioNames2 ## ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 BMMC BMMC ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 BMMC BMMC ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 BMMC BMMC ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 BMMC BMMC ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 BMMC BMMC ## … … … ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 PBMC NA ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 PBMC NA ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 PBMC NA ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 PBMC NA ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 PBMC NA Example 4. Obtaining columns from cellColData ArchR provides the getCellColData() function to enable easy retreival of metadata columns from an ArchRProject. For example, we can retrieve a column by name, such as the number of unique nuclear (i.e. non-mitochondrial) fragments per cell: df &lt;- getCellColData(projHeme1, select = &quot;nFrags&quot;) df ## DataFrame with 10661 rows and 1 column ## nFrags ## ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 26189 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 20648 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 18991 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 18296 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 17458 ## … … ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 1038 ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 1037 ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 1033 ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 1033 ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 1002 Instead of selecting a column by name, we can actually perform operations on a given column using its column name: df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;nFrags - 1&quot;)) df ## DataFrame with 10661 rows and 2 columns ## log10(nFrags) nFrags - 1 ## ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 26188 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 20647 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 18990 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 18295 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 17457 ## … … … ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 1037 ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 1036 ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 1032 ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 1032 ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 1001 Example 5. Plotting QC metrics - log10(Unique Fragments) vs TSS enrichment score Repeating the example shown above, we can easily obtain standard scATAC-seq metrics for quality control of individual cells. We have found that the most robust metrics for quality control are the TSS enrichment score (a measure of signal-to-background in ATAC-seq data) and the number of unique nuclear fragments (because cells with very few fragments do not have enough data to confidently analyze). df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;TSSEnrichment&quot;)) df ## DataFrame with 10661 rows and 2 columns ## log10(nFrags) TSSEnrichment ## ## scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 7.149 ## scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 7.911 ## scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 4.505 ## scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 6.946 ## scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 4.799 ## … … … ## scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 24.356 ## scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 22.537 ## scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 20.146 ## scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 30.198 ## scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 21.485 Now lets plot the number of unique nuclear fragments (log10) by the TSS enrichment score. This type of plot is key for identifying high quality cells. You’ll notice that the cutoffs that we previously specified when creating the Arrow files (via filterTSS and filterFrags) have already removed low quality cells. However, if we noticed that the previously applied QC filters were not adequate for this sample, we could further adjust our cutoffs based on this plot or re-generate the Arrow files if needed. p &lt;- ggPoint( x = df[,1], y = df[,2], colorDensity = TRUE, continuousSet = &quot;sambaNight&quot;, xlabel = &quot;Log10 Unique Fragments&quot;, ylabel = &quot;TSS Enrichment&quot;, xlim = c(log10(500), quantile(df[,1], probs = 0.99)), ylim = c(0, quantile(df[,2], probs = 0.99)) ) + geom_hline(yintercept = 4, lty = &quot;dashed&quot;) + geom_vline(xintercept = 3, lty = &quot;dashed&quot;) p To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p, name = &quot;TSS-vs-Frags.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE) ## [1] “plotting ggplot!” ## [1] 0 Download PDF : TSS-vs-Frags.pdf "],
["plotting-sample-statistics-from-an-archrproject.html", "3.3 Plotting Sample Statistics from an ArchRProject", " 3.3 Plotting Sample Statistics from an ArchRProject When working with multiple distinct samples in a single integrated data set, it can be important to compare various metrics across all samples. ArchR provides two main plotting mechanisms for grouped data: ridge plots and violin plots. These are both accessed through the plotGroups() function. Of course, this plot type is not limited to sample-level data and can be used for plotting of downstream group-level information for groups such as clusters. Example 1. Make a ridge plot for each sample for the TSS enrichment scores. To make a ridge plot, we set plotAs = \"ridges\". p1 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;ridges&quot; ) ## 1 p1 ## Picking joint bandwidth of 0.882 Example 2. Make a violin plot for each sample for the TSS enrichment scores. To make a violin plot, we set plotAs = \"violin\". Violin plots in ArchR come with a box-and-whiskers plot in the style of Tukey as implemented by ggplot2. This means that the lower and upper hinges correspond to the 25th and 75th percentiles, respectively, and the middle corresponds to the median. The lower and upper whiskers extend from the hinge to the lowest or highest value or 1.5 times the interquartile range (the distance between the 25th and 75th percentiles). p2 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) ## 1 p2 Example 3. Make a ridge plot for each sample for the log10(unique nuclear fragments). p3 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;ridges&quot; ) ## 1 p3 ## Picking joint bandwidth of 0.05 Example 4. Make a violin plot for each sample for the log10(unique nuclear fragments). p4 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) ## 1 p4 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;QC-Sample-Statistics.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 4, height = 4) ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.882 ## Picking joint bandwidth of 0.882 ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.05 ## Picking joint bandwidth of 0.05 ## [1] “plotting ggplot!” ## [1] 0 Download PDF : QC-Sample-Statistics.pdf "],
["plotting-sample-fragment-size-distribution-and-tss-enrichment-profiles-.html", "3.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles.", " 3.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles. Because of how the data is stored and accessed, ArchR can compute fragment size distributions and TSS enrichment profiles from Arrow files very quickly. Fragment size distributions To plot the fragment size distributions of all samples, we use the plotFragmentSizes() function. Fragment size distributions in ATAC-seq can be quite variable across samples, cell types, and batches. Slight differences like those shown below are common and do not necessarily correlate with differences in data quality. p1 &lt;- plotFragmentSizes(ArchRProj = projHeme1) p1 TSS enrichment profiles To plot TSS enrichment profiles, we use the plotTSSEnrichment() function. TSS enrichment profiles should show a clear peak in the center and a smaller shoulder peak right-of-center which is caused by the well-positioned +1 nucleosome. p2 &lt;- plotTSSEnrichment(ArchRProj = projHeme1) p2 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2, name = &quot;QC-Sample-FragSizes-TSSProfile.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : QC-Sample-FragSizes-TSSProfile.pdf "],
["saving-and-loading-an-archrproject.html", "3.5 Saving and Loading an ArchRProject", " 3.5 Saving and Loading an ArchRProject ArchR provides a facile way to save an ArchRProject object to either re-load at a later time or share with other users. Fundamentally, an ArchRProject points to a set of Arrow files. Because of this, the process of saving an ArchRProject using the saveArchRProject() function will: Copy the current Arrow files to the designated outputDirectory so that they are exclusively associated with the new ArchRProject object. Save a copy of the designated ArchRProject in the outputDirectory. For example, we can save our projHeme1 using saveArchRProject() which will allow us to use this project in future chapters. saveArchRProject(ArchRProj = projHeme1, outputDirectory = &quot;Save-ProjHeme1&quot;, load = FALSE) ## Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme1 ## Copying Arrow Files… ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## No imputeWeights found, returning NULL ## Copying Other Files… ## Copying Other Files (1 of 1): Plots ## Saving ArchRProject… This will copy the Arrow files and save a .RDS file of the projHeme1 ArchRProject object in the specified outputDirectory. Very important! This process does NOT automatically update the ArchRProject object that is active in your current R session. Specifically, the object named projHeme1 in the current R session will still point to the original location of the Arrow files, not the copied Arrow files that reside in the specified outputDirectory. If we wanted to do this, we would specify load = TRUE which causes the saveArchRProject() function to return the saved ArchRProject object which you can assign to overwrite the original ArchRProject object using &lt;-. This effectively saves and loads the ArchRProject from its new location. "],
["filtering-doublets-from-an-archrproject.html", "3.6 Filtering Doublets from an ArchRProject", " 3.6 Filtering Doublets from an ArchRProject After we have added information on the predicted doublets using addDoubletScores(), we can remove these predicted doublets using filterDoublets(). One of the key elements of this filtering step is the filterRatio which is the maximum ratio of predicted doublets to filter based on the number of pass-filter cells. For example, if there are 5000 cells, the maximum number of filtered predicted doublets would be filterRatio * 5000^2 / (100000) (which simplifies to filterRatio * 5000 * 0.05). This filterRatio allows you to apply a consistent filter across multiple different samples that may have different percentages of doublets because they were run with different cell loading concentrations. The higher the filterRatio, the greater the number of cells potentially removed as doublets. First, we filter the doublets. We save this as a new ArchRProject for the purposes of this stepwise tutorial but you can always overwrite your original ArchRProject object. projHeme2 &lt;- filterDoublets(projHeme1) ## Filtering 410 cells from ArchRProject! ## scATAC_BMMC_R1 : 243 of 4932 (4.9%) ## scATAC_CD34_BMMC_R1 : 107 of 3275 (3.3%) ## scATAC_PBMC_R1 : 60 of 2454 (2.4%) Previously, we saw that projHeme1 had 10,661 cells. Now, we see that projHeme2 has 10,251 cells, indicating that 410 cells (3.85%) were removed by doublet filtration as indicated above. projHeme2 ## class: ArchRProject ## outputDirectory: /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/HemeTutorial ## samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## sampleColData names(1): ArrowFiles ## cellColData names(13): Sample TSSEnrichment … bioNames bioNames2 ## numberOfCells(1): 10251 ## medianTSS(1): 16.856 ## medianFrags(1): 2991 If you wanted to filter more cells from the ArchR Project, you would use a higher filterRatio. To see additional arguments that can be tweaked, try ?filterDoublets. projHemeTmp &lt;- filterDoublets(projHeme1, filterRatio = 1.5) ## Filtering 614 cells from ArchRProject! ## scATAC_BMMC_R1 : 364 of 4932 (7.4%) ## scATAC_CD34_BMMC_R1 : 160 of 3275 (4.9%) ## scATAC_PBMC_R1 : 90 of 2454 (3.7%) Since projHemeTmp was only created for illustrative purposes, we remove it from our R session. rm(projHemeTmp) "],
["dimensionality-reduction-with-archr.html", "Chapter 4 Dimensionality Reduction with ArchR", " Chapter 4 Dimensionality Reduction with ArchR Dimensionality reduction with scATAC-seq is challenging due to the sparsity of the data. In scATAC-seq, a particular site can either be accessible on one allele, both alleles, or no alleles. Even in higher-quality scATAC-seq data, the majority of accesible regions are not transposed and this leads to many loci having 0 accessibile alleles. Moreover, when we see (for example) three Tn5 insertions within a single peak region in a single cell, the sparsity of the data prevents us from confidently determining that this site in this cell is actually three times more accessible than another cell that only has one insertion in the same site. For this reason a lot of analytical strategies work on a binarized scATAC-seq data matrix. This binarized matrix still ends up being mostly 0s because transposition is rare. However, it is important to note that a 0 in scATAC-seq could mean “non-accessible” or “not sampled” and these two inferences are very different from a biological standpoint. Because of this, the 1s have information and the 0s do not. This low information content is what makes our scATAC-seq data sparse. If you were to perform a standard dimensionality reduction, like Principal Component Analysis, on this sparse insertion counts matrix and plot the top two principal components, you would not obtain the desired result because the sparsity causes high inter-cell similarity at all of the 0 positions. To get around this issue, we use a layered dimensionality reduction approach. First, we use Latent Semantic Indexing (LSI), an approach from natural language processing that was originally designed to assess document similarity based on word counts. This solution was created for natural language processing because the data is sparse and noisy (many different words and many low frequency words). LSI was first introduced for scATAC-seq by Cusanovich et al. (Science 2015). In the case of scATAC-seq, different samples are the documents and different regions/peaks are the words. First, we calculate the term frequency by depth normalization per single cell. These values are then normalized by the inverse document frequency which weights features by how often they occur to identify featres that are more “specific” rather than commonly accessible. The resultant term frequency-inverse document frequency (TF-IDF) matrix reflects how important a word (aka region/peak) is to a document (aka sample). Then, through a technique called singular value decomposition (SVD), the most valuable information across samples is identified and represented in a lower dimensional space. LSI allows you to reduce the dimensionality of the sparse insertion counts matrix from many thousands to tens or hundreds. Then, a more conventional dimensionality reduction technique, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE) can be used to visualize the data. In ArchR, these visualization methods are referred to as embeddings. "],
["archrs-lsi-implementation.html", "4.1 ArchR’s LSI Implementation", " 4.1 ArchR’s LSI Implementation ArchR implements a few different LSI implementations and we have benchmarked many of these methods across multiple different test data sets. ArchR’s default LSI implementation is related to the method introduced by Timothy Stuart in Signac, which uses a term frequency that has been depth normalized to a constant (10,000) followed by normalization with the inverse document frequency and then log-transforming the resultant matrix (aka log(TF-IDF)). One of the key inputs to LSI dimensionality reduction is the starting matrix. Thus far, the two main strategies in scATAC-seq have been to (1) use peak regions or (2) genome-wide tiles. However, using peak regions for LSI is inherently challenging because we do not have clusters or cluster-specific peaks prior to dimensionality reduction. Moreover, calling peaks on aggregated cells prior to clustering obscures cell type-specific peaks. Moreover, any union peak set will change when new samples are added to an experiment, making this strategy less stable. The second strategy, using genome-wide tiles, mitigates these issues by using a consistent and unbiased feature set (genome-wide tiles). However, a genome-wide tile matrix of all cells by all regions can become prohibitively large. For this reason, most implementations use tiles that are greater than or equal to 5 kilobases in size. This drastically reduces the resolution of the approach because most accessible regions are only a few hundred basepairs long. Because of the way that Arrow files are designed, ArchR is able to perform LSI very rapidly using genome-wide 500-bp tiles. This solves the problem of resolution and allows for the identification of clusters prior to calling peaks. The challenge is that 500-bp bins generate around 6 million features to be included in the cell by tile matrix. While ArchR is able to read this large amount of data into R by chunking the relevant matrices, we have also implemented an “estimated LSI” approach that performs the initial dimensionality reduction on a subset of the total cells. This estimated LSI approach has two main utilities - (i) it speeds up dimensionality reduction and (ii) as you decrease the number of cells used in the intial dimensionality reduction, this decreases the granularity of the data. This reduction in granularity can be used to your advantage to reduce batch effects in your data. However, it can also obscure true biology so estimated LSI approaches should be used under close manual supervision. "],
["iterative-latent-semantic-indexing-lsi.html", "4.2 Iterative Latent Semantic Indexing (LSI)", " 4.2 Iterative Latent Semantic Indexing (LSI) In scRNA-seq identifying variable genes is a common way to compute dimensionality reduction (such as PCA). This is done because these highly variable genes are more likely to be biologically important and this reduces experimental noise. In scATAC-seq the data is binary and thus you cannot identify variable peaks for dimensionality reduction. Rather than identifying the most variable peaks, we have tried using the most accessible features as input to LSI; however, the results when running multiple samples have shown high degrees of noise and low reproducibility. To remedy this we introduced the “iterative LSI” approach (Satpathy*, Granja* et al. Nature Biotechnology 2019 and Granja*, Klemm* and McGinnis* et al. Nature Biotechnology 2019). This approach computes an inital LSI transformation on the most accessible tiles and identifies lower resolution clusters that are not batch confounded. For example, when performed on peripheral blood mononuclear cells, this will identify clusters corresponding to the major cell types (T cells, B cells, and monocytes). Then ArchR computes the average accessibility for each of these clusters across all features. ArchR then identifies the most variable peaks across these clusters and uses these features for LSI again. In this second iteration, the most variable peaks are more similar to the variable genes used in scRNA-seq LSI implementations. The user can set how many iterations of LSI should be performed. We have found this approach to minimize observed batch effects and allow dimensionality reduction operations on a more reasonably sized feature matrix. To perform iterative LSI in ArchR, we use the addIterativeLSI() function. The default parameters should cover most cases but we encourage you to explore the available parameters and how they each affect your particular data set. See ?addIterativeLSI for more details on inputs. The most common parameters to tweak are iterations, varFeatures, and resolution. It is important to note that LSI is not deterministic. This means that even if you run LSI in exactly the same way with exactly the same parameters, you will not get exactly the same results. Of course, they will be highly similar, but not identical. So make sure to save your ArchRProject or the relevant LSI information once you’ve settled on an ideal dimensionality reduction. For the purposes of this tutorial, we will create a reducedDims object called “IterativeLSI”. projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( #See Seurat::FindClusters resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) ## Checking Inputs… ## ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-ea2d75dd89ad-Date-2020-04-15_Time-09-36-28.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 09:36:29 : Computing Total Accessibility Across All Features, 0.003 mins elapsed. ## 2020-04-15 09:36:35 : Computing Top Features, 0.102 mins elapsed. ## ########### ## 2020-04-15 09:36:35 : Running LSI (1 of 2) on Top Features, 0.111 mins elapsed. ## ########### ## 2020-04-15 09:36:35 : Sampling Cells (N = 10002) for Estimated LSI, 0.112 mins elapsed. ## 2020-04-15 09:36:35 : Creating Sampled Partial Matrix, 0.112 mins elapsed. ## 2020-04-15 09:36:45 : Computing Estimated LSI (projectAll = FALSE), 0.276 mins elapsed. ## 2020-04-15 09:37:22 : Identifying Clusters, 0.887 mins elapsed. ## 2020-04-15 09:37:53 : Identified 5 Clusters, 1.407 mins elapsed. ## 2020-04-15 09:37:53 : Saving LSI Iteration, 1.407 mins elapsed. ## 2020-04-15 09:38:10 : Creating Cluster Matrix on the total Group Features, 1.696 mins elapsed. ## 2020-04-15 09:38:21 : Computing Variable Features, 1.867 mins elapsed. ## ########### ## 2020-04-15 09:38:21 : Running LSI (2 of 2) on Variable Features, 1.871 mins elapsed. ## ########### ## 2020-04-15 09:38:21 : Creating Partial Matrix, 1.871 mins elapsed. ## 2020-04-15 09:38:30 : Computing LSI, 2.018 mins elapsed. ## 2020-04-15 09:39:05 : Finished Running IterativeLSI, 2.606 mins elapsed. If you see downstream that you have subtle batch effects, another option is to add more LSI iterations and to start from a lower intial clustering resolution as shown below. Additionally the number of variable features can be lowered to increase focus on the more variable features. We will name this reducedDims object “IterativeLSI2” for illustrative purposes but we won’t use is downstream. projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI2&quot;, iterations = 4, clusterParams = list( #See Seurat::FindClusters resolution = c(0.1, 0.2, 0.4), sampleCells = 10000, n.start = 10 ), varFeatures = 15000, dimsToUse = 1:30 ) ## Checking Inputs… ## ArchR logging to : ArchRLogs/ArchR-addIterativeLSI-ea2d349ff558-Date-2020-04-15_Time-09-39-05.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 09:39:06 : Computing Total Accessibility Across All Features, 0.004 mins elapsed. ## 2020-04-15 09:39:09 : Computing Top Features, 0.06 mins elapsed. ## ########### ## 2020-04-15 09:39:10 : Running LSI (1 of 4) on Top Features, 0.07 mins elapsed. ## ########### ## 2020-04-15 09:39:10 : Sampling Cells (N = 10002) for Estimated LSI, 0.071 mins elapsed. ## 2020-04-15 09:39:10 : Creating Sampled Partial Matrix, 0.071 mins elapsed. ## 2020-04-15 09:39:17 : Computing Estimated LSI (projectAll = FALSE), 0.192 mins elapsed. ## 2020-04-15 09:39:42 : Identifying Clusters, 0.611 mins elapsed. ## 2020-04-15 09:40:05 : Identified 4 Clusters, 0.987 mins elapsed. ## 2020-04-15 09:40:05 : Saving LSI Iteration, 0.987 mins elapsed. ## 2020-04-15 09:40:26 : Creating Cluster Matrix on the total Group Features, 1.343 mins elapsed. ## 2020-04-15 09:40:38 : Computing Variable Features, 1.54 mins elapsed. ## ########### ## 2020-04-15 09:40:38 : Running LSI (2 of 4) on Variable Features, 1.542 mins elapsed. ## ########### ## 2020-04-15 09:40:38 : Sampling Cells (N = 10002) for Estimated LSI, 1.544 mins elapsed. ## 2020-04-15 09:40:38 : Creating Sampled Partial Matrix, 1.544 mins elapsed. ## 2020-04-15 09:40:47 : Computing Estimated LSI (projectAll = FALSE), 1.687 mins elapsed. ## 2020-04-15 09:41:09 : Identifying Clusters, 2.048 mins elapsed. ## 2020-04-15 09:41:31 : Identified 7 Clusters, 2.421 mins elapsed. ## 2020-04-15 09:41:31 : Saving LSI Iteration, 2.421 mins elapsed. ## 2020-04-15 09:41:54 : Creating Cluster Matrix on the total Group Features, 2.807 mins elapsed. ## 2020-04-15 09:42:05 : Computing Variable Features, 2.995 mins elapsed. ## ########### ## 2020-04-15 09:42:06 : Running LSI (3 of 4) on Variable Features, 3 mins elapsed. ## ########### ## 2020-04-15 09:42:06 : Sampling Cells (N = 10002) for Estimated LSI, 3.001 mins elapsed. ## 2020-04-15 09:42:06 : Creating Sampled Partial Matrix, 3.001 mins elapsed. ## 2020-04-15 09:42:13 : Computing Estimated LSI (projectAll = FALSE), 3.121 mins elapsed. ## 2020-04-15 09:42:33 : Identifying Clusters, 3.461 mins elapsed. ## 2020-04-15 09:42:55 : Identified 9 Clusters, 3.829 mins elapsed. ## 2020-04-15 09:42:55 : Saving LSI Iteration, 3.829 mins elapsed. ## 2020-04-15 09:43:13 : Creating Cluster Matrix on the total Group Features, 4.129 mins elapsed. ## 2020-04-15 09:43:26 : Computing Variable Features, 4.341 mins elapsed. ## ########### ## 2020-04-15 09:43:26 : Running LSI (4 of 4) on Variable Features, 4.346 mins elapsed. ## ########### ## 2020-04-15 09:43:26 : Creating Partial Matrix, 4.347 mins elapsed. ## 2020-04-15 09:43:33 : Computing LSI, 4.462 mins elapsed. ## 2020-04-15 09:43:55 : Finished Running IterativeLSI, 4.829 mins elapsed. You can list the available reducedDims objects in an ArchRProject using the slot extraction opperator @: "],
["estimated-lsi.html", "4.3 Estimated LSI", " 4.3 Estimated LSI For extremely large scATAC-seq datasets, ArchR can estimate the LSI dimensionality reduction with LSI projection. This procedure is similar to the iterative LSI workflow, however the LSI procedure differs. First, a subset of randomly selected “landmark” cells is used for LSI dimensionality reduction. Second, the remaining cells are TF-IDF normalized using the inverse document frequency determined from the landmark cells. Third, these normalized cells are projected into the SVD subspace defined by the landmark cells. This leads to an LSI transformation based on a small set of cells used as landmarks for the projection of the remaining cells. This estimated LSI procedure is efficient with ArchR because, when projecting the new cells into the landmark cells LSI, ArchR iteratively reads in the cells from each sample and LSI projects them without storing them all in memory. This optimization leads to minimal memory usage and further increases the scalability for extremely large datasets. Importantly, the required landmark set size is dependent on the proportion of different cells within the dataset. Estimated LSI is accessed in ArchR via the addIterativeLSI() function by setting the sampleCellsFinal and projectCellsPre parameters. samplesCellsFinal designates the size of the landmark cell subset and projectCellsPre tells ArchR to use this landmark cell subset for projection of the remaining cells. "],
["batch-effect-correction-wtih-harmony.html", "4.4 Batch Effect Correction wtih Harmony", " 4.4 Batch Effect Correction wtih Harmony Sometimes the iterative LSI approach isnt enough of a correction for strong batch effect differences. For this reason, ArchR implements a commonly used batch effect correction tool called Harmony which was originally designed for scRNA-seq. We provide a wrapper that will pass a dimensionality reduction object from ArchR directly to the HarmonyMatrix() function. Additional arguments can be directly passed to HarmonyMatrix() in the function via the additional parameters (...) . See ?addHarmony() for more details. Users should be aware of the caveats of batch correction for their particular application. projHeme2 &lt;- addHarmony( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;Harmony&quot;, groupBy = &quot;Sample&quot; ) ## Harmony 1/10 ## Harmony 2/10 ## Harmony 3/10 ## Harmony converged after 3 iterations This process creates a new reducedDims object called “Harmony” in our projHeme2 object. "],
["clustering-with-archr.html", "Chapter 5 Clustering with ArchR", " Chapter 5 Clustering with ArchR Most single-cell clustering methods focus on computing nearest neighbor graphs in reduced dimensions and then identifying “communities” or clusters of cells. These approaches work extremely well and are a standard practice in scRNA-seq. For this reason, ArchR uses existing state-of-the-art clustering methods from scRNA-seq packages for clustering. "],
["clustering-using-seurats-findclusters-function.html", "5.1 Clustering using Seurat’s FindClusters() function", " 5.1 Clustering using Seurat’s FindClusters() function We have had the most success using the graph clustering approach implemented by Seurat. In ArchR, clustering is performed using the addClusters() function which permits additional clustering parameters to be passed to the Seurat::FindClusters() function via .... In our hands, clustering using Seurat::FindClusters() is deterministic, meaning that the exact same input will always result in the exact same output. projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;Seurat&quot;, name = &quot;Clusters&quot;, resolution = 0.8 ) ## ArchR logging to : ArchRLogs/ArchR-addClusters-ee735fb26d4a-Date-2020-04-15_Time-09-46-59.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 09:47:08 : Running Seurats FindClusters (Stuart et al. Cell 2019), 0.142 mins elapsed. ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10251 ## Number of edges: 496637 ## ## Running Louvain algorithm… ## Maximum modularity in 10 random starts: 0.8554 ## Number of communities: 12 ## Elapsed time: 1 seconds ## 2020-04-15 09:47:29 : Testing Outlier Clusters, 0.483 mins elapsed. ## 2020-04-15 09:47:29 : Assigning Cluster Names to 12 Clusters, 0.483 mins elapsed. To access these clusters we can use the $ accessor which shows the cluster ID for each single cell. head(projHeme2$Clusters) ## [1] “C3” “C8” “C4” “C3” “C11” “C3” We can tabulate the number of cells present in each cluster: table(projHeme2$Clusters) ## C1 C10 C11 C12 C2 C3 C4 C5 C6 C7 C8 C9 ## 1547 879 793 1650 1085 439 351 320 387 851 1271 678 To better understand which samples reside in which clusters, we can create a cluster confusion matrix across each sample using the confusionMatrix() function. cM &lt;- confusionMatrix(paste0(projHeme2$Clusters), paste0(projHeme2$Sample)) cM ## 12 x 3 sparse Matrix of class “dgCMatrix” ## scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 ## C3 251 6 182 ## C8 1219 . 52 ## C4 351 . . ## C11 251 541 1 ## C1 1508 9 30 ## C12 172 1478 . ## C10 194 677 8 ## C9 117 1 560 ## C7 301 . 550 ## C5 161 150 9 ## C2 82 1 1002 ## C6 82 305 . To plot this confusion matrix as a heatmap, we use the pheatmap package: library(pheatmap) cM &lt;- cM / Matrix::rowSums(cM) p &lt;- pheatmap::pheatmap( mat = as.matrix(cM), color = paletteContinuous(&quot;whiteBlue&quot;), border_color = &quot;black&quot; ) p There are times where the relative location of cells within the 2-dimensional embedding does not agree perfectly with the identified clusters. More explicitly, cells from a single cluster may appear in multiple different areas of the embedding. In these contexts, it is appropriate to adjust the clustering parameters or embedding parameters until there is agreement between the two. 5.1.1 Clustering using scran Additionally, ArchR allows for the identification of clusters with scran by changing the method parameter in addClusters(). projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;scran&quot;, name = &quot;ScranClusters&quot;, k = 15 ) ## ArchR logging to : ArchRLogs/ArchR-addClusters-ee735ec9887a-Date-2020-04-15_Time-09-47-32.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 09:47:39 : Running Scran SNN Graph (Lun et al. F1000Res. 2016), 0.103 mins elapsed. ## 2020-04-15 09:47:49 : Identifying Clusters (Lun et al. F1000Res. 2016), 0.27 mins elapsed. ## 2020-04-15 09:50:31 : Testing Outlier Clusters, 2.98 mins elapsed. ## 2020-04-15 09:50:31 : Assigning Cluster Names to 9 Clusters, 2.98 mins elapsed. "],
["single-cell-embeddings.html", "Chapter 6 Single Cell Embeddings", " Chapter 6 Single Cell Embeddings In ArchR, embeddings, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE), are used to visualize single cells in reduced dimension space. These embeddings each have distinct advantages and disadvantages. We call these “embeddings” because they are strictly used to visualize the clusters and are not used to identify clusters which is done in an LSI sub-space as mentioned in previous chapters. The primary difference between UMAP and t-SNE is the interpretatino of the distance between cells or clusters. t-SNE is designed to preserve the local structure in the data while UMAP is designed to preserve both the local and most of the global structure in the data. In theory, this means that the distance between two clusters is not informative in t-SNE but is informative in UMAP. For example, t-SNE does not allow you to say that Cluster A is more similar to Cluster B than it is to Cluster C based on the observation that Cluster A is located closer to Cluster B than Cluster C on the t-SNE. UMAP, on the other hand, is designed to permit this type of comparison, though it is worth noting that UMAP is a new enough method that this is still being flushed out in the literature. It is important to note that neither t-SNE nor UMAP are naturally deterministic (same input always gives exactly the same output). However, t-SNE shows much more randomness across multiple replicates of the same input than does UMAP. Moreover, UMAP as implemented in the uwot package is effectively deterministic when using the same random seed. The choice of whether to use UMAP or t-SNE is nuanced but in our hands, UMAP works very well for a diverse set of applications and this is our standard choice for scATAC-seq data. UMAP also performs faster than t-SNE. Perhaps most importantly, with UMAP you can create an embedding and project new samples into that embedding and this is not possible with t-SNE because the fitting and prediction of data happens simultaneously. Regardless of which method you choose, the input parameters can have drastic effects on the resulting embedding. Because of this, it is important to understand the various input parameters and to tweak these to best meet the needs of your own data. ArchR implements a default set of input parameters that work for most applications but there is really no single set of parameters that will produce the desired results for datasets that vary greatly in cell number, complexity, and quality. "],
["uniform-manifold-approximation-and-projection-umap.html", "6.1 Uniform Manifold Approximation and Projection (UMAP)", " 6.1 Uniform Manifold Approximation and Projection (UMAP) To run UMAP in ArchR we use the addUMAP() function: projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;UMAP&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) ## 09:50:55 UMAP embedding parameters a = 0.583 b = 1.334 ## 09:50:56 Read 10251 rows and found 30 numeric columns ## 09:50:56 Using Annoy for neighbor search, n_neighbors = 30 ## 09:50:57 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [—-|—-|—-|—-|—-|—-|—-|—-|—-|—-| ## **************************************************| ## 09:50:59 Writing NN index file to temp file /tmp/RtmpXb8qQa/fileefeefe9c02c ## 09:50:59 Searching Annoy index using 10 threads, search_k = 3000 ## 09:51:00 Annoy recall = 100% ## 09:51:01 Commencing smooth kNN distance calibration using 10 threads ## 09:51:03 Initializing from normalized Laplacian + noise ## 09:51:03 Commencing optimization for 200 epochs, with 467652 positive edges ## 09:51:14 Optimization finished You can list the available embeddings objects in an ArchRProject using the slot extraction opperator @: To plot the UMAP results, we use the plotEmbedding() function and pass the name of the UMAP embedding we just generated (“UMAP”). We can tell ArchR how to color the cells by using a combination of colorBy which tells ArchR which matrix to use to find the specified metadata column provided to name. p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee4e054106-Date-2020-04-15_Time-09-51-17.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee4e054106-Date-2020-04-15_Time-09-51-17.log Instead of coloring by “Sample” as above, we can color by “Clusters” which were identified in a previous chapter. p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee3f232286-Date-2020-04-15_Time-09-51-18.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee3f232286-Date-2020-04-15_Time-09-51-18.log We can visualize these two plots side by side using the ggAlignPlots() function, specifying a horizontal orientation using type = \"h\". ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-UMAP-Sample-Clusters.pdf We can also use plotEmbedding() to visualize the results from clustering using scran: p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee6f4b8b88-Date-2020-04-15_Time-09-51-38.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee6f4b8b88-Date-2020-04-15_Time-09-51-38.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee6c73b6da-Date-2020-04-15_Time-09-51-39.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee6c73b6da-Date-2020-04-15_Time-09-51-39.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-UMAP-Sample-ScranClusters.pdf "],
["t-stocastic-neighbor-embedding-t-sne.html", "6.2 t-Stocastic Neighbor Embedding (t-SNE)", " 6.2 t-Stocastic Neighbor Embedding (t-SNE) To run t-SNE in ArchR we use the addTSNE() function: projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;TSNE&quot;, perplexity = 30 ) ## Read the 10251 x 30 data matrix successfully! ## OpenMP is working. 9 threads. ## Using no_dims = 2, perplexity = 30.000000, and theta = 0.500000 ## Computing input similarities… ## Building tree… ## - point 10000 of 10251 ## - point 10000 of 10251 ## Done in 9.33 seconds (sparsity = 0.013318)! ## Learning embedding… ## Iteration 50: error is 96.116599 (50 iterations in 7.59 seconds) ## Iteration 100: error is 84.202047 (50 iterations in 7.93 seconds) ## Iteration 150: error is 81.634548 (50 iterations in 6.24 seconds) ## Iteration 200: error is 80.924221 (50 iterations in 6.33 seconds) ## Iteration 250: error is 80.681514 (50 iterations in 6.60 seconds) ## Iteration 300: error is 3.272456 (50 iterations in 5.98 seconds) ## Iteration 350: error is 3.003011 (50 iterations in 5.69 seconds) ## Iteration 400: error is 2.860067 (50 iterations in 5.58 seconds) ## Iteration 450: error is 2.771029 (50 iterations in 5.53 seconds) ## Iteration 500: error is 2.708926 (50 iterations in 5.58 seconds) ## Iteration 550: error is 2.662250 (50 iterations in 5.49 seconds) ## Iteration 600: error is 2.626274 (50 iterations in 5.53 seconds) ## Iteration 650: error is 2.597377 (50 iterations in 5.48 seconds) ## Iteration 700: error is 2.573140 (50 iterations in 5.48 seconds) ## Iteration 750: error is 2.553895 (50 iterations in 5.43 seconds) ## Iteration 800: error is 2.540270 (50 iterations in 5.46 seconds) ## Iteration 850: error is 2.531147 (50 iterations in 5.64 seconds) ## Iteration 900: error is 2.524095 (50 iterations in 5.73 seconds) ## Iteration 950: error is 2.517901 (50 iterations in 5.63 seconds) ## Iteration 1000: error is 2.511794 (50 iterations in 5.47 seconds) ## Fitting performed in 118.39 seconds. Similar to UMAP, we can plot the t-SNE embedding using plotEmbedding(). The same parameters apply to colorBy and name regardless of which type of embedding is being used. p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee11770af1-Date-2020-04-15_Time-09-52-22.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee11770af1-Date-2020-04-15_Time-09-52-22.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee339a10ad-Date-2020-04-15_Time-09-52-23.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee339a10ad-Date-2020-04-15_Time-09-52-23.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-TSNE-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-TSNE-Sample-Clusters.pdf As we did with UMAP, we can compare the clustering results from Seurat::FindClusters() with the results of clusering with scran: p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efeeb55d566-Date-2020-04-15_Time-09-52-45.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efeeb55d566-Date-2020-04-15_Time-09-52-45.log p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;TSNE&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee4843c8ed-Date-2020-04-15_Time-09-52-46.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee4843c8ed-Date-2020-04-15_Time-09-52-46.log ggAlignPlots(p1, p2, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2, name = &quot;Plot-tSNE-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-tSNE-Sample-ScranClusters.pdf "],
["dimensionality-reduction-after-harmony.html", "6.3 Dimensionality Reduction After Harmony", " 6.3 Dimensionality Reduction After Harmony In a previous chapter, we performed batch correction using Harmony via the addHarmony() function, creating a reducedDims object named “Harmony”. We can assess the effects of Harmony by visualizing the embedding using UMAP or t-SNE and comparing this to the embeddings visualized in the previous sections for iterative LSI. Repeating the UMAP embedding with the same parameters but for the “Harmony” reducedDims object: projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;UMAPHarmony&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) ## 09:53:44 UMAP embedding parameters a = 0.583 b = 1.334 ## 09:53:44 Read 10251 rows and found 30 numeric columns ## 09:53:44 Using Annoy for neighbor search, n_neighbors = 30 ## 09:53:44 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [—-|—-|—-|—-|—-|—-|—-|—-|—-|—-| ## **************************************************| ## 09:53:47 Writing NN index file to temp file /tmp/RtmpXb8qQa/fileefee55b054c6 ## 09:53:47 Searching Annoy index using 10 threads, search_k = 3000 ## 09:53:48 Annoy recall = 100% ## 09:53:49 Commencing smooth kNN distance calibration using 10 threads ## 09:53:50 Initializing from normalized Laplacian + noise ## 09:53:51 Commencing optimization for 200 epochs, with 472754 positive edges ## 09:54:01 Optimization finished p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAPHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efeea6eac67-Date-2020-04-15_Time-09-54-03.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efeea6eac67-Date-2020-04-15_Time-09-54-03.log p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAPHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee76ae6a66-Date-2020-04-15_Time-09-54-04.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee76ae6a66-Date-2020-04-15_Time-09-54-04.log ggAlignPlots(p3, p4, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;Plot-UMAP2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-UMAP2Harmony-Sample-Clusters.pdf And the same for t-SNE: projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;TSNEHarmony&quot;, perplexity = 30 ) ## Read the 10251 x 30 data matrix successfully! ## OpenMP is working. 9 threads. ## Using no_dims = 2, perplexity = 30.000000, and theta = 0.500000 ## Computing input similarities… ## Building tree… ## - point 10000 of 10251 ## Done in 12.20 seconds (sparsity = 0.013705)! ## Learning embedding… ## Iteration 50: error is 95.841545 (50 iterations in 9.09 seconds) ## Iteration 100: error is 86.878252 (50 iterations in 10.44 seconds) ## Iteration 150: error is 84.458350 (50 iterations in 6.52 seconds) ## Iteration 200: error is 84.214403 (50 iterations in 6.81 seconds) ## Iteration 250: error is 84.119663 (50 iterations in 6.93 seconds) ## Iteration 300: error is 3.435665 (50 iterations in 6.05 seconds) ## Iteration 350: error is 3.186510 (50 iterations in 5.82 seconds) ## Iteration 400: error is 3.055847 (50 iterations in 5.83 seconds) ## Iteration 450: error is 2.971219 (50 iterations in 5.78 seconds) ## Iteration 500: error is 2.911368 (50 iterations in 5.75 seconds) ## Iteration 550: error is 2.867716 (50 iterations in 5.70 seconds) ## Iteration 600: error is 2.833307 (50 iterations in 5.75 seconds) ## Iteration 650: error is 2.806291 (50 iterations in 5.72 seconds) ## Iteration 700: error is 2.784594 (50 iterations in 5.68 seconds) ## Iteration 750: error is 2.767633 (50 iterations in 5.68 seconds) ## Iteration 800: error is 2.754284 (50 iterations in 5.72 seconds) ## Iteration 850: error is 2.743628 (50 iterations in 5.71 seconds) ## Iteration 900: error is 2.735122 (50 iterations in 5.71 seconds) ## Iteration 950: error is 2.727634 (50 iterations in 5.67 seconds) ## Iteration 1000: error is 2.721500 (50 iterations in 5.69 seconds) ## Fitting performed in 126.05 seconds. p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNEHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee50fc7167-Date-2020-04-15_Time-09-55-42.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee50fc7167-Date-2020-04-15_Time-09-55-42.log p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNEHarmony&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-efee8ad75d2-Date-2020-04-15_Time-09-55-42.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-efee8ad75d2-Date-2020-04-15_Time-09-55-42.log ggAlignPlots(p3, p4, type = &quot;h&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;Plot-TSNE2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-TSNE2Harmony-Sample-Clusters.pdf "],
["gene-scores-and-marker-genes-with-archr.html", "Chapter 7 Gene Scores and Marker Genes with ArchR", " Chapter 7 Gene Scores and Marker Genes with ArchR While ArchR is able to robustly call clusters, it is not possible to know a priori which cell type is represented by each cluster. This task is often left to manual annotation because every application is different. To do this cell type annotation, we use prior knowledge of cell type-specific marker genes and we estimate gene expression for these genes from our chromatin accessibility data by uing gene scores. A gene score is essentially a prediction of how highly expressed a gene will be based on the accessibility of regulatory elements in the vicinity of the gene. To create these gene scores, ArchR allows for the use of complex user-supplied custom distance-weighted accessibility models. "],
["calculating-gene-scores-in-archr.html", "7.1 Calculating Gene Scores in ArchR", " 7.1 Calculating Gene Scores in ArchR In our publication, we tested over 50 different gene score models and identified a class of models that consistently outperformed the rest across a variety of test conditions. This class of model, which is implemented as the default in ArchR, has three major components: Accessibility within the entire gene body contributes to the gene score. An exponential weighting function that accounts for the activity of putative distal regulatory elements in a distance-dependent fashion. Imposed gene boundaries that minimizes the contribution of unrelated regulatory elements to the gene score. So how does ArchR calculate gene scores? For each chromosome, ArchR creates a tile matrix using a user-defined tile size that is not pre-computed (default is 500 bp), overlaps these tiles with the user-defined gene window (default is 100 kb on either side of the gene), and then computes the distance from each tile (start or end) to the gene body (with optional extensions upstream or downstream) or gene start. We have found that the best predictor of gene expression is the local accessibility of the gene region which includes the promoter and gene body. As mentioned above, to properly account for distal accessibility for a given gene, ArchR identifies the subset of tiles that are within the gene window and do not cross another gene region. This filtering allows for inclusion of distal regulatory elements that could improve the accuracy of predicting gene expression values but excludes regulatory elements more likely to be associated with another gene (for ex. the promoter of a nearby gene). The distance from each tile to the gene is then converted to a distance weight using a user-defined accessibility model (default is e(-abs(distance)/5000) + e-1). When the gene body is included in the gene region (where the distance-based weight is the maximum weight possible), we found that extremely large genes can bias the overall gene scores. In these cases, the total gene scores can vary substantially due to the inclusion of insertions in both introns and exons. To help adjust for these large differences in gene size, ArchR applies a separate weight for the inverse of the gene size (1 / gene size) and scales this inverse weight linearly from 1 to a user-defined hard maximum (default of 5). Smaller genes thus receive larger relative weights, partially normalizing this length effect. The corresponding distance and gene size weights are then multiplied by the number of Tn5 insertions within each tile and summed across all tiles within the gene window, while still accounting for nearby gene regions as described above. This summed accessibility is a “gene score” and is depth normalized across all genes to a user-defined constant (default of 10,000). Computed gene scores are then stored in the corresponding Arrow file for downstream analyses. To illustrate what the default ArchR gene score model looks like, we provide this toy example showing the weighting applied across the entire gene region: Gene scores are calculated for each Arrow file at the time of creation if the parameter addGeneScoreMat is set to TRUE - this is the default behavior. Alternatively, gene scores can be added to Arrow files at any time by using the addGeneScoreMatrix() function. Once caluclated, individual cells of an embedding can be colored by their gene scores to help with the identification of various cell types. We illustrate the application of gene scores throughout the rest of this chapter. It is important to note that not all genes behave well with gene scores. In particular, genes that reside in very gene-dense areas can be problematic. Thus, it is always best to sanity check all gene score analyses by looking at sequencing tracks which is described in a later chapter. "],
["identification-of-marker-genes.html", "7.2 Identification of Marker Genes", " 7.2 Identification of Marker Genes In addition to using prior knowledge of relevant marker genes for annotation of clusters, ArchR enables unbiased identification of marker features for any given cell groupings (for example, clusters). These features can be anything - peaks, genes (based on gene scores), or transcription factor motifs (based on chromVAR deviations). ArchR does this using the getMarkerFeatures() function which can take as input any matrix via the useMatrix parameter and it identifies features unique to the groups indicated by the groupBy parameter. If the useMatrix parameter is set to “GeneScoreMatrix”, then the function will identify the genes that appear to be uniquely active in each cell type. This provides an unbiased way of seeing which genes are predicted to be active in each cluster and can aid in cluster annotation. As mentioned above, the same getMarkerFeatures() function can be used with any matrix stored in the Arrow files to identify features that are specific to certain cell groups. This is accomplished via the useMatrix parameter. For example, useMatrix = \"TileMatrix\" would identify genomic regions that are highly specific to a certain cell group and useMatrix = \"PeakMatrix\" would identify peaks that are highly specific to a certain cell group. 7.2.1 How does marker feature identification happen? This process of marker feature identification hinges on the selection of a group of bias-matched background cells for each cell group. Across all features, each cell group is compared to its own background group of cells to determine if the given cell group has significantly higher accessibility. The selection of these background cell groups is critical to the success of this process and is performed across the multi-dimensional space provided by the user via the bias argument to getMarkerFeatures(). For each cell in the cell group, ArchR finds the nearest neighbor cell across the provided multi-dimensional space that is not a member of the given cell group and adds it to the background group of cells. In this way, ArchR creates a group of bias-matched cells that is as similar as possible to the given cell group, thus enabling a more robust determination of significance even if the group of cells is small. The way ArchR does this is by taking all of the dimensions provided via the bias parameter and quantile normalizing their values to distribute the variance of each dimension across the same relative scale. Taking a toy example, if the parameters TSS and log10(Num Fragments) were provided to bias, the pre-quantile normalized values might look like this: Here, the relative variance across the y-axis is very small compared to the variance across the x-axis. If we normalize these axes so that their values range from 0 to 1 instead, we make the relative variance much more equal. Importantly, we also change the nearest neighbors dramatically as indicated to the right of this plot. ArchR normalizes all of the dimensions and uses euclidean distance in this normalized multidimensional space to find the nearest neighbors. 7.2.2 Identifying marker genes in our tutorial data To identify marker genes based on gene scores, we call the getMarkerFeatures() function with useMatrix = \"GeneScoreMatrix\". We specify that we want to know the cluster-specific features with groupBy = \"Clusters\" which tells ArchR to use the “Clusters” column in cellColData to stratify cell groups. markersGS &lt;- getMarkerFeatures( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, groupBy = &quot;Clusters&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-f4e4232fa80b-Date-2020-04-15_Time-10-04-48.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Double.Matrix ## 2020-04-15 10:04:49 : Matching Known Biases, 0.009 mins elapsed. ## ## ########### ## 2020-04-15 10:05:23 : Completed Pairwise Tests, 0.585 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-f4e4232fa80b-Date-2020-04-15_Time-10-04-48.log This function returns a SummarizedExperiment object containing relevant information on the marker features identified. This type of return value is common in ArchR and is one of the key ways that ArchR enables downstream data analysis. SummarizedExperiment objects are similar to a matrix where rows represent features of interest (i.e. genes) and columns represent samples. A SummarizedExperiment object contains one or more assays, each represented by a matrix-like object of numeric data, and metadata that applies to the rows or columns of the assays matrices. It is beyond the scope of this tutorial to dive into SummarizedExperiment objects but check out the bioconductor page if you need more information. We can get a list of DataFrame objects, one for each of our clusters, containing the relevant marker features using the getMarkers() function: markerList &lt;- getMarkers(markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;) markerList$C6 ## DataFrame with 291 rows and 9 columns ## seqnames start end strand name idx ## ## 8362 chr16 49891830 49524515 2 ZNF423 539 ## 7025 chr14 105714879 105717430 1 BTBD6 764 ## 8726 chr16 89043504 88941263 2 CBFA2T3 903 ## 7024 chr14 105781914 105675623 2 BRF1 763 ## 17158 chr5 997455 988425 2 LOC100506688 18 ## … … … … … … … ## 19084 chr6 119812467 119773712 2 LOC285762 925 ## 18913 chr6 83072923 83077133 1 TPBG 754 ## 12814 chr2 124782864 125672863 1 CNTNAP5 755 ## 20390 chr7 150147962 150176483 1 GIMAP8 1028 ## 7384 chr15 52569397 52569314 2 MIR1266 347 ## Log2FC FDR MeanDiff ## ## 8362 1.94888141545084 2.95473053609015e-21 2.08129078745695 ## 7025 1.88748443360838 3.25360925877231e-15 2.29925343722754 ## 8726 1.5858058377813 3.25360925877231e-15 2.11727644857422 ## 7024 1.41061475820385 2.00400144783449e-14 1.9923490244715 ## 17158 3.16686924437513 2.00400144783449e-14 0.693424444489265 ## … … … … ## 19084 1.36625245611966 0.00853516274073803 0.211727000065234 ## 18913 2.30499450627443 0.00854168013784213 0.544454051635953 ## 12814 2.28305835231306 0.00893526022954534 0.82240450922043 ## 20390 1.52933035478039 0.00910586862792073 0.516763460205267 ## 7384 2.16292224987129 0.00986664274558125 0.22839476831448 To visualize all of the marker features simultaneously, we can create a heatmap using the markerHeatmap() function, optionally supplying some marker genes to label on the heatmap via the labelMarkers parameter. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;EBF1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;CEBPB&quot;, &quot;MPO&quot;, #Monocytes &quot;IRF8&quot;, &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) heatmapGS &lt;- markerHeatmap( seMarker = markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;, labelMarkers = markerGenes, transpose = TRUE ) ## Printing Top Marker Genes: ## C1: ## PADI4, PADI6, CDA, LINC01226, TMEM61, RPE65, PIN1P1, GNAT2, HSD3BP4, SRGAP2D, SNX27, THEM5, S100A8, FCAMR, UCN3, MIR604, MIR938, MIR4679-2, OR56B4, OR52B2 ## C2: ## HES4, FHAD1, PLA2G2C, CELA3A, RHD, FGR, MYCL, BTBD19, TCTEX1D4, SLC5A9, L1TD1, PALMD, FRRS1, GPR88, MYBPHL, CASQ2, NHLH2, SLC22A15, CTSS, S100A11 ## C3: ## PLEKHM2, MIR4422, CLCA3P, LOC729970, ALG14, TMEM56, SLC16A4, FCRL3, AIM2, SLAMF6, C1orf220, MIR4424, RALGPS2, RHEX, FCMR, BPNT1, KMO, LINC00700, ARID5B, MIR548AV ## C4: ## LINC01342, LINC01346, SERINC2, RIMS3, SLFNL1-AS1, EDN2, ROR1, C1orf141, CACNA1S, KLHDC8A, SLC16A9, MIR346, GLYATL2, FAM111B, OR5AN1, RAB30-AS1, BTG4, TEAD4, CD9, PIANP ## C5: ## LRRC38, FAM131C, PLA2G2D, LOC653160, TSPAN1, TTC39A, GBP1P1, LOC100129046, HAO2, RORC, S100A5, S100A4, ILDR2, FMO1, ANGPTL1, LAD1, TNNI1, VASH2, GJC2, KCNK1 ## C6: ## TTLL10, ATP13A2, PAX7, CSMD2, MIR3659, TRABD2B, ERICH3, ABCA4, NTNG1, LOR, FAM189B, UCK2, PHLDA3, LEMD1, SERTAD4-AS1, ESRRG, TRIM67, LOC149373, C1orf131, DEPP1 ## C7: ## TNFRSF4, RUNX3, LEXM, IL12RB2, VCAM1, CHIA, BCL2L15, CD160, PDZK1, SH2D2A, NTRK1, PYHIN1, SLAMF7, FCGR3A, CD247, LOC100505918, FASLG, GAS5-AS1, ATP6V1G3, GREM2 ## C8: ## RCAN3, HPCAL4, ANKRD13C, HHLA3, ZRANB2, PLPPR5, PRMT6, AMIGO1, CHI3L2, CD2, PTGFRN, ACP6, NIT1, NUF2, MIR557, IL19, MIR1265, ANKRD26, ZEB1, ZEB1-AS1 ## C9: ## ESPN, MIR4252, RCAN3AS, HOOK1, ZNF37BP, ZNF239, SLC10A1, TMEM202, RRN3P1, TP53TG3D, MT1F, ZNF286B, FOXO3B, TRIM16L, PEX12, LOC729966, PDCD2L, ZNF283, ZNF610, TLX2 ## C10: ## MIR4689, HES2, NPPA-AS1, MFN2, FBLIM1, KLHDC7A, RPS14P3, FAM43B, MIR378F, GRHL3, TRIM63, GJB3, GJA4, EPHA10, RHBDL2, PPIE, RIMKLA, FAM183A, LINC00853, PDZK1IP1 ## C11: ## NPPA, SFTA1P, WT1-AS, MIR4488, LRRC10B, CACNA1C-AS4, LOC728739, CCNA1, LPO, MPO, TTR, PRTN3, ELANE, OR10H2, NCAN, OXER1, INSM1, BPIFA1, EMILIN3, COL9A3 ## C12: ## LINC02593, VWA1, CHD5, TMEM51-AS1, MFAP2, PADI3, HSPG2, C1QB, MIR4253, KIAA1522, C1orf94, LINC01343, KNCN, DMRTB1, CDCP2, ACOT11, ASB17, CYR61, SLC6A17, LOC643441 ## Identified 2662 markers! ## Adding Annotations.. ## Preparing Main Heatmap.. To plot this heatmap, we can use the ComplexHeatmap::draw() function because the heatmapGS object is actually a list of heatmaps: ComplexHeatmap::draw(heatmapGS, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(heatmapGS, name = &quot;GeneScores-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE) ## [1] 0 Download PDF : GeneScores-Marker-Heatmap.pdf "],
["visualizing-marker-genes-on-an-embedding.html", "7.3 Visualizing Marker Genes on an Embedding", " 7.3 Visualizing Marker Genes on an Embedding As mentioned previously, we can overlay per-cell gene scores on our UMAP embedding. This is accomplished using the colorBy and name parameters in the plotEmbedding() function. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;MPO&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;#TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, quantCut = c(0.01, 0.95), imputeWeights = NULL ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f4e44c020f3e-Date-2020-04-15_Time-10-05-43.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f4e44c020f3e-Date-2020-04-15_Time-10-05-43.log To plot a specific gene, we can subset this plot list: p$CD14 To plot all genes we can use cowplot to arrange the various marker genes into a single plot. p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-WO-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-UMAP-Marker-Genes-WO-Imputation.pdf "],
["marker-genes-imputation-with-magic.html", "7.4 Marker Genes Imputation with MAGIC", " 7.4 Marker Genes Imputation with MAGIC In the previous section, you may have noticed that some of the gene score plots appear quite variable. This is because of the sparsity of scATAC-seq data. We can use MAGIC to impute gene scores by smoothing signal across nearby cells. In our hands, this greatly improves the visual interpretation of gene scores. To do this, we first add impute weights to our ArchRProject. projHeme2 &lt;- addImputeWeights(projHeme2) ## 2020-04-15 10:06:25 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 10:06:36 : Completed Getting Magic Weights!, 0.19 mins elapsed. These impute weights can then be passed to plotEmbedding() when plotting gene scores overlayed on the UMAP embedding. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, &quot;MME&quot;, #B-Cell Trajectory &quot;CD14&quot;, &quot;MPO&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;#TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme2) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f4e41cd9b447-Date-2020-04-15_Time-10-06-36.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f4e41cd9b447-Date-2020-04-15_Time-10-06-36.log As before, we can subset this plot list to select a specific gene. p$CD14 Or we can plot all the marker genes at once using cowplot. #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save an editable vectorized version of this plot, we use the plotPDF() function. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-W-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 Download PDF : Plot-UMAP-Marker-Genes-W-Imputation.pdf "],
["track-plotting-with-archrbrowser.html", "7.5 Track Plotting with ArchRBrowser", " 7.5 Track Plotting with ArchRBrowser In addition to plotting gene scores per cell as a UMAP overlay, we can browse the local chromatin accessibility at these marker genes on a per cluster basis with genome browser tracks. To do this, we use the plotBrowserTrack() function which will create a list of plots, one for each of the genes specified by markerGenes. This function will plot a single track for each group in the groupBy parameter. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotBrowserTrack( ArchRProj = projHeme2, groupBy = &quot;Clusters&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000 ) ## ArchR logging to : ArchRLogs/ArchR-plotBrowserTrack-f4e46f9da45e-Date-2020-04-15_Time-10-07-24.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:07:24 : Validating Region, 0.006 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 10:07:25 : Adding Bulk Tracks (1 of 9), 0.009 mins elapsed. ## 2020-04-15 10:07:27 : Adding Gene Tracks (1 of 9), 0.044 mins elapsed. ## 2020-04-15 10:07:27 : Plotting, 0.054 mins elapsed. ## 2020-04-15 10:07:29 : Adding Bulk Tracks (2 of 9), 0.09 mins elapsed. ## 2020-04-15 10:07:31 : Adding Gene Tracks (2 of 9), 0.108 mins elapsed. ## 2020-04-15 10:07:31 : Plotting, 0.117 mins elapsed. ## 2020-04-15 10:07:34 : Adding Bulk Tracks (3 of 9), 0.157 mins elapsed. ## 2020-04-15 10:07:35 : Adding Gene Tracks (3 of 9), 0.175 mins elapsed. ## 2020-04-15 10:07:35 : Plotting, 0.183 mins elapsed. ## 2020-04-15 10:07:37 : Adding Bulk Tracks (4 of 9), 0.221 mins elapsed. ## 2020-04-15 10:07:38 : Adding Gene Tracks (4 of 9), 0.239 mins elapsed. ## 2020-04-15 10:07:39 : Plotting, 0.249 mins elapsed. ## 2020-04-15 10:07:41 : Adding Bulk Tracks (5 of 9), 0.279 mins elapsed. ## 2020-04-15 10:07:42 : Adding Gene Tracks (5 of 9), 0.295 mins elapsed. ## 2020-04-15 10:07:42 : Plotting, 0.301 mins elapsed. ## 2020-04-15 10:07:44 : Adding Bulk Tracks (6 of 9), 0.339 mins elapsed. ## 2020-04-15 10:07:46 : Adding Gene Tracks (6 of 9), 0.358 mins elapsed. ## 2020-04-15 10:07:46 : Plotting, 0.367 mins elapsed. ## 2020-04-15 10:07:49 : Adding Bulk Tracks (7 of 9), 0.409 mins elapsed. ## 2020-04-15 10:07:50 : Adding Gene Tracks (7 of 9), 0.429 mins elapsed. ## 2020-04-15 10:07:50 : Plotting, 0.44 mins elapsed. ## 2020-04-15 10:07:54 : Adding Bulk Tracks (8 of 9), 0.502 mins elapsed. ## 2020-04-15 10:07:55 : Adding Gene Tracks (8 of 9), 0.52 mins elapsed. ## 2020-04-15 10:07:56 : Plotting, 0.528 mins elapsed. ## 2020-04-15 10:07:58 : Adding Bulk Tracks (9 of 9), 0.567 mins elapsed. ## 2020-04-15 10:07:59 : Adding Gene Tracks (9 of 9), 0.585 mins elapsed. ## 2020-04-15 10:08:00 : Plotting, 0.593 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-plotBrowserTrack-f4e46f9da45e-Date-2020-04-15_Time-10-07-24.log To plot a track of a specific gene, we can select one from the list. grid::grid.newpage() grid::grid.draw(p$CD14) We can save a multi-page PDF with a single page for each gene locus in our plot list using the plotPDF() function. plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## [1] 0 Download PDF : Plot-Tracks-Marker-Genes.pdf "],
["launching-the-archrbrowser.html", "7.6 Launching the ArchRBrowser", " 7.6 Launching the ArchRBrowser One challenge inherent to scATAC-seq data analysis is genome-track level visualizations of chromatin accessibility observed within groups of. Traditionally, track visualization requires grouping the scATAC-seq fragments, creating a genome coverage bigwig, and normalizing this track for quantitative visualization. Typically, end-users use a genome browser such as the WashU Epigenome Browser, the UCSC Genome Browser, or the IGV browser to visualize these sequencing tracks. This process involves using multiple software and any change to the cellular groups or addition of more samples requires re-generation of bigwig files etc., which can become time consuming. For this reason, ArchR has a Shiny-based interactive genome browser that can be launched with a single line of code ArchRBrowser(ArchRProj). The data storage strategy implemented in Arrow files allows this interactive browser to dynamically change the cell groupings, resolution, and normalization, enabling real-time track-level visualizations. The ArchR Genome Browser also creates high-quality vectorized images in PDF format for publication or distribution. Additionally, the browser accepts user-supplied input files such as a GenomicRanges object to display features, via the features parameter, or genomic interaction files that define co-accessibility, peak-to-gene linkages, or loops from chromatin conformation data via the loops parameter. For loops the expected format is a GRanges object whose start position represents the center position of one loop anchor and whose end position represents the center position of the other loop anchor. To launch our local interactive genome browser, we use the ArchRBrowser() function. #ArchRBrowser(projHeme2) When we start, we see a screen that looks like this: By selecting a gene via the “Gene Symbol” box, we can begin browsing. You may need to click the “Plot Track” button to force your browser session to update. Once we have plotted a gene locus, we see a single track representing each of the clusters in our data If we click the “Additional Parameters” tab, we can specify which clusters to display and which to hide. By unclicking the check boes next to Clusters 1, 2, and 3, we will remove them from the plot. When we return to the “Plot” tab, we should see an updated plot with Clusters 1, 2, and 3 removed. Again, you may need to click the “Plot Track” button to force your browser session to update. "],
["labeling-clusters-with-scrna.html", "Chapter 8 Labeling Clusters with scRNA ", " Chapter 8 Labeling Clusters with scRNA "],
["labeling-scatac-cells-with-scrna-clusters.html", "8.1 Labeling scATAC cells with scRNA clusters", " 8.1 Labeling scATAC cells with scRNA clusters First we need to download scRNA data for hematopoiesis from Granja* et al (2019). #111 MB Download if(!file.exists(&quot;scRNA-Hematopoiesis-Granja-2019.rds&quot;)){ download.file( url = &quot;https://jeffgranja.s3.amazonaws.com/ArchR/TestData/scRNA-Hematopoiesis-Granja-2019.rds&quot;, destfile = &quot;scRNA-Hematopoiesis-Granja-2019.rds&quot; ) } seRNA &lt;- readRDS(&quot;scRNA-Hematopoiesis-Granja-2019.rds&quot;) seRNA ## class: RangedSummarizedExperiment ## dim: 20287 35582 ## metadata(0): ## assays(1): counts ## rownames(20287): FAM138A OR4F5 … S100B PRMT2 ## rowData names(3): gene_name gene_id exonLength ## colnames(35582): CD34_32_R5:AAACCTGAGTATCGAA-1 ## CD34_32_R5:AAACCTGAGTCGTTTG-1 … ## BMMC_10x_GREENLEAF_REP2:TTTGTTGCATGTGTCA-1 ## BMMC_10x_GREENLEAF_REP2:TTTGTTGCATTGAAAG-1 ## colData names(10): Group nUMI_pre … BioClassification Barcode colnames(colData(seRNA)) ## [1] “Group” “nUMI_pre” “nUMI” ## [4] “nGene” “initialClusters” “UMAP1” ## [7] “UMAP2” “Clusters” “BioClassification” ## [10] “Barcode” table(colData(seRNA)$BioClassification) ## 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP ## 1425 1653 446 111 2260 ## 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC ## 903 2097 1050 544 325 ## 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 ## 1800 4222 292 520 377 ## 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 ## 710 1711 62 1521 2470 ## 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK ## 2364 3539 796 2080 2143 ## 26_Unk ## 161 Unconstrained Integration (not-recommended) #~5 minutes projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = FALSE, groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell_Un&quot;, #Name of column where cell from scRNA is matched to each cell nameGroup = &quot;predictedGroup_Un&quot;, #Name of column where group from scRNA is matched to each cell nameScore = &quot;predictedScore_Un&quot; #Name of column where prediction score from scRNA ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f6635e453cfd-Date-2020-04-15_Time-10-08-55.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:08:56 : Running Seurat’s Integration Stuart* et al 2019, 0.005 mins elapsed. ## 2020-04-15 10:09:06 : Checking ATAC Input, 0.172 mins elapsed. ## 2020-04-15 10:09:06 : Checking RNA Input, 0.173 mins elapsed. ## 2020-04-15 10:09:17 : Creating Integration Blocks, 0.367 mins elapsed. ## 2020-04-15 10:09:18 : Prepping Interation Data, 0.372 mins elapsed. ## 2020-04-15 10:09:19 : Computing Integration in 1 Integration Blocks!, 0 mins elapsed. ## 2020-04-15 10:09:19 : Block (1 of 1) : Computing Integration, 0 mins elapsed. ## 2020-04-15 10:09:23 : Block (1 of 1) : Identifying Variable Genes, 0.071 mins elapsed. ## 2020-04-15 10:09:28 : Block (1 of 1) : Getting GeneScoreMatrix, 0.146 mins elapsed. ## 2020-04-15 10:09:37 : Block (1 of 1) : Imputing GeneScoreMatrix, 0.298 mins elapsed. ## 2020-04-15 10:09:37 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 10:09:37 : Computing Partial Diffusion Matrix with Magic (1 of 2), 0 mins elapsed. ## 2020-04-15 10:09:44 : Computing Partial Diffusion Matrix with Magic (2 of 2), 0.122 mins elapsed. ## 2020-04-15 10:09:51 : Completed Getting Magic Weights!, 0.242 mins elapsed. ## Getting ImputeWeights ## Using weights on disk ## Using weights on disk ## Getting ImputeWeights ## 2020-04-15 10:10:17 : Block (1 of 1) : Seurat FindTransferAnchors, 0.968 mins elapsed. ## 2020-04-15 10:12:00 : Block (1 of 1) : Seurat TransferData Cell Labels, 2.681 mins elapsed. ## 2020-04-15 10:12:34 : Block (1 of 1) : Completed Integration, 3.243 mins elapsed. ## 2020-04-15 10:12:34 : Completed Integration with RNA Matrix, 3.256 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f6635e453cfd-Date-2020-04-15_Time-10-08-55.log Constrained Integration (recommended) #We can use the unconstrained fits to help identify which are T/NK Cells cM &lt;- as.matrix(confusionMatrix(projHeme2$Clusters, projHeme2$predictedGroup_Un)) preClust &lt;- colnames(cM)[apply(cM, 1 , which.max)] cbind(preClust, rownames(cM)) #Assignments ## preClust ## [1,] “17_B” “C3” ## [2,] “20_CD4.N1” “C8” ## [3,] “16_Pre.B” “C4” ## [4,] “08_GMP.Neut” “C11” ## [5,] “11_CD14.Mono.1” “C1” ## [6,] “01_HSC” “C12” ## [7,] “03_Late.Eryth” “C10” ## [8,] “22_CD4.M” “C9” ## [9,] “25_NK” “C7” ## [10,] “09_pDC” “C5” ## [11,] “12_CD14.Mono.2” “C2” ## [12,] “15_CLP.2” “C6” #From scRNA cTNK &lt;- paste0(paste0(19:25), collapse=&quot;|&quot;) cTNK ## [1] “19|20|21|22|23|24|25” cNonTNK &lt;- paste0(c(paste0(&quot;0&quot;, 1:9), 10:13, 15:18), collapse=&quot;|&quot;) cNonTNK ## [1] “01|02|03|04|05|06|07|08|09|10|11|12|13|15|16|17|18” #Assign scATAC to these categories clustTNK &lt;- rownames(cM)[grep(cTNK, preClust)] clustTNK ## [1] “C8” “C9” “C7” clustNonTNK &lt;- rownames(cM)[grep(cNonTNK, preClust)] clustNonTNK ## [1] “C3” “C4” “C11” “C1” “C12” “C10” “C5” “C2” “C6” #RNA get cells in these categories rnaTNK &lt;- colnames(seRNA)[grep(cTNK, colData(seRNA)$BioClassification)] head(rnaTNK) ## [1] “PBMC_10x_GREENLEAF_REP1:AAACCCAGTCGTCATA-1” ## [2] “PBMC_10x_GREENLEAF_REP1:AAACCCATCCGATGTA-1” ## [3] “PBMC_10x_GREENLEAF_REP1:AAACCCATCTCAACGA-1” ## [4] “PBMC_10x_GREENLEAF_REP1:AAACCCATCTCTCGAC-1” ## [5] “PBMC_10x_GREENLEAF_REP1:AAACGAACAATCGTCA-1” ## [6] “PBMC_10x_GREENLEAF_REP1:AAACGAACACGATTCA-1” rnaNonTNK &lt;- colnames(seRNA)[grep(cNonTNK, colData(seRNA)$BioClassification)] head(rnaNonTNK) ## [1] “CD34_32_R5:AAACCTGAGTATCGAA-1” “CD34_32_R5:AAACCTGAGTCGTTTG-1” ## [3] “CD34_32_R5:AAACCTGGTTCCACAA-1” “CD34_32_R5:AAACGGGAGCTTCGCG-1” ## [5] “CD34_32_R5:AAACGGGAGGGAGTAA-1” “CD34_32_R5:AAACGGGAGTTACGGG-1” groupList &lt;- SimpleList( TNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustTNK], RNA = rnaTNK ), NonTNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustNonTNK], RNA = rnaNonTNK ) ) #~5 minutes projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = FALSE, groupList = groupList, #Constrain List groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell_Co&quot;, #Name of column where cell from scRNA is matched to each cell nameGroup = &quot;predictedGroup_Co&quot;, #Name of column where group from scRNA is matched to each cell nameScore = &quot;predictedScore_Co&quot; #Name of column where prediction score from scRNA ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f663618b2629-Date-2020-04-15_Time-10-12-35.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:12:36 : Running Seurat’s Integration Stuart* et al 2019, 0.014 mins elapsed. ## 2020-04-15 10:12:36 : Checking ATAC Input, 0.027 mins elapsed. ## 2020-04-15 10:12:36 : Checking RNA Input, 0.027 mins elapsed. ## 2020-04-15 10:12:48 : Creating Integration Blocks, 0.218 mins elapsed. ## 2020-04-15 10:12:48 : Prepping Interation Data, 0.222 mins elapsed. ## 2020-04-15 10:12:49 : Computing Integration in 2 Integration Blocks!, 0 mins elapsed. ## 2020-04-15 10:15:24 : Completed Integration with RNA Matrix, 2.574 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f663618b2629-Date-2020-04-15_Time-10-12-35.log Compare results pal &lt;- paletteDiscrete(values = colData(seRNA)$BioClassification) ## Length of unique values greater than palette, interpolating.. pal ## 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP ## “#D51F26” “#502A59” “#235D55” “#3D6E57” “#8D2B8B” ## 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC ## “#DE6C3E” “#F9B712” “#D8CE42” “#8E9ACD” “#B774B1” ## 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 ## “#D69FC8” “#C7C8DE” “#8FD3D4” “#89C86E” “#CC9672” ## 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 ## “#CF7E96” “#A27AA4” “#CD4F32” “#6B977E” “#518AA3” ## 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK ## “#5A5297” “#0F707D” “#5E2E32” “#A95A3C” “#B28D5C” ## 26_Unk ## “#3D3D3D” p1 &lt;- plotEmbedding( projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup_Un&quot;, pal = pal ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f66351b51d5d-Date-2020-04-15_Time-10-15-31.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f66351b51d5d-Date-2020-04-15_Time-10-15-31.log p1 p2 &lt;- plotEmbedding( projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup_Co&quot;, pal = pal ) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f6632ef266a4-Date-2020-04-15_Time-10-15-49.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f6632ef266a4-Date-2020-04-15_Time-10-15-49.log p2 To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-RNA-Integration.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 "],
["adding-pseudo-scrna-profiles-for-each-scatac-cell.html", "8.2 Adding Pseudo-scRNA profiles for each scATAC cell", " 8.2 Adding Pseudo-scRNA profiles for each scATAC cell We can save our original projHeme2 using saveArchRProject from ArchR. saveArchRProject(ArchRProj = projHeme2, outputDirectory = &quot;Save-ProjHeme2&quot;, load = FALSE) ## Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme2 ## Copying Arrow Files… ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights… ## Copying Other Files… ## Copying Other Files (1 of 4): Embeddings ## Copying Other Files (2 of 4): IterativeLSI ## Copying Other Files (3 of 4): IterativeLSI2 ## Copying Other Files (4 of 4): Plots ## Saving ArchRProject… Once you are satisfied with the results you can re-run with adding the gene expression to the Arrow Files groupList &lt;- SimpleList( TNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustTNK], RNA = rnaTNK ), NonTNK = SimpleList( ATAC = projHeme2$cellNames[projHeme2$Clusters %in% clustNonTNK], RNA = rnaNonTNK ) ) groupList ## List of length 2 ## names(2): TNK NonTNK #~5 minutes projHeme3 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, matrixName = &quot;GeneIntegrationMatrix&quot;, reducedDims = &quot;IterativeLSI&quot;, seRNA = seRNA, addToArrow = TRUE, #Now we add gene expression to Arrow Files force= TRUE, groupList = groupList, #Constrain List groupRNA = &quot;BioClassification&quot;, nameCell = &quot;predictedCell&quot;, #Name of column where cell from scRNA is matched to each cell nameGroup = &quot;predictedGroup&quot;, #Name of column where group from scRNA is matched to each cell nameScore = &quot;predictedScore&quot; #Name of column where prediction score from scRNA ) ## ArchR logging to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f66317d3557e-Date-2020-04-15_Time-10-16-26.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:16:26 : Running Seurat’s Integration Stuart* et al 2019, 0.009 mins elapsed. ## 2020-04-15 10:16:27 : Checking ATAC Input, 0.021 mins elapsed. ## 2020-04-15 10:16:27 : Checking RNA Input, 0.021 mins elapsed. ## 2020-04-15 10:16:38 : Creating Integration Blocks, 0.211 mins elapsed. ## 2020-04-15 10:16:39 : Prepping Interation Data, 0.215 mins elapsed. ## 2020-04-15 10:16:39 : Computing Integration in 2 Integration Blocks!, 0 mins elapsed. ## 2020-04-15 10:19:30 : Transferring Data to ArrowFiles, 2.843 mins elapsed. ## 2020-04-15 10:20:47 : Completed Integration with RNA Matrix, 4.133 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGeneIntegrationMatrix-f66317d3557e-Date-2020-04-15_Time-10-16-26.log What matrices are available? getAvailableMatrices(projHeme3) ## [1] “GeneIntegrationMatrix” “GeneScoreMatrix” “TileMatrix” Now lets see how this effects our marker gene scores overlayed on our 2-d embedding. projHeme3 &lt;- addImputeWeights(projHeme3) ## 2020-04-15 10:20:49 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 10:20:59 : Completed Getting Magic Weights!, 0.176 mins elapsed. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p1 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneIntegrationMatrix&quot;, name = markerGenes, continuousSet = &quot;horizonExtra&quot;, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f66370e499ac-Date-2020-04-15_Time-10-20-59.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f66370e499ac-Date-2020-04-15_Time-10-20-59.log p2 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneScoreMatrix&quot;, continuousSet = &quot;horizonExtra&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f6632d4259ce-Date-2020-04-15_Time-10-21-15.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f6632d4259ce-Date-2020-04-15_Time-10-21-15.log To plot all marker genes we can use cowplot #Rearrange for grid plotting p1c &lt;- lapply(p1, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) #Rearrange for grid plotting p2c &lt;- lapply(p2, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3), p1c)) do.call(cowplot::plot_grid, c(list(ncol = 3), p2c)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p1, name = &quot;Plot-UMAP-Marker-Genes-RNA-W-Imputation.pdf&quot;, ArchRProj = projHeme3, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 "],
["labeling-scatac-clusters-with-scrna.html", "8.3 Labeling scATAC clusters with scRNA", " 8.3 Labeling scATAC clusters with scRNA Now that we have pretty good scRNA and scATAC correspondence we can label our clusters with scRNA ## [1] “plotting ggplot!” ## [1] 0 To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, name = &quot;Plot-UMAP-Remap-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) "],
["pseudo-bulk-replicates-in-archr.html", "Chapter 9 Pseudo-bulk Replicates in ArchR", " Chapter 9 Pseudo-bulk Replicates in ArchR Many of the analyses we would like to perform require replicates to obtain measurements of statistical significance. In single-cell data, this is done by forming pseudo-bulk replicates. The term pseudo-bulk refers to a grouping of single cells where the data from each single cell is combined into a single pseudo-sample that resembles a bulk ATAC-seq experiment. ArchR makes multiple such pseudo-bulk samples for each cell grouping, hence the term pseudo-bulk replicates. "],
["how-does-archr-make-pseudo-bulk-replicates.html", "9.1 How does ArchR make Pseudo-bulk Replicates?", " 9.1 How does ArchR make Pseudo-bulk Replicates? To create these pseudo-bulk replicates, ArchR employs a tiered priority approach. The user specifies (i) the minimum and maximum number of replicates desired, (ii) the minimum and maximum number of cells per replicate, and (iii) the sampling ratio to use if a particular grouping lacks sufficient cells to make the desired replicates. For example, a sampling ratio of 0.8 means that cells can be sampled without replacement up to 80% of the total number of cells for each replicate (this will result in sampling with replacement across replicates). In this case, multiple replicates may contain some of the same cells but this is a necessary sacrifice if you would like to generate pseudo-bulk replicates from a cell group that lacks sufficient cells. We describe the pseudo-bulk replicate generation process in a decision tree below and outline some of the key considerations in words here. First, the user identifies the cell groups to be used - this is often the clusters called by ArchR. Then for each cell grouping, ArchR attempts to create the desired pseudo-bulk replicates. The ideal pseudo-bulk replicate would consist of a sufficient number of cells from a single sample. This maintains sample diversity and biological variation in the replicates. This is what ArchR strives to obtain, but in reality there are 5 possible outcomes in this process, ranked below by preference in ArchR: Enough different samples (at least the max # replicates) each have more than the minimum number of cells to create pseudo-bulk replicates in a sample-aware fashion, combining only cells from the same sample into a single replicate. Some samples each have more than the minimum number of cells to create pseudo-bulk replicates in a sample-aware fashion. The remaing required replicates are created by combining cells without replacement from samples that are not already represented in the sample-aware pseudobulks. No samples have more than the minimum number of cells to create a sample-aware pseudo-bulk replicate but there are more cells than minCells * minReps. All required replicates are created by combining cells without replacement from in a sample-agnostic fashion. The total number of cells within a cell grouping is less than the minimum number of cells multiplied by the minimum number of replicates but greater than the minimum number of cells divided by the sampling ratio. Create the minimum number of replicates by sampling without replacement within a single replicate but with replacement across replicates while minimizing the number of cells present in multiple pseudo-bulk replicates. The total number of cells within a cell grouping is less than the minimum number of cells divided by the sampling ratio. This means that we must make replicates by sampling with replacement within a single replicate and across different replicates. This is the worst case scenario and users should be cautious about using these pseudo-bulk replicates downstream. This can be controled in various functions using the minCells parameter. To illustrate this process, we will use the following example data set: Sample Cluster1 Cluster2 Cluster3 Cluster4 Cluster5 A 800 600 900 100 75 B 1000 50 400 150 25 C 600 900 100 200 50 D 1200 500 50 50 25 E 900 100 50 150 50 F 700 200 100 100 25 And we will set minRep = 3, maxRep = 5, minCells = 300, maxCells = 1000, and sampleRatio = 0.8. 9.1.0.1 Cluster1 For Cluster1, we have 6 samples (more than maxRep) that all have more than minCells cells (300 cells). This illustrates Option#1 above and we will make 5 pseudo-bulk replicates in a sample aware fashion like so: Rep1 = 800 cells from SampleA Rep2 = 1000 cells from SampleB Rep3 = 1000 cells from SampleD Rep4 = 900 cells from SampleE Rep5 = 700 cells from SampleF Is this true? would SampleC be left out and SampleF used because it has more cells? There are two things to note about these replicates: (i) SampleC was left out because we had more than enough samples to make maxRep sample-aware pseudo-bulk replicates and SampleC had the fewest number of cells. (ii) Only 1000 cells were used from SampleD because this is the maxCells value. 9.1.0.2 Cluster2 For Cluster2, we have 3 samples that all have more than minCells cells and a few additional samples that do not. This illustrates Option#2 above and we will make the following pseudo-bulk replicates: Rep1 = 600 cells from SampleA Rep2 = 900 cells from SampleC Rep3 = 500 cells from SampleD Rep4 = 350 cells [50 cells from SampleB + 100 from SampleE + 200 from SampleF] In this example, Rep4 gets created in a samaple agnostic fashion by sampling without replacement. 9.1.0.3 Cluster3 For Cluster3, we only have 2 samples that have more than minCells cells which is less than the required minReps. However, if we combine the cells from the remaining samples, we can make one additional replicate with more than minCells. This gives us a total of 3 pseudo-bulk replicates and represents the situation illustrated by Option#3 above. We will make the following replicates: Rep1 = 900 cells from SampleA Rep2 = 400 cells from SampleB Rep3 = 250 cells [100 cells from SampleC + 50 from SampleD + 50 from SampleE + 50 from SampleF] Similar to Cluster2 above, Cluster3 Rep3 is created in a sample agnostic fashion by sampling without replacement across multiple samples. 9.1.0.4 Cluster4 For Cluster4, the total number of cells is 750 which is less than minCells * minReps (900 cells). In this case, we do not have sufficient cells to make minReps with at least minCells without some form of sampling with replacement. However, the total cells is still greater than minCells / sampleRatio (375 cells) which means that we only have to sample with replacement across different pseudo-bulk replicates, not within a single replicate. This represents the situation illustrated in Option#4 above and we will therefore make the following replicates: Rep1 = 300 cells [250 unique cells + 25 cells overlapping Rep2 + 25 cells overlapping Rep3] Rep2 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep3] Rep3 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep2] In this case, ArchR will minimize the number of cells that overlap between any two pseudo-bulk replicates. 9.1.0.5 Cluster5 For Cluster5, the total number of cells is 250 which is less than minCells * minReps (900 cells) and less than minCells / sampleRatio (375 cells). This means that we we will have to sample with replacement within each sample and across different replicates to make pseudo-bulk replicates. This represents the least desirable situation illustrated in Option#5 above and we should therefore be cautious in using these pseudo-bulk replicates in downstream analyses. We will therefore make the following replicates: Rep1 = 300 cells [250 unique cells + 25 cells overlapping Rep2 + 25 cells overlapping Rep3] Rep2 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep3] Rep3 = 300 cells [250 unique cells + 25 cells overlapping Rep1 + 25 cells overlapping Rep2] 9.1.0.6 Pseudo-bulk Replicate Decision Tree "],
["example.html", "9.2 Example", " 9.2 Example "],
["calling-peaks-with-archr.html", "Chapter 10 Calling Peaks with ArchR", " Chapter 10 Calling Peaks with ArchR We first introduced a strategy for iterative peak merging in 2018 (Corces* &amp; Granja* et al. Science 2018 - See Supplementary Methods). Other peak merging strategies suffer from a few key issues that we outline below. 10.0.0.1 Fixed-width vs Variable-width Peaks We use 501-bp fixed-width peaks because they make downstream computation easier as peak length does not need to be normalized. Moreover, the vast majority of peaks in ATAC-seq are less than 501-bp wide. Using variable-width peaks also makes it difficult to merge peak calls from multiple samples. In general, we do not feel that the potential benefit derived from using variable-width peaks outweighs the costs. More broadly, most analyses are stable with respect to the peak set or peak style used. Below, we use the same toy example of a few cell types with a few different peaks to illustrate the differences between these often used peak merging methods. 10.0.0.2 Raw Peak Overlap Using bedtools merge Raw peak overlap involves taking any peaks that overlap each other and merging these into a single larger peak. In this scheme, daisy-chaining becomes a large problem because peaks that dont directly overlap each other get included in the same larger peak because they are bridged by a shared internal peak. Another problem with this type of approach is that, if you want to keep track of peak summits, you are forced to pick a single summit for this each new merged peak. 10.0.0.3 Clustered Overlap Using bedtools cluster Clustered overlap takes peaks that cluster together and picks a single winner. This is often done by using bedtools cluster and then keeping the most significant peak in each cluster. In our experience, this ends up under-calling and misses smaller peaks located nearby. 10.0.0.4 Iterative Overlap In ArchR Iterative overlap removal avoids the issues mentioned above. Peaks are first ranked by their significance. The most significant peak is retained and any peak that directly overlaps with the most significant peak is removed from further analysis. Then, of the remaining peaks, this process is repeated until no more peaks exist. This avoids daisy-chaining and still allows for use of fixed-width peaks. It is important to note that we use a normalized metric of significance for peaks because the reported MACS2 significance is proportional to the sequencing depth. 10.0.1 Comparison of Peak Calling Methods Comparing the peak calls resulting from all of these methods directly shows clear differences in the final peak sets. It is our opinion that the iterative overlap peak merging process yields the best peak set with the fewest caveats. 10.0.2 What if I don’t like this iterative overlap peak merging process? The iterative overlap peak merging process is implemented by ArchR via addReproduciblePeakSet() but you can always use your own peak set via ArchRProj &lt;- addPeakSet(...). "],
["calling-peaks-w-macs2.html", "10.1 Calling Peaks w/ Macs2", " 10.1 Calling Peaks w/ Macs2 We can now save our original projHeme3 using saveArchRProject from ArchR. saveArchRProject(ArchRProj = projHeme3, outputDirectory = &quot;Save-ProjHeme3&quot;, load = FALSE) ## Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme3 ## Copying Arrow Files… ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights… ## Copying Other Files… ## Copying Other Files (1 of 4): Embeddings ## Copying Other Files (2 of 4): IterativeLSI ## Copying Other Files (3 of 4): IterativeLSI2 ## Copying Other Files (4 of 4): Plots ## Saving ArchRProject… #Create Group Coverage Files that can be used for downstream analysis (~5-10 minutes) projHeme4 &lt;- addGroupCoverages(ArchRProj = projHeme3, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-addGroupCoverages-faba40cd6ba1-Date-2020-04-15_Time-10-23-14.log ## If there is an issue, please report to github with logFile! ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## B CellGroups N = 2CD4.M CellGroups N = 2CD4.N CellGroups N = 2CLP CellGroups N = 2Erythroid CellGroups N = 2GMP CellGroups N = 2Mono CellGroups N = 2NK CellGroups N = 2pDC CellGroups N = 2PreB CellGroups N = 2Progenitor CellGroups N = 2 ## 2020-04-15 10:23:17 : Creating Coverage Files!, 0.046 mins elapsed. ## 2020-04-15 10:23:17 : Batch Execution w/ safelapply!, 0.046 mins elapsed. ## 2020-04-15 10:24:14 : Adding Kmer Bias to Coverage Files!, 0.996 mins elapsed. ## ## Completed Kmer Bias Calculation ## Adding Kmer Bias (1 of 22) ## Adding Kmer Bias (2 of 22) ## Adding Kmer Bias (3 of 22) ## Adding Kmer Bias (4 of 22) ## Adding Kmer Bias (5 of 22) ## Adding Kmer Bias (6 of 22) ## Adding Kmer Bias (7 of 22) ## Adding Kmer Bias (8 of 22) ## Adding Kmer Bias (9 of 22) ## Adding Kmer Bias (10 of 22) ## Adding Kmer Bias (11 of 22) ## Adding Kmer Bias (12 of 22) ## Adding Kmer Bias (13 of 22) ## Adding Kmer Bias (14 of 22) ## Adding Kmer Bias (15 of 22) ## Adding Kmer Bias (16 of 22) ## Adding Kmer Bias (17 of 22) ## Adding Kmer Bias (18 of 22) ## Adding Kmer Bias (19 of 22) ## Adding Kmer Bias (20 of 22) ## Adding Kmer Bias (21 of 22) ## Adding Kmer Bias (22 of 22) ## 2020-04-15 10:25:16 : Finished Creation of Coverage Files!, 2.022 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addGroupCoverages-faba40cd6ba1-Date-2020-04-15_Time-10-23-14.log #Find Path to Macs2 binary. This function sometimes struggles if you are using conda environment #for installation of python packages. If this function fails try providing a direct path manually pathToMacs2 &lt;- findMacs2() ## Searching For MACS2.. ## Found with $path! #Call Reproducible Peaks w/ Macs2 (~5-10 minutes) projHeme4 &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters2&quot;, pathToMacs2 = pathToMacs2 ) ## ArchR logging to : ArchRLogs/ArchR-addReproduciblePeakSet-faba719c230c-Date-2020-04-15_Time-10-25-16.log ## If there is an issue, please report to github with logFile! ## Calling Peaks with Macs2 ## 2020-04-15 10:25:17 : Peak Calling Parameters!, 0.014 mins elapsed. ## Group nCells nCellsUsed nReplicates nMin nMax maxPeaks ## B B 439 433 2 182 251 150000 ## CD4.M CD4.M 678 617 2 117 500 150000 ## CD4.N CD4.N 1271 552 2 52 500 150000 ## CLP CLP 387 387 2 82 305 150000 ## Erythroid Erythroid 879 694 2 194 500 150000 ## GMP GMP 793 751 2 251 500 150000 ## Mono Mono 2632 1000 2 500 500 150000 ## NK NK 851 801 2 301 500 150000 ## pDC pDC 320 311 2 150 161 150000 ## PreB PreB 351 351 2 40 311 150000 ## Progenitor Progenitor 1650 672 2 172 500 150000 ## 2020-04-15 10:25:17 : Batching Peak Calls!, 0.014 mins elapsed. ## 2020-04-15 10:25:17 : Batch Execution w/ safelapply!, 0 mins elapsed. ## 2020-04-15 10:27:01 : Identifying Reproducible Peaks!, 1.74 mins elapsed. ## 2020-04-15 10:27:09 : Creating Union Peak Set!, 1.886 mins elapsed. ## Converged after 7 iterations! ## [1] “plotting ggplot!” ## 2020-04-15 10:27:15 : Finished Creating Union Peak Set (144009)!, 1.98 mins elapsed. getPeakSet(projHeme4) ## GRanges object with 144009 ranges and 12 metadata columns: ## seqnames ranges strand | score ## | ## Mono chr1 752499-752999 * | 24.54003 ## NK chr1 762651-763151 * | 141.22064 ## B chr1 801006-801506 * | 14.18461 ## B chr1 805039-805539 * | 37.30365 ## CLP chr1 845325-845825 * | 2.81281 ## … … … … . … ## Erythroid chrX 154664540-154665040 * | 7.09786 ## NK chrX 154807324-154807824 * | 9.38477 ## PreB chrX 154840785-154841285 * | 3.29501 ## PreB chrX 154842404-154842904 * | 7.68692 ## NK chrX 154862017-154862517 * | 12.44 ## replicateScoreQuantile groupScoreQuantile Reproducibility ## ## Mono 0.812 0.655 2 ## NK 0.887 0.797 2 ## B 0.7 0.418 2 ## B 0.959 0.9 2 ## CLP 0.706 0.311 2 ## … … … … ## Erythroid 0.69 0.279 2 ## NK 0.424 0.166 2 ## PreB 0.669 0.274 2 ## PreB 0.932 0.772 2 ## NK 0.492 0.202 2 ## GroupReplicate distToGeneStart nearestGene peakType ## ## Mono Mono._.scATAC_PBMC_R1 10152 LINC00115 Distal ## NK NK._.scATAC_PBMC_R1 0 LINC00115 Promoter ## B B._.scATAC_PBMC_R1 10925 FAM41C Distal ## B B._.scATAC_BMMC_R1 6892 FAM41C Intronic ## CLP CLP._.scATAC_BMMC_R1 9241 LINC02593 Distal ## … … … … … ## Erythroid Erythroid._.scATAC_BMMC_R1 100803 CLIC2 Distal ## NK NK._.scATAC_PBMC_R1 35047 TMLHE Intronic ## PreB PreB._.Rep2 1586 TMLHE Intronic ## PreB PreB._.Rep2 31 TMLHE Promoter ## NK NK._.scATAC_PBMC_R1 19644 TMLHE Distal ## distToTSS nearestTSS GC idx ## ## Mono 10152 uc001aau.3 0.483 1 ## NK 0 uc001aau.3 0.6906 2 ## B 10925 uc021oei.1 0.4371 3 ## B 6892 uc021oei.1 0.7285 4 ## CLP 1239 uc010nxu.2 0.7904 5 ## … … … … … ## Erythroid 22387 uc004cim.2 0.515 3462 ## NK 35047 uc004cin.3 0.525 3463 ## PreB 1586 uc004cin.3 0.485 3464 ## PreB 31 uc004cin.3 0.5888 3465 ## NK 19644 uc004cin.3 0.4212 3466 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths "],
["calling-peaks-w-tilematrix.html", "10.2 Calling Peaks w/ TileMatrix", " 10.2 Calling Peaks w/ TileMatrix #Call Reproducible Peaks w/ TileMatrix (~2 minutes) projHemeTmp &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters2&quot;, peakMethod = &quot;Tiles&quot;, method = &quot;p&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addReproduciblePeakSet-faba49485623-Date-2020-04-15_Time-10-27-15.log ## If there is an issue, please report to github with logFile! ## Calling Peaks with TileMatrix ## Group Coverages Already Computed Returning Groups, Set force = TRUE to Recompute! ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor ## 2020-04-15 10:27:16 : Peak Calling Parameters!, 0.012 mins elapsed. ## Group nCells nCellsUsed nReplicates nMin nMax maxPeaks ## B B 439 433 2 182 251 150000 ## CD4.M CD4.M 678 617 2 117 500 150000 ## CD4.N CD4.N 1271 552 2 52 500 150000 ## CLP CLP 387 387 2 82 305 150000 ## Erythroid Erythroid 879 694 2 194 500 150000 ## GMP GMP 793 751 2 251 500 150000 ## Mono Mono 2632 1000 2 500 500 150000 ## NK NK 851 801 2 301 500 150000 ## pDC pDC 320 311 2 150 161 150000 ## PreB PreB 351 351 2 40 311 150000 ## Progenitor Progenitor 1650 672 2 172 500 150000 ## 2020-04-15 10:27:24 : Computing Total Accessibility Across All Features, 0.138 mins elapsed. ## 2020-04-15 10:27:27 : Computing Pseudo-Grouped Tile Matrix, 0.19 mins elapsed. ## 2020-04-15 10:28:07 : Created Pseudo-Grouped Tile Matrix (0.474 GB), 0.866 mins elapsed. ## Expectation = 0.137769200114613Expectation = 0.170233276575844Expectation = 0.502430087836881Expectation = 0.0743484690298421Expectation = 0.231170400914268Expectation = 0.0293481232153502Expectation = 0.188425424281447Expectation = 0.0412872862125409Expectation = 0.369108556109225Expectation = 0.120760726012825Expectation = 0.33554874172927Expectation = 0.330837760307742Expectation = 0.41068352704434Expectation = 0.343789007051322Expectation = 0.571660173038985Expectation = 0.180700422552374Expectation = 0.126306931769154Expectation = 0.107652051338631Expectation = 0.200607316117261Expectation = 0.0248573103536859Expectation = 0.38762741617292Expectation = 0.0990605372969163 ## 2020-04-15 10:28:51 : Creating Group Peak Sets with Annotations!, 1.59 mins elapsed. ## 2020-04-15 10:29:03 : Creating Union Peak Set with Annotations!, 1.789 mins elapsed. ## Annotating Peaks : Nearest Gene ## Annotating Peaks : Gene ## Annotating Peaks : TSS ## Annotating Peaks : GC ## [1] “plotting ggplot!” ## 2020-04-15 10:29:22 : Finished Creating Union Peak Set (271917)!, 2.104 mins elapsed. getPeakSet(projHemeTmp) ## GRanges object with 271917 ranges and 9 metadata columns: ## seqnames ranges strand | mlog10p Group ## | ## [1] chr1 752000-752499 * | 0.742 Mono ## [2] chr1 752500-752999 * | 6.561 Mono ## [3] chr1 758500-758999 * | 1.11 NK ## [4] chr1 762000-762499 * | 2.461 NK ## [5] chr1 762500-762999 * | 22.536 NK ## … … … … . … … ## [271913] chrX 154862000-154862499 * | 1.966 NK ## [271914] chrX 154862500-154862999 * | 1.334 NK ## [271915] chrX 154912500-154912999 * | 2.01 Erythroid ## [271916] chrX 154997000-154997499 * | 1.349 Progenitor ## [271917] chrX 154998000-154998499 * | 1.227 Mono ## distToGeneStart nearestGene peakType distToTSS nearestTSS ## ## [1] 10652 LINC00115 Distal 10652 uc001aau.3 ## [2] 10152 LINC00115 Distal 10152 uc001aau.3 ## [3] 4152 LINC00115 Distal 4152 uc001aau.3 ## [4] 652 LINC00115 Promoter 652 uc001aau.3 ## [5] 152 LINC00115 Promoter 152 uc001aau.3 ## … … … … … … ## [271913] 19626 TMLHE Distal 19626 uc004cin.3 ## [271914] 20126 TMLHE Distal 20126 uc004cin.3 ## [271915] 70126 TMLHE Distal 70126 uc004cin.3 ## [271916] 154626 TMLHE Distal 201 uc004cin.3 ## [271917] 155626 TMLHE Distal 797 uc004cin.3 ## GC idx ## ## [1] 0.376 1 ## [2] 0.484 2 ## [3] 0.56 3 ## [4] 0.574 4 ## [5] 0.684 5 ## … … … ## [271913] 0.43 6212 ## [271914] 0.42 6213 ## [271915] 0.368 6214 ## [271916] 0.542 6215 ## [271917] 0.476 6216 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Lets see how well this compares to Macs2 #Peak Overlap length(subsetByOverlaps(getPeakSet(projHeme4), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) ## [1] 0.9627246 length(subsetByOverlaps(getPeakSet(projHemeTmp), getPeakSet(projHeme4))) / length(getPeakSet(projHemeTmp)) ## [1] 0.7533365 #Extend to 1kb length(subsetByOverlaps(resize(getPeakSet(projHeme4), 1000, &quot;center&quot;), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) ## [1] 0.9676687 length(subsetByOverlaps(getPeakSet(projHemeTmp), resize(getPeakSet(projHeme4), 1000, &quot;center&quot;))) / length(getPeakSet(projHemeTmp)) ## [1] 0.8287639 "],
["add-peak-matrix.html", "10.3 Add Peak Matrix", " 10.3 Add Peak Matrix We can now save our original projHeme4 using saveArchRProject from ArchR. saveArchRProject(ArchRProj = projHeme4, outputDirectory = &quot;Save-ProjHeme4&quot;, load = FALSE) ## Copying ArchRProject to new outputDirectory : /oak/stanford/groups/howchang/users/jgranja/ArchRTutorial/ArchRBook/BookOutput4/Save-ProjHeme4 ## Copying Arrow Files… ## Copying Arrow Files (1 of 3) ## Copying Arrow Files (2 of 3) ## Copying Arrow Files (3 of 3) ## Getting ImputeWeights ## Dropping ImputeWeights… ## Copying Other Files… ## Copying Other Files (1 of 6): Embeddings ## Copying Other Files (2 of 6): GroupCoverages ## Copying Other Files (3 of 6): IterativeLSI ## Copying Other Files (4 of 6): IterativeLSI2 ## Copying Other Files (5 of 6): PeakCalls ## Copying Other Files (6 of 6): Plots ## Saving ArchRProject… getPeakSet(projHeme4) ## GRanges object with 144009 ranges and 12 metadata columns: ## seqnames ranges strand | score ## | ## Mono chr1 752499-752999 * | 24.54003 ## NK chr1 762651-763151 * | 141.22064 ## B chr1 801006-801506 * | 14.18461 ## B chr1 805039-805539 * | 37.30365 ## CLP chr1 845325-845825 * | 2.81281 ## … … … … . … ## Erythroid chrX 154664540-154665040 * | 7.09786 ## NK chrX 154807324-154807824 * | 9.38477 ## PreB chrX 154840785-154841285 * | 3.29501 ## PreB chrX 154842404-154842904 * | 7.68692 ## NK chrX 154862017-154862517 * | 12.44 ## replicateScoreQuantile groupScoreQuantile Reproducibility ## ## Mono 0.812 0.655 2 ## NK 0.887 0.797 2 ## B 0.7 0.418 2 ## B 0.959 0.9 2 ## CLP 0.706 0.311 2 ## … … … … ## Erythroid 0.69 0.279 2 ## NK 0.424 0.166 2 ## PreB 0.669 0.274 2 ## PreB 0.932 0.772 2 ## NK 0.492 0.202 2 ## GroupReplicate distToGeneStart nearestGene peakType ## ## Mono Mono._.scATAC_PBMC_R1 10152 LINC00115 Distal ## NK NK._.scATAC_PBMC_R1 0 LINC00115 Promoter ## B B._.scATAC_PBMC_R1 10925 FAM41C Distal ## B B._.scATAC_BMMC_R1 6892 FAM41C Intronic ## CLP CLP._.scATAC_BMMC_R1 9241 LINC02593 Distal ## … … … … … ## Erythroid Erythroid._.scATAC_BMMC_R1 100803 CLIC2 Distal ## NK NK._.scATAC_PBMC_R1 35047 TMLHE Intronic ## PreB PreB._.Rep2 1586 TMLHE Intronic ## PreB PreB._.Rep2 31 TMLHE Promoter ## NK NK._.scATAC_PBMC_R1 19644 TMLHE Distal ## distToTSS nearestTSS GC idx ## ## Mono 10152 uc001aau.3 0.483 1 ## NK 0 uc001aau.3 0.6906 2 ## B 10925 uc021oei.1 0.4371 3 ## B 6892 uc021oei.1 0.7285 4 ## CLP 1239 uc010nxu.2 0.7904 5 ## … … … … … ## Erythroid 22387 uc004cim.2 0.515 3462 ## NK 35047 uc004cin.3 0.525 3463 ## PreB 1586 uc004cin.3 0.485 3464 ## PreB 31 uc004cin.3 0.5888 3465 ## NK 19644 uc004cin.3 0.4212 3466 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths #~1-2 Minutes projHeme5 &lt;- addPeakMatrix(projHeme4) ## ArchR logging to : ArchRLogs/ArchR-addPeakMatrix-faba377aa2f2-Date-2020-04-15_Time-10-29-40.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 10:29:41 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeakMatrix-faba377aa2f2-Date-2020-04-15_Time-10-29-40.log getAvailableMatrices(projHeme5) ## [1] “GeneIntegrationMatrix” “GeneScoreMatrix” “PeakMatrix” ## [4] “TileMatrix” "],
["identifying-marker-peaks-with-archr.html", "Chapter 11 Identifying Marker Peaks with ArchR ", " Chapter 11 Identifying Marker Peaks with ArchR "],
["identifying-marker-peaks-with-archr-1.html", "11.1 Identifying Marker Peaks with ArchR", " 11.1 Identifying Marker Peaks with ArchR Often times, we are interested to know which peaks are unique to an individual cluster or a small group of clusters. We can do this in an unsupervised fashion in ArchR: addArchRThreads(8) ## Setting default number of Parallel threads to 8. #Our scRNA labels table(projHeme5$Clusters2) ## ## B CD4.M CD4.N CLP Erythroid GMP Mono ## 439 678 1271 387 879 793 2632 ## NK pDC PreB Progenitor ## 851 320 351 1650 #Identify Marker Peaks while controling for TSS and Depth Biases markersPeaks &lt;- getMarkerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-ff9f78e54080-Date-2020-04-15_Time-10-31-43.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Integer.Matrix ## 2020-04-15 10:31:44 : Matching Known Biases, 0.011 mins elapsed. ## ## ########### ## 2020-04-15 10:33:02 : Completed Pairwise Tests, 1.301 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-ff9f78e54080-Date-2020-04-15_Time-10-31-43.log markersPeaks ## class: SummarizedExperiment ## dim: 144009 11 ## metadata(2): MatchInfo Params ## assays(6): Log2FC Mean … AUC MeanBGD ## rownames(144009): 1 2 … 144008 144009 ## rowData names(4): seqnames idx start end ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): We can get the peak regions for each marker as DataFrame or GRanges. #DataFrame markerList &lt;- getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;) markerList ## List of length 11 ## names(11): B CD4.M CD4.N CLP Erythroid GMP Mono NK pDC PreB Progenitor markerList$Erythroid ## DataFrame with 2267 rows and 7 columns ## seqnames idx start end Log2FC ## ## 6915 chr1 6915 110407005 110407505 6.13156087199941 ## 89187 chr22 1265 30129827 30130327 4.31793618061602 ## 2715 chr1 2715 27869127 27869627 8.81830883930008 ## 9273 chr1 9273 164681433 164681933 4.09761463117515 ## 46278 chr15 2875 74902688 74903188 5.94807465189627 ## … … … … … … ## 124072 chr7 2640 47608032 47608532 1.57044726023651 ## 13738 chr1 13738 248018421 248018921 2.18899218987721 ## 90192 chr22 2270 39632393 39632893 2.09633755722991 ## 30353 chr12 2227 47600919 47601419 1.98865307113263 ## 51935 chr16 3926 70729551 70730051 2.33056750082649 ## FDR MeanDiff ## ## 6915 8.5785377923846e-15 0.908051252811916 ## 89187 1.00297518036045e-13 1.0458579648286 ## 2715 3.96321274318867e-12 0.908093680025248 ## 9273 3.96321274318867e-12 0.743482307090926 ## 46278 3.96321274318867e-12 0.739990672777532 ## … … … ## 124072 0.00939699723029238 0.345440715489147 ## 13738 0.00940220652828868 0.214851028991864 ## 90192 0.00960407719383025 0.270261700407864 ## 30353 0.00978687988910092 0.348162927084217 ## 51935 0.00982181746221214 0.327156785147329 #GRanges markerList &lt;- getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE) markerList ## GRangesList object of length 11: ## $B ## GRanges object with 594 ranges and 3 metadata columns: ## seqnames ranges strand | Log2FC ## | ## [1] chr2 232537191-232537691 * | 4.60006288742652 ## [2] chr12 92566305-92566805 * | 4.3389825818619 ## [3] chr3 13152070-13152570 * | 4.44200650760392 ## [4] chr9 37409171-37409671 * | 3.32811859032542 ## [5] chr1 160759469-160759969 * | 5.66666023794885 ## … … … … . … ## [590] chr8 128222178-128222678 * | 6.1639699924098 ## [591] chr9 93643862-93644362 * | 6.57677988412609 ## [592] chrX 6656761-6657261 * | 6.4417508983755 ## [593] chr14 81425876-81426376 * | 4.62521198459712 ## [594] chr7 63765291-63765791 * | 4.10893943379989 ## FDR MeanDiff ## ## [1] 1.61183300601365e-12 1.09207677080711 ## [2] 9.91817474781581e-10 0.993976831608143 ## [3] 4.25560916639498e-09 1.20028559994278 ## [4] 1.45797719387195e-08 1.03421998926309 ## [5] 1.58046323198917e-08 0.80285226332275 ## … … … ## [590] 0.0098441599959607 0.20375624865997 ## [591] 0.0098441599959607 0.27221052581318 ## [592] 0.0098441599959607 0.247631445395118 ## [593] 0.00994427516588697 0.432810696716752 ## [594] 0.00998116335641915 0.326535661912967 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths ## ## … ## &lt;10 more elements&gt; markerList$Erythroid ## GRanges object with 2267 ranges and 3 metadata columns: ## seqnames ranges strand | Log2FC ## | ## [1] chr1 110407005-110407505 * | 6.13156087199941 ## [2] chr22 30129827-30130327 * | 4.31793618061602 ## [3] chr1 27869127-27869627 * | 8.81830883930008 ## [4] chr1 164681433-164681933 * | 4.09761463117515 ## [5] chr15 74902688-74903188 * | 5.94807465189627 ## … … … … . … ## [2263] chr7 47608032-47608532 * | 1.57044726023651 ## [2264] chr1 248018421-248018921 * | 2.18899218987721 ## [2265] chr22 39632393-39632893 * | 2.09633755722991 ## [2266] chr12 47600919-47601419 * | 1.98865307113263 ## [2267] chr16 70729551-70730051 * | 2.33056750082649 ## FDR MeanDiff ## ## [1] 8.5785377923846e-15 0.908051252811916 ## [2] 1.00297518036045e-13 1.0458579648286 ## [3] 3.96321274318867e-12 0.908093680025248 ## [4] 3.96321274318867e-12 0.743482307090926 ## [5] 3.96321274318867e-12 0.739990672777532 ## … … … ## [2263] 0.00939699723029238 0.345440715489147 ## [2264] 0.00940220652828868 0.214851028991864 ## [2265] 0.00960407719383025 0.270261700407864 ## [2266] 0.00978687988910092 0.348162927084217 ## [2267] 0.00982181746221214 0.327156785147329 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths We can visualize this as a heatmap #Visualize Markers as a heatmap heatmapPeaks &lt;- markerHeatmap( seMarker = markersPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot;, transpose = TRUE ) ## Identified 40034 markers! ## Preparing Main Heatmap.. draw(heatmapPeaks, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapPeaks, name = &quot;Peak-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 We can also plot an MA/Volcano Plot for any individual cluster #Marker Peaks for Erythroid pma &lt;- markerPlot(seMarker = markersPeaks, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma ## Warning: Removed 55 rows containing missing values (geom_point_rast). pv &lt;- markerPlot(seMarker = markersPeaks, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv ## Warning: Removed 55 rows containing missing values (geom_point_rast). We can then plot this as a nice pdf plotPDF(pma, pv, name = &quot;Erythroid-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## [1] “plotting ggplot!” ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## Warning: Removed 55 rows containing missing values (geom_point_rast). ## [1] 0 Additionally we can see these peak regions overlayed on our browser tracks p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = c(&quot;GATA1&quot;), features = getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE)[&quot;Erythroid&quot;], upstream = 50000, downstream = 50000 ) ## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-ff9f580fdbcb-Date-2020-04-15_Time-10-35-20.log ## If there is an issue, please report to github with logFile! ## Warning: ‘GenomicRangesList’ is deprecated. ## Use ‘GRangesList(…, compress=FALSE)’ instead. ## See help(“Deprecated”) ## 2020-04-15 10:35:23 : Validating Region, 0.045 mins elapsed. ## GRanges object with 1 range and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chrX 48644982-48652717 + | 2623 GATA1 ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 10:35:23 : Adding Bulk Tracks (1 of 1), 0.047 mins elapsed. ## 2020-04-15 10:35:26 : Adding Feature Tracks (1 of 1), 0.095 mins elapsed. ## 2020-04-15 10:35:26 : Adding Gene Tracks (1 of 1), 0.1 mins elapsed. ## 2020-04-15 10:35:27 : Plotting, 0.109 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-ff9f580fdbcb-Date-2020-04-15_Time-10-35-20.log grid::grid.newpage() grid::grid.draw(p$GATA1) We can then plot this as a nice pdf plotPDF(p, name = &quot;Plot-Tracks-With-Features&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## NULL ## [1] 0 "],
["pairwise-testing-groups.html", "11.2 Pairwise Testing Groups", " 11.2 Pairwise Testing Groups #Pairwise Test between Erythroid Cells (Cluster5) and Early Progenitors (HSC) markerTest &lt;- markerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, testMethod = &quot;wilcoxon&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), useGroups = &quot;Erythroid&quot;, bgdGroups = &quot;Progenitor&quot; ) ## Warning: ‘markerFeatures’ is deprecated. ## Use ‘getMarkerFeatures’ instead. ## See help(“Deprecated”) ## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-ff9f77b592d7-Date-2020-04-15_Time-10-35-37.log ## If there is an issue, please report to github with logFile! ## MatrixClass = Sparse.Integer.Matrix ## 2020-04-15 10:35:41 : Matching Known Biases, 0.057 mins elapsed. ## ## 2020-04-15 10:35:44 : Computing Pairwise Tests (1 of 1), 0.107 mins elapsed. ## ########### ## 2020-04-15 10:36:13 : Completed Pairwise Tests, 0.584 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-ff9f77b592d7-Date-2020-04-15_Time-10-35-37.log We can then plot an MA/Volcano Plot #Marker Peaks for Erythroid pma &lt;- markerPlot(seMarker = markerTest, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma ## Warning: Removed 57 rows containing missing values (geom_point_rast). pv &lt;- markerPlot(seMarker = markerTest, name = &quot;Erythroid&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv ## Warning: Removed 57 rows containing missing values (geom_point_rast). We can then plot this as a nice pdf plotPDF(pma, pv, name = &quot;Erythroid-vs-Progenitor-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## [1] “plotting ggplot!” ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## Warning: Removed 57 rows containing missing values (geom_point_rast). ## [1] 0 We can look for enriched motifs (see next chapter for more details) #Add Motif Peak Annotations if not already added! projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) ## No methods found in package ‘IRanges’ for request: ‘score’ when loading ‘TFBSTools’ ## 2020-04-15 10:38:11 : Gettting Motif Set, Species : Homo sapiens, 0 mins elapsed. ## Using version 2 motifs! ## 2020-04-15 10:38:13 : Finding Motif Positions with motifmatchr!, 0.027 mins elapsed. ## 2020-04-15 10:41:40 : Creating Motif Overlap Matrix, 3.48 mins elapsed. ## 2020-04-15 10:41:43 : Finished Getting Motif Info!, 3.523 mins elapsed. #Identify Motif Enrichments motifsUp &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:41:49 : Computing Enrichments 1 of 1, 0.066 mins elapsed. motifsUp ## class: SummarizedExperiment ## dim: 870 1 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 … TBX18_869 TBX22_870 ## rowData names(0): ## colnames(1): Erythroid ## colData names(0): #Create data.frame df &lt;- data.frame(TF = rownames(motifsUp), mlog10Padj = assay(motifsUp)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) head(df) ## TF mlog10Padj rank ## 388 GATA2_388 535.7098 1 ## 383 GATA1_383 523.8809 2 ## 384 GATA3_384 421.6064 3 ## 385 GATA5_385 407.2538 4 ## 386 GATA4_386 309.7756 5 ## 387 GATA6_387 216.7223 6 #Ggplot ggUp &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(P-adj) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggUp #Identify Motif Enrichments motifsDo &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &lt;= -0.5&quot; ) ## 2020-04-15 10:42:01 : Computing Enrichments 1 of 1, 0.053 mins elapsed. motifsDo ## class: SummarizedExperiment ## dim: 870 1 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 … TBX18_869 TBX22_870 ## rowData names(0): ## colnames(1): Erythroid ## colData names(0): #Create data.frame df &lt;- data.frame(TF = rownames(motifsDo), mlog10Padj = assay(motifsDo)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) head(df) ## TF mlog10Padj rank ## 326 ELF2_326 88.68056 1 ## 733 RUNX1_733 64.00586 2 ## 801 CBFB_801 53.55426 3 ## 732 RUNX2_732 53.14766 4 ## 734 ENSG00000250096_734 53.14766 5 ## 336 SPIB_336 52.79666 6 #Ggplot ggDo &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(FDR) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggDo We can then plot this as a nice pdf plotPDF(ggUp, ggDo, name = &quot;Erythroid-vs-Progenitor-Markers-Motifs-Enriched&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## [1] “plotting ggplot!” ## [1] 0 "],
["peak-annotation-enrichment-with-archr.html", "Chapter 12 Peak Annotation Enrichment with ArchR ", " Chapter 12 Peak Annotation Enrichment with ArchR "],
["motif-enrichment.html", "12.1 Motif Enrichment", " 12.1 Motif Enrichment #Motif Search in Peak Set and add to Peak Annotations if(&quot;Motif&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) } #Identify Motif Enrichments enrichMotifs &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:43:01 : Computing Enrichments 1 of 11, 0.046 mins elapsed. ## 2020-04-15 10:43:01 : Computing Enrichments 2 of 11, 0.058 mins elapsed. ## 2020-04-15 10:43:02 : Computing Enrichments 3 of 11, 0.072 mins elapsed. ## 2020-04-15 10:43:03 : Computing Enrichments 4 of 11, 0.094 mins elapsed. ## 2020-04-15 10:43:04 : Computing Enrichments 5 of 11, 0.103 mins elapsed. ## 2020-04-15 10:43:05 : Computing Enrichments 6 of 11, 0.113 mins elapsed. ## 2020-04-15 10:43:05 : Computing Enrichments 7 of 11, 0.121 mins elapsed. ## 2020-04-15 10:43:06 : Computing Enrichments 8 of 11, 0.13 mins elapsed. ## 2020-04-15 10:43:06 : Computing Enrichments 9 of 11, 0.139 mins elapsed. ## 2020-04-15 10:43:07 : Computing Enrichments 10 of 11, 0.148 mins elapsed. ## 2020-04-15 10:43:08 : Computing Enrichments 11 of 11, 0.17 mins elapsed. enrichMotifs ## class: SummarizedExperiment ## dim: 870 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(870): TFAP2B_1 TFAP2D_2 … TBX18_869 TBX22_870 ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapEM &lt;- enrichHeatmap(enrichMotifs, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapEM, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapEM, name = &quot;Motifs-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 "],
["archr-enrichment.html", "12.2 ArchR Enrichment", " 12.2 ArchR Enrichment 12.2.1 Encode TFBS projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) ## Annotation ArchR-Hg19-v1.Anno does not exist! Downloading.. ## Annotating Chr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X #Identify EncodeTFBS Enrichments enrichEncode &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:43:34 : Computing Enrichments 1 of 11, 0.036 mins elapsed. ## 2020-04-15 10:43:34 : Computing Enrichments 2 of 11, 0.041 mins elapsed. ## 2020-04-15 10:43:34 : Computing Enrichments 3 of 11, 0.047 mins elapsed. ## 2020-04-15 10:43:35 : Computing Enrichments 4 of 11, 0.054 mins elapsed. ## 2020-04-15 10:43:35 : Computing Enrichments 5 of 11, 0.063 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 6 of 11, 0.066 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 7 of 11, 0.071 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 8 of 11, 0.075 mins elapsed. ## 2020-04-15 10:43:36 : Computing Enrichments 9 of 11, 0.079 mins elapsed. ## 2020-04-15 10:43:37 : Computing Enrichments 10 of 11, 0.083 mins elapsed. ## 2020-04-15 10:43:37 : Computing Enrichments 11 of 11, 0.087 mins elapsed. enrichEncode ## class: SummarizedExperiment ## dim: 689 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(689): 1.CTCF-Dnd41… 2.EZH2_39-Dnd41… … ## 688.CTCF-WERI_Rb_1… 689.CTCF-WI_38… ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapEncode &lt;- enrichHeatmap(enrichEncode, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapEncode, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapEncode, name = &quot;EncodeTFBS-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 12.2.2 Bulk ATAC-seq projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) ## Annotating Chr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X #Identify ATAC Enrichments enrichATAC &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:43:53 : Computing Enrichments 1 of 11, 0.027 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 2 of 11, 0.028 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 3 of 11, 0.03 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 4 of 11, 0.034 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 5 of 11, 0.036 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 6 of 11, 0.038 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 7 of 11, 0.04 mins elapsed. ## 2020-04-15 10:43:54 : Computing Enrichments 8 of 11, 0.043 mins elapsed. ## 2020-04-15 10:43:55 : Computing Enrichments 9 of 11, 0.045 mins elapsed. ## 2020-04-15 10:43:55 : Computing Enrichments 10 of 11, 0.047 mins elapsed. ## 2020-04-15 10:43:55 : Computing Enrichments 11 of 11, 0.049 mins elapsed. enrichATAC ## class: SummarizedExperiment ## dim: 96 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(96): Brain_Astrocytes Brain_Excitatory_neurons … Heme_MPP ## Heme_NK ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapATAC &lt;- enrichHeatmap(enrichATAC, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapATAC, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapATAC, name = &quot;ATAC-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 12.2.3 Codex TFBS projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;Codex&quot;) ## Annotating Chr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X #Identify Codex Enrichments enrichCodex &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Codex&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:44:11 : Computing Enrichments 1 of 11, 0.025 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 2 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 3 of 11, 0.029 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 4 of 11, 0.032 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 5 of 11, 0.034 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 6 of 11, 0.035 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 7 of 11, 0.036 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 8 of 11, 0.037 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 9 of 11, 0.038 mins elapsed. ## 2020-04-15 10:44:11 : Computing Enrichments 10 of 11, 0.039 mins elapsed. ## 2020-04-15 10:44:12 : Computing Enrichments 11 of 11, 0.041 mins elapsed. enrichCodex ## class: SummarizedExperiment ## dim: 189 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(189): 1.STAT5-No_drug_(DMSO)… 2.RUNX3-GM12878_cell_fr… … ## 188.TP53-codex_Embryonic… 189.TP53-codex_Embryonic… ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapCodex &lt;- enrichHeatmap(enrichCodex, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapCodex, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapCodex, name = &quot;Codex-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 "],
["custom-enrichment.html", "12.3 Custom Enrichment", " 12.3 Custom Enrichment #Custom Peak Annotations EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) ## 2020-04-15 10:44:23 : Creating Peak Overlap Matrix, 0.036 mins elapsed. #Identify ChIP Enrichments enrichRegions &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) ## 2020-04-15 10:44:25 : Computing Enrichments 1 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 2 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 3 of 11, 0.027 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 4 of 11, 0.028 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 5 of 11, 0.028 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 6 of 11, 0.029 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 7 of 11, 0.029 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 8 of 11, 0.03 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 9 of 11, 0.03 mins elapsed. ## 2020-04-15 10:44:25 : Computing Enrichments 10 of 11, 0.03 mins elapsed. ## 2020-04-15 10:44:26 : Computing Enrichments 11 of 11, 0.033 mins elapsed. enrichRegions ## class: SummarizedExperiment ## dim: 4 11 ## metadata(0): ## assays(10): mlog10Padj mlog10p … CompareFrequency feature ## rownames(4): Encode_K562_GATA1 Encode_GM12878_CEBPB Encode_K562_Ebf1 ## Encode_K562_Pax5 ## rowData names(0): ## colnames(11): B CD4.M … PreB Progenitor ## colData names(0): #Heatmap heatmapRegions &lt;- enrichHeatmap(enrichRegions, n = 7, transpose = TRUE) ## Adding Annotations.. ## Preparing Main Heatmap.. draw(heatmapRegions, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapRegions, name = &quot;Regions-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) ## [1] 0 "],
["chromvar-deviatons-enrichment-with-archr.html", "Chapter 13 ChromVAR Deviatons Enrichment with ArchR ", " Chapter 13 ChromVAR Deviatons Enrichment with ArchR "],
["motif-deviations.html", "13.1 Motif Deviations", " 13.1 Motif Deviations If you have not added motif annotations if(&quot;Motif&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) } If you have not added background peaks projHeme5 &lt;- addBgdPeaks(projHeme5) ## Identifying Background Peaks! ## No methods found in package ‘IRanges’ for request: ‘score’ when loading ‘TFBSTools’ Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-103741bce39ff-Date-2020-04-15_Time-10-45-35.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 10:45:40 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 10:57:19 : Completed Computing Deviations!, 11.734 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-103741bce39ff-Date-2020-04-15_Time-10-45-35.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## ## f388 z 388 GATA2_388 11.9292478607949 -0.034894792575792 ## f155 z 155 CEBPA_155 11.8070700579364 -0.174087405321135 ## f383 z 383 GATA1_383 11.8045825337775 -0.0378306234562619 ## f336 z 336 SPIB_336 11.3432739583017 -0.0819836042460723 ## f385 z 385 GATA5_385 10.8828679211543 -0.036867577013264 ## f651 z 651 SMARCC1_651 10.2885493109675 -0.131812047523969 ## rank ## ## f388 1 ## f155 2 ## f383 3 ## f336 4 ## f385 5 ## f651 6 plotVarDev ## Warning: Removed 1 rows containing missing values (geom_point). We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-Motif-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 1 rows containing missing values (geom_point). ## Warning: Removed 1 rows containing missing values (geom_point). ## [1] 0 If we want to get motif feature names for downstream plotting motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;MotifMatrix&quot;) ## [1] “z:TBX21_780” “z:PAX5_709” “z:IRF4_632” ## [4] “z:GATA1_383” “z:CEBPA_155” “z:EBF1_67” ## [7] “z:SREBF1_22” “deviations:TBX21_780” “deviations:PAX5_709” ## [10] “deviations:IRF4_632” “deviations:GATA1_383” “deviations:CEBPA_155” ## [13] “deviations:EBF1_67” “deviations:SREBF1_22” To get deviation z-scores markerMotifs &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;MotifMatrix&quot;) markerMotifs &lt;- grep(&quot;z:&quot;, markerMotifs, value = TRUE) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;z:SREBF1_22&quot;] markerMotifs ## [1] “z:TBX21_780” “z:PAX5_709” “z:IRF4_632” “z:GATA1_383” “z:CEBPA_155” ## [6] “z:EBF1_67” We can also now plot the distribution of chromVAR deviation scores for each cluster p &lt;- plotGroups(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, colorBy = &quot;MotifMatrix&quot;, name = markerMotifs, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## Getting Matrix Values… ## Getting Matrix Values… ## ## ArchR logging to : ArchRLogs/ArchR-imputeMatrix-103746efc5207-Date-2020-04-15_Time-10-57-40.log ## If there is an issue, please report to github with logFile! ## Using weights on disk ## Using weights on disk ## 1 2 3 4 5 6 To plot all genes we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(seq_along(p), function(x){ if(x != 1){ p[[x]] + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) }else{ p[[x]] + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) } }) do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2, rep(1, length(p2) - 1))),p2)) ## Picking joint bandwidth of 0.0181 ## Picking joint bandwidth of 0.02 ## Picking joint bandwidth of 0.07 ## Picking joint bandwidth of 0.109 ## Picking joint bandwidth of 0.102 ## Picking joint bandwidth of 0.0703 We can then plot this as a nice PDF plotPDF(p, name = &quot;Plot-Groups-Deviations-w-Imputation&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.0181 ## Picking joint bandwidth of 0.0181 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.02 ## Picking joint bandwidth of 0.02 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.07 ## Picking joint bandwidth of 0.07 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.109 ## Picking joint bandwidth of 0.109 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.102 ## Picking joint bandwidth of 0.102 ## [1] “plotting ggplot!” ## Picking joint bandwidth of 0.0703 ## Picking joint bandwidth of 0.0703 ## [1] 0 We can now overlay these motif deviation scores on the UMAP embedding p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;MotifMatrix&quot;, name = sort(markerMotifs), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374bec190f-Date-2020-04-15_Time-10-58-03.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = MotifMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374bec190f-Date-2020-04-15_Time-10-58-03.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneScoreMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA ## [1] “TBX21” “CEBPA” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneScoreMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-1037475e6dc52-Date-2020-04-15_Time-10-58-30.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-1037475e6dc52-Date-2020-04-15_Time-10-58-30.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneIntegrationMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA ## [1] “TBX21” “CEBPA” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneIntegrationMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, continuousSet = &quot;blueYellow&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374438d3144-Date-2020-04-15_Time-10-58-56.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374438d3144-Date-2020-04-15_Time-10-58-56.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) "],
["archr-deviations.html", "13.2 ArchR Deviations", " 13.2 ArchR Deviations 13.2.1 Encode TFBS If you have not added motif annotations if(&quot;EncodeTFBS&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) } Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-10374737762a7-Date-2020-04-15_Time-10-59-20.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 10:59:26 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 11:08:11 : Completed Computing Deviations!, 8.864 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-10374737762a7-Date-2020-04-15_Time-10-59-20.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;EncodeTFBSMatrix&quot;) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars ## ## f222 z 222 222.GATA2_S-K562… 13.6382687713858 ## f41 z 41 41.EZH2_39-NHEK… 12.9150554355261 ## f542 z 542 542.TAL1_SC-K562… 11.5490744327685 ## f584 z 584 584.GATA_1-PBDEFetal… 10.7653053700024 ## f498 z 498 498.GATA_2-K562… 10.2384173319845 ## f44 z 44 44.EZH2_39-NHLF… 9.92292044310219 ## combinedMeans rank ## ## f222 -0.0312421757573656 1 ## f41 0.113221166775704 2 ## f542 -0.0155915927183644 3 ## f584 -0.00997025022971285 4 ## f498 -0.0317577572129743 5 ## f44 0.0707460230932926 6 plotVarDev ## Warning: Removed 7 rows containing missing values (geom_point). We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-EncodeTFBS-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 7 rows containing missing values (geom_point). ## Warning: Removed 7 rows containing missing values (geom_point). ## [1] 0 If we want to get TF feature names for downstream plotting tfs &lt;- c(&quot;GATA_1&quot;, &quot;CEBPB&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) ## [1] “z:584.GATA_1-PBDEFetal…” “z:582.GATA_1-PBDE…” ## [3] “z:497.GATA_1-K562…” “z:477.CEBPB-K562…” ## [5] “z:462.CEBPB-IMR90…” “z:427.CEBPB-HepG2…” ## [7] “z:426.CEBPB-HepG2…” “z:379.CEBPB-HeLa_S3…” ## [9] “z:344.CEBPB-H1_hESC…” “z:293.EBF1_SC-GM12878…” ## [11] “z:278.CEBPB-A549…” “z:213.CEBPB_S-K562…” ## [13] “z:173.CEBPB_S-HepG2…” “z:130.PAX5_C2-GM12892…” ## [15] “z:123.PAX5_C2-GM12891…” “z:102.PAX5_N1-GM12878…” ## [17] “z:101.PAX5_C2-GM12878…” “z:93.IRF4_SC-GM12878…” ## [19] “z:87.EBF1_SC-GM12878…” “z:86.CEBPB_S-GM12878…” ## [21] “deviations:584.GATA_1-PBDEFetal…” “deviations:582.GATA_1-PBDE…” ## [23] “deviations:497.GATA_1-K562…” “deviations:477.CEBPB-K562…” ## [25] “deviations:462.CEBPB-IMR90…” “deviations:427.CEBPB-HepG2…” ## [27] “deviations:426.CEBPB-HepG2…” “deviations:379.CEBPB-HeLa_S3…” ## [29] “deviations:344.CEBPB-H1_hESC…” “deviations:293.EBF1_SC-GM12878…” ## [31] “deviations:278.CEBPB-A549…” “deviations:213.CEBPB_S-K562…” ## [33] “deviations:173.CEBPB_S-HepG2…” “deviations:130.PAX5_C2-GM12892…” ## [35] “deviations:123.PAX5_C2-GM12891…” “deviations:102.PAX5_N1-GM12878…” ## [37] “deviations:101.PAX5_C2-GM12878…” “deviations:93.IRF4_SC-GM12878…” ## [39] “deviations:87.EBF1_SC-GM12878…” “deviations:86.CEBPB_S-GM12878…” To get deviation z-scores markerTFs &lt;- getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) markerTFs &lt;- sort(grep(&quot;z:&quot;, markerTFs, value = TRUE)) TFnames &lt;- stringr::str_split(stringr::str_split(markerTFs, pattern = &quot;\\\\.&quot;, simplify=TRUE)[,2], pattern = &quot;-&quot;, simplify = TRUE)[,1] markerTFs &lt;- markerTFs[!duplicated(TFnames)] markerTFs ## [1] “z:101.PAX5_C2-GM12878…” “z:102.PAX5_N1-GM12878…” ## [3] “z:173.CEBPB_S-HepG2…” “z:278.CEBPB-A549…” ## [5] “z:293.EBF1_SC-GM12878…” “z:497.GATA_1-K562…” ## [7] “z:93.IRF4_SC-GM12878…” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;EncodeTFBSMatrix&quot;, name = markerTFs, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-103747b681a1c-Date-2020-04-15_Time-11-08-26.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = EncodeTFBSMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-103747b681a1c-Date-2020-04-15_Time-11-08-26.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(gsub(&quot;_&quot;,&quot;&quot;,tfs), collapse=&quot;|&quot;), useMatrix = &quot;GeneScoreMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;)] markerRNA ## [1] “TBX21” “CEBPB” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneScoreMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-103747bae5e9f-Date-2020-04-15_Time-11-08-53.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneScoreMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-103747bae5e9f-Date-2020-04-15_Time-11-08-53.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(gsub(&quot;_&quot;,&quot;&quot;,tfs), collapse=&quot;|&quot;), useMatrix = &quot;GeneIntegrationMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA ## [1] “TBX21” “CEBPB” “EBF1” “IRF4” “PAX5” “GATA1” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneIntegrationMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, continuousSet = &quot;blueYellow&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-103746f7eeb66-Date-2020-04-15_Time-11-09-21.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = GeneIntegrationMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-103746f7eeb66-Date-2020-04-15_Time-11-09-21.log #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) 13.2.2 Bulk ATAC-seq If you have not added motif annotations if(&quot;ATAC&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) } Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-103743481be2a-Date-2020-04-15_Time-11-09-46.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 11:09:52 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 11:13:09 : Completed Computing Deviations!, 3.376 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-103743481be2a-Date-2020-04-15_Time-11-09-46.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ATACMatrix&quot;) ## DataFrame with 6 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## ## f22 z 22 IAtlas_T_CD8posCenMem 12.8413703976471 -0.0972946574781075 ## f86 z 86 Heme_CD8 12.5070480860108 -0.079462324469343 ## f85 z 85 Heme_CD4 12.2753260246254 -0.0561621531675016 ## f23 z 23 IAtlas_T_CD8posEffMem 12.2250185804317 -0.104389732164243 ## f21 z 21 IAtlas_T_CD8pos 12.1998071900673 -0.09178088897301 ## f33 z 33 IAtlas_T_Th1Precursor 12.1352640996498 -0.0819315630754632 ## rank ## ## f22 1 ## f86 2 ## f85 3 ## f23 4 ## f21 5 ## f33 6 plotVarDev We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-ATAC-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## [1] 0 If we want to get TF feature names for downstream plotting ATACPeaks &lt;- c(&quot;Heme_HSC&quot;, &quot;Heme_LMPP&quot;, &quot;Heme_Ery&quot;, &quot;Heme_Mono&quot;, &quot;Heme_CD4&quot;, &quot;Heme_CD8&quot;, &quot;Heme_B&quot;, &quot;Heme_NK&quot;, &quot;IAtlas_DC_Plasmacytoid&quot;) getFeatures(projHeme5, select = paste(ATACPeaks, collapse=&quot;|&quot;), useMatrix = &quot;ATACMatrix&quot;) ## [1] “z:Heme_NK” “z:Heme_Mono” ## [3] “z:Heme_LMPP” “z:Heme_HSC” ## [5] “z:Heme_Ery” “z:Heme_CD8” ## [7] “z:Heme_CD4” “z:Heme_B” ## [9] “z:IAtlas_DC_Plasmacytoid” “deviations:Heme_NK” ## [11] “deviations:Heme_Mono” “deviations:Heme_LMPP” ## [13] “deviations:Heme_HSC” “deviations:Heme_Ery” ## [15] “deviations:Heme_CD8” “deviations:Heme_CD4” ## [17] “deviations:Heme_B” “deviations:IAtlas_DC_Plasmacytoid” To get deviation z-scores markerATAC &lt;- getFeatures(projHeme5, select = paste(ATACPeaks, collapse=&quot;|&quot;), useMatrix = &quot;ATACMatrix&quot;) markerATAC &lt;- sort(grep(&quot;z:&quot;, markerATAC, value = TRUE)) markerATAC ## [1] “z:Heme_B” “z:Heme_CD4” ## [3] “z:Heme_CD8” “z:Heme_Ery” ## [5] “z:Heme_HSC” “z:Heme_LMPP” ## [7] “z:Heme_Mono” “z:Heme_NK” ## [9] “z:IAtlas_DC_Plasmacytoid” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ATACMatrix&quot;, name = markerATAC, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-1037416f3cb56-Date-2020-04-15_Time-11-13-23.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = ATACMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 5 6 7 8 9 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-1037416f3cb56-Date-2020-04-15_Time-11-13-23.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) "],
["custom-deviations.html", "13.3 Custom Deviations", " 13.3 Custom Deviations If you have not added motif annotations #Custom Peak Annotations EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) if(&quot;ChIP&quot; %ni% names(projHeme5@peakAnnotation)){ projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) } Add ChromVAR Deviations for Motifs projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot;, force = TRUE ) ## Using Previous Background Peaks! ## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-10374246a529b-Date-2020-04-15_Time-11-13-54.log ## If there is an issue, please report to github with logFile! ## NULL ## 2020-04-15 11:13:59 : Batch Execution w/ safelapply!, 0 mins elapsed. ## ########### ## 2020-04-15 11:14:24 : Completed Computing Deviations!, 0.505 mins elapsed. ## ########### ## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-10374246a529b-Date-2020-04-15_Time-11-13-54.log Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ChIPMatrix&quot;) ## DataFrame with 4 rows and 6 columns ## seqnames idx name combinedVars combinedMeans ## ## f1 z 1 Encode_K562_GATA1 6.33176528990239 -0.0165812177586936 ## f3 z 3 Encode_K562_Ebf1 3.41531511621115 0.0355188580388895 ## f4 z 4 Encode_K562_Pax5 3.24513143947069 -0.00960057929930531 ## f2 z 2 Encode_GM12878_CEBPB 0.822128491900276 0.00742820197777246 ## rank ## ## f1 1 ## f3 2 ## f4 3 ## f2 4 plotVarDev ## Warning: Removed 21 rows containing missing values (geom_label_repel). We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-ChIP-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) ## [1] “plotting ggplot!” ## Warning: Removed 21 rows containing missing values (geom_label_repel). ## Warning: Removed 21 rows containing missing values (geom_label_repel). ## [1] 0 To get deviation z-scores markerChIP &lt;- getFeatures(projHeme5, useMatrix = &quot;ChIPMatrix&quot;) markerChIP &lt;- sort(grep(&quot;z:&quot;, markerChIP, value = TRUE)) markerChIP ## [1] “z:Encode_GM12878_CEBPB” “z:Encode_K562_Ebf1” “z:Encode_K562_GATA1” ## [4] “z:Encode_K562_Pax5” p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ChIPMatrix&quot;, name = markerChIP, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374635d5970-Date-2020-04-15_Time-11-14-35.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = ChIPMatrix ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting Embedding ## 1 2 3 4 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374635d5970-Date-2020-04-15_Time-11-14-35.log To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 2),p2)) "],
["footprinting-with-archr.html", "Chapter 14 Footprinting with ArchR", " Chapter 14 Footprinting with ArchR Transcription factor (TF) footprinting allows for the prediction of the precise binding location of a TF at a particular locus. This is because the DNA bases that are bound by the TF are actually protected from transposition while the DNA bases immediately adjacent to TF binding are accessible. Ideally, TF footprinting is performed at a single site to determine the precise binding location of the TF. However, in practice, this requires very high sequencing depth, often much higher depth than what most users would obtain from either bulk or single-cell ATAC-seq. To get around this problem, we can combine Tn5 insertion locations across many instances of predicted TF binding. For example, we can take all peaks that harbor a CTCF motif and make an aggregate TF footprint for CTCF across the whole genome. The accuracy of this footprint relies on generating a reliable curated list of predicted binding sites for the TF of interest. ArchR does this in a naive way via the addMotifAnnotations() functions by searching the peak region for any DNA sequence matching a motif. Depending on the degeneracy of the motif of interest, this may or may not be sufficient. These motif annotations get added to the QQQArchRProject??? as a binary representation on a per peak basis (0 = no motif, 1 = motif present). Once you have these motif annotations, ArchR performs footprinting using the plotFootprints() function which takes as input an ArchRProject object and a GenomicRanges object that contains the positions of the motifs. These positions can be accessed from the ArchRProject via the getPositions() function. Perhaps most importantly, the footprinting analyses in ArchR account for known Tn5 insertion sequence bias.To do this, ArchR uses a matrix of hexamer position frequencies and a matrix of k-mer frequencies at Tn5 insertion sites: All put together, the plotFootprints() function generates footprint plots that take into account Tn5 insertion bias. "],
["motif-footprinting.html", "14.1 Motif Footprinting", " 14.1 Motif Footprinting Transcription factor footprinting can also be done in ArchR with a single command. We note that the footprints generated by the tutorial data are not as clean as would be desired but this is because of the small size of the tutorial dataset. motifPositions &lt;- getPositions(projHeme5) motifPositions ## GRangesList object of length 870: ## $TFAP2B_1 ## GRanges object with 16773 ranges and 1 metadata column: ## seqnames ranges strand | score ## | ## [1] chr1 852468-852479 + | 8.17731199746359 ## [2] chr1 873916-873927 + | 8.32673820065588 ## [3] chr1 873916-873927 - | 8.32673820065588 ## [4] chr1 896671-896682 + | 9.96223327271814 ## [5] chr1 896671-896682 - | 8.92408377606486 ## … … … … . … ## [16769] chrX 153991101-153991112 + | 8.39549159740639 ## [16770] chrX 154299568-154299579 + | 8.90119825654299 ## [16771] chrX 154664929-154664940 - | 8.16690864294221 ## [16772] chrX 154807684-154807695 + | 9.57636587154549 ## [16773] chrX 154807684-154807695 - | 10.6117355833828 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths ## ## … ## &lt;869 more elements&gt; Find TF-Motifs motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) markerMotifs &lt;- unlist(lapply(motifs, function(x) grep(x, names(motifPositions), value = TRUE))) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;SREBF1_22&quot;] markerMotifs ## [1] “GATA1_383” “CEBPA_155” “EBF1_67” “IRF4_632” “TBX21_780” “PAX5_709” #Create Group Coverage Files if you have not done so already projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) Now we can compute footprints #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set seFoot &lt;- getFootprints( ArchRProj = projHeme5, positions = motifPositions[markerMotifs], groupBy = &quot;Clusters2&quot; ) ## ArchR logging to : ArchRLogs/ArchR-getFootprints-10b7a1d11042e-Date-2020-04-15_Time-11-15-50.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:15:51 : Computing Kmer Bias Table, 0.024 mins elapsed. ## 2020-04-15 11:16:13 : Finished Computing Kmer Tables, 0.361 mins elapsed. ## 2020-04-15 11:16:13 : Computing Footprints, 0.385 mins elapsed. ## 2020-04-15 11:16:22 : Computing Footprints Bias, 0.539 mins elapsed. ## 2020-04-15 11:16:28 : Summarizing Footprints, 0.642 mins elapsed. 14.1.1 No Normalization #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;None&quot;, plotName = &quot;Footprints-No-Normalization&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a22669572-Date-2020-04-15_Time-11-16-30.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:16:31 : Plotting Footprint : GATA1_383 (1 of 6), 0.009 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:35 : Plotting Footprint : CEBPA_155 (2 of 6), 0.077 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:38 : Plotting Footprint : EBF1_67 (3 of 6), 0.125 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:41 : Plotting Footprint : IRF4_632 (4 of 6), 0.173 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:44 : Plotting Footprint : TBX21_780 (5 of 6), 0.221 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## 2020-04-15 11:16:46 : Plotting Footprint : PAX5_709 (6 of 6), 0.27 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = None ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a22669572-Date-2020-04-15_Time-11-16-30.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. 14.1.2 Subtract Tn5 Bias #Re-Plot with different normalization method plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;Subtract&quot;, plotName = &quot;Footprints-Subtract-Bias&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a2038428-Date-2020-04-15_Time-11-16-59.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:16:59 : Plotting Footprint : GATA1_383 (1 of 6), 0.007 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:02 : Plotting Footprint : CEBPA_155 (2 of 6), 0.065 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:05 : Plotting Footprint : EBF1_67 (3 of 6), 0.109 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:08 : Plotting Footprint : IRF4_632 (4 of 6), 0.155 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:11 : Plotting Footprint : TBX21_780 (5 of 6), 0.199 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## 2020-04-15 11:17:13 : Plotting Footprint : PAX5_709 (6 of 6), 0.245 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Subtract ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a2038428-Date-2020-04-15_Time-11-16-59.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. 14.1.3 Divide Tn5 Bias #Re-Plot with different normalization method plotFootprints( seFoot = seFoot, ArchRProj = projHeme5, normMethod = &quot;Divide&quot;, plotName = &quot;Footprints-Divide-Bias&quot;, addDOC = FALSE, smoothWindow = 5 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a703225b0-Date-2020-04-15_Time-11-17-23.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:17:23 : Plotting Footprint : GATA1_383 (1 of 6), 0.008 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:27 : Plotting Footprint : CEBPA_155 (2 of 6), 0.073 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:30 : Plotting Footprint : EBF1_67 (3 of 6), 0.13 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:34 : Plotting Footprint : IRF4_632 (4 of 6), 0.189 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:38 : Plotting Footprint : TBX21_780 (5 of 6), 0.248 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## 2020-04-15 11:17:41 : Plotting Footprint : PAX5_709 (6 of 6), 0.307 mins elapsed. ## Applying smoothing window to footprint ## Normalizing by flanking regions ## NormMethod = Divide ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a703225b0-Date-2020-04-15_Time-11-17-23.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. "],
["feature-footprinting.html", "14.2 Feature Footprinting", " 14.2 Feature Footprinting #Create Group Coverage Files if you have not done so already projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) 14.2.1 No Normalization #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set seTSS &lt;- getFootprints( ArchRProj = projHeme5, positions = GRangesList(TSS = getTSS(projHeme5)), groupBy = &quot;Clusters2&quot;, flank = 2000 ) ## ArchR logging to : ArchRLogs/ArchR-getFootprints-10b7a47a82723-Date-2020-04-15_Time-11-17-52.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:17:52 : Computing Kmer Bias Table, 0.012 mins elapsed. ## 2020-04-15 11:18:24 : Finished Computing Kmer Tables, 0.535 mins elapsed. ## 2020-04-15 11:18:24 : Computing Footprints, 0.547 mins elapsed. ## 2020-04-15 11:18:36 : Computing Footprints Bias, 0.734 mins elapsed. ## 2020-04-15 11:18:43 : Summarizing Footprints, 0.852 mins elapsed. plotFootprints( seFoot = seTSS, ArchRProj = projHeme5, normMethod = &quot;None&quot;, plotName = &quot;TSS-No-Normalization&quot;, addDOC = FALSE, flank = 2000, flankNorm = 100 ) ## ArchR logging to : ArchRLogs/ArchR-plotFootprints-10b7a1b7faa1-Date-2020-04-15_Time-11-18-46.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:18:46 : Plotting Footprint : TSS (1 of 1), 0.007 mins elapsed. ## Normalizing by flanking regions ## NormMethod = None ## ArchR logging successful to : ArchRLogs/ArchR-plotFootprints-10b7a1b7faa1-Date-2020-04-15_Time-11-18-46.log By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. "],
["integrative-analysis-with-archr.html", "Chapter 15 Integrative Analysis with ArchR ", " Chapter 15 Integrative Analysis with ArchR "],
["co-accessibility-with-archr.html", "15.1 Co-accessibility with ArchR", " 15.1 Co-accessibility with ArchR projHeme5 &lt;- addCoAccessibility( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addCoAccessibility-11a706a1e44aa-Date-2020-04-15_Time-11-54-46.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:54:46 : Computing KNN, 0.009 mins elapsed. ## 2020-04-15 11:54:48 : Identifying Non-Overlapping KNN pairs, 0.032 mins elapsed. ## 2020-04-15 11:54:51 : Identified 491 Groupings!, 0.084 mins elapsed. ## 2020-04-15 11:54:54 : Computing Co-Accessibility chr1 (1 of 23), 0.134 mins elapsed. ## 2020-04-15 11:55:00 : Computing Co-Accessibility chr2 (2 of 23), 0.245 mins elapsed. ## 2020-04-15 11:55:05 : Computing Co-Accessibility chr3 (3 of 23), 0.325 mins elapsed. ## 2020-04-15 11:55:09 : Computing Co-Accessibility chr4 (4 of 23), 0.386 mins elapsed. ## 2020-04-15 11:55:12 : Computing Co-Accessibility chr5 (5 of 23), 0.438 mins elapsed. ## 2020-04-15 11:55:15 : Computing Co-Accessibility chr6 (6 of 23), 0.493 mins elapsed. ## 2020-04-15 11:55:20 : Computing Co-Accessibility chr7 (7 of 23), 0.564 mins elapsed. ## 2020-04-15 11:55:24 : Computing Co-Accessibility chr8 (8 of 23), 0.634 mins elapsed. ## 2020-04-15 11:55:27 : Computing Co-Accessibility chr9 (9 of 23), 0.685 mins elapsed. ## 2020-04-15 11:55:30 : Computing Co-Accessibility chr10 (10 of 23), 0.737 mins elapsed. ## 2020-04-15 11:55:34 : Computing Co-Accessibility chr11 (11 of 23), 0.805 mins elapsed. ## 2020-04-15 11:55:38 : Computing Co-Accessibility chr12 (12 of 23), 0.874 mins elapsed. ## 2020-04-15 11:55:42 : Computing Co-Accessibility chr13 (13 of 23), 0.937 mins elapsed. ## 2020-04-15 11:55:44 : Computing Co-Accessibility chr14 (14 of 23), 0.979 mins elapsed. ## 2020-04-15 11:55:47 : Computing Co-Accessibility chr15 (15 of 23), 1.028 mins elapsed. ## 2020-04-15 11:55:51 : Computing Co-Accessibility chr16 (16 of 23), 1.085 mins elapsed. ## 2020-04-15 11:55:55 : Computing Co-Accessibility chr17 (17 of 23), 1.146 mins elapsed. ## 2020-04-15 11:55:58 : Computing Co-Accessibility chr18 (18 of 23), 1.206 mins elapsed. ## 2020-04-15 11:56:01 : Computing Co-Accessibility chr19 (19 of 23), 1.251 mins elapsed. ## 2020-04-15 11:56:05 : Computing Co-Accessibility chr20 (20 of 23), 1.327 mins elapsed. ## 2020-04-15 11:56:09 : Computing Co-Accessibility chr21 (21 of 23), 1.384 mins elapsed. ## 2020-04-15 11:56:11 : Computing Co-Accessibility chr22 (22 of 23), 1.424 mins elapsed. ## 2020-04-15 11:56:14 : Computing Co-Accessibility chrX (23 of 23), 1.468 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addCoAccessibility-11a706a1e44aa-Date-2020-04-15_Time-11-54-46.log cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = FALSE ) cA ## DataFrame with 64824 rows and 4 columns ## queryHits subjectHits seqnames correlation ## ## 1 5 10 chr1 0.63855416236086 ## 2 10 5 chr1 0.63855416236086 ## 3 21 22 chr1 0.551520040138677 ## 4 22 21 chr1 0.551520040138677 ## 5 25 37 chr1 0.535392737290744 ## … … … … … ## 64820 143907 143906 chrX 0.510896735395573 ## 64821 143932 143936 chrX 0.501021498357938 ## 64822 143936 143932 chrX 0.501021498357938 ## 64823 143977 143978 chrX 0.550319862774772 ## 64824 143978 143977 chrX 0.550319862774772 metadata(cA)[[1]] ## GRanges object with 144009 ranges and 0 metadata columns: ## seqnames ranges strand ## ## Mono chr1 752499-752999 * ## NK chr1 762651-763151 * ## B chr1 801006-801506 * ## B chr1 805039-805539 * ## CLP chr1 845325-845825 * ## … … … … ## Erythroid chrX 154664540-154665040 * ## NK chrX 154807324-154807824 * ## PreB chrX 154840785-154841285 * ## PreB chrX 154842404-154842904 * ## NK chrX 154862017-154862517 * ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = TRUE ) cA[[1]] ## GRanges object with 32412 ranges and 1 metadata column: ## seqnames ranges strand | value ## | ## [1] chr1 845575-856640 * | 0.63855416236086 ## [2] chr1 894704-895233 * | 0.551520040138677 ## [3] chr1 901499-940519 * | 0.535392737290744 ## [4] chr1 968584-1004206 * | 0.541750176412625 ## [5] chr1 974287-975116 * | 0.614286275264492 ## … … … … . … ## [32408] chrX 153306085-153342739 * | 0.54575277183448 ## [32409] chrX 153523581-153529374 * | 0.539921104229481 ## [32410] chrX 153582820-153583471 * | 0.510896735395573 ## [32411] chrX 153637615-153656023 * | 0.501021498357938 ## [32412] chrX 153980218-153990364 * | 0.550319862774772 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1000, returnLoops = TRUE ) cA[[1]] ## GRanges object with 30997 ranges and 1 metadata column: ## seqnames ranges strand | value ## | ## [1] chr1 845500-856500 * | 0.63855416236086 ## [2] chr1 894500-895500 * | 0.551520040138677 ## [3] chr1 901500-940500 * | 0.535392737290744 ## [4] chr1 968500-1004500 * | 0.541750176412625 ## [5] chr1 974500-975500 * | 0.614286275264492 ## … … … … . … ## [30993] chrX 153306500-153342500 * | 0.54575277183448 ## [30994] chrX 153523500-153529500 * | 0.539921104229481 ## [30995] chrX 153582500-153583500 * | 0.510896735395573 ## [30996] chrX 153637500-153656500 * | 0.501021498357938 ## [30997] chrX 153980500-153990500 * | 0.550319862774772 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 10000, returnLoops = TRUE ) cA[[1]] ## GRanges object with 21142 ranges and 1 metadata column: ## seqnames ranges strand | value ## | ## [1] chr1 845000-855000 * | 0.63855416236086 ## [2] chr1 895000 * | 0.551520040138677 ## [3] chr1 905000-945000 * | 0.535392737290744 ## [4] chr1 965000-1005000 * | 0.541750176412625 ## [5] chr1 975000 * | 0.614286275264492 ## … … … … . … ## [21138] chrX 153305000-153345000 * | 0.54575277183448 ## [21139] chrX 153525000 * | 0.539921104229481 ## [21140] chrX 153585000 * | 0.510896735395573 ## [21141] chrX 153635000-153655000 * | 0.501021498357938 ## [21142] chrX 153985000-153995000 * | 0.550319862774772 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Plotting browser tracks with CoAccessibility markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000, loops = getCoAccessibility(projHeme5) ) ## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-11a703dda2936-Date-2020-04-15_Time-11-56-18.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:56:18 : Validating Region, 0.007 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 11:56:18 : Adding Bulk Tracks (1 of 9), 0.01 mins elapsed. ## 2020-04-15 11:56:21 : Adding Feature Tracks (1 of 9), 0.053 mins elapsed. ## 2020-04-15 11:56:21 : Adding Loop Tracks (1 of 9), 0.056 mins elapsed. ## 2020-04-15 11:56:21 : Adding Gene Tracks (1 of 9), 0.059 mins elapsed. ## 2020-04-15 11:56:21 : Plotting, 0.065 mins elapsed. ## 2020-04-15 11:56:24 : Adding Bulk Tracks (2 of 9), 0.1 mins elapsed. ## 2020-04-15 11:56:26 : Adding Feature Tracks (2 of 9), 0.137 mins elapsed. ## 2020-04-15 11:56:26 : Adding Loop Tracks (2 of 9), 0.139 mins elapsed. ## 2020-04-15 11:56:26 : Adding Gene Tracks (2 of 9), 0.144 mins elapsed. ## 2020-04-15 11:56:27 : Plotting, 0.151 mins elapsed. ## 2020-04-15 11:56:28 : Adding Bulk Tracks (3 of 9), 0.181 mins elapsed. ## 2020-04-15 11:56:30 : Adding Feature Tracks (3 of 9), 0.202 mins elapsed. ## 2020-04-15 11:56:30 : Adding Loop Tracks (3 of 9), 0.205 mins elapsed. ## 2020-04-15 11:56:31 : Adding Gene Tracks (3 of 9), 0.217 mins elapsed. ## 2020-04-15 11:56:31 : Plotting, 0.223 mins elapsed. ## 2020-04-15 11:56:33 : Adding Bulk Tracks (4 of 9), 0.257 mins elapsed. ## 2020-04-15 11:56:34 : Adding Feature Tracks (4 of 9), 0.272 mins elapsed. ## 2020-04-15 11:56:34 : Adding Loop Tracks (4 of 9), 0.275 mins elapsed. ## 2020-04-15 11:56:34 : Adding Gene Tracks (4 of 9), 0.281 mins elapsed. ## 2020-04-15 11:56:35 : Plotting, 0.287 mins elapsed. ## 2020-04-15 11:56:36 : Adding Bulk Tracks (5 of 9), 0.31 mins elapsed. ## 2020-04-15 11:56:37 : Adding Feature Tracks (5 of 9), 0.327 mins elapsed. ## 2020-04-15 11:56:37 : Adding Loop Tracks (5 of 9), 0.329 mins elapsed. ## 2020-04-15 11:56:38 : Adding Gene Tracks (5 of 9), 0.335 mins elapsed. ## 2020-04-15 11:56:38 : Plotting, 0.339 mins elapsed. ## 2020-04-15 11:56:40 : Adding Bulk Tracks (6 of 9), 0.367 mins elapsed. ## 2020-04-15 11:56:41 : Adding Feature Tracks (6 of 9), 0.384 mins elapsed. ## 2020-04-15 11:56:41 : Adding Loop Tracks (6 of 9), 0.385 mins elapsed. ## 2020-04-15 11:56:41 : Adding Gene Tracks (6 of 9), 0.391 mins elapsed. ## 2020-04-15 11:56:41 : Plotting, 0.395 mins elapsed. ## 2020-04-15 11:56:43 : Adding Bulk Tracks (7 of 9), 0.422 mins elapsed. ## 2020-04-15 11:56:44 : Adding Feature Tracks (7 of 9), 0.443 mins elapsed. ## 2020-04-15 11:56:44 : Adding Loop Tracks (7 of 9), 0.447 mins elapsed. ## 2020-04-15 11:56:45 : Adding Gene Tracks (7 of 9), 0.455 mins elapsed. ## 2020-04-15 11:56:45 : Plotting, 0.459 mins elapsed. ## 2020-04-15 11:56:47 : Adding Bulk Tracks (8 of 9), 0.489 mins elapsed. ## 2020-04-15 11:56:48 : Adding Feature Tracks (8 of 9), 0.506 mins elapsed. ## 2020-04-15 11:56:48 : Adding Loop Tracks (8 of 9), 0.51 mins elapsed. ## 2020-04-15 11:56:49 : Adding Gene Tracks (8 of 9), 0.522 mins elapsed. ## 2020-04-15 11:56:49 : Plotting, 0.526 mins elapsed. ## 2020-04-15 11:56:51 : Adding Bulk Tracks (9 of 9), 0.562 mins elapsed. ## 2020-04-15 11:56:52 : Adding Feature Tracks (9 of 9), 0.578 mins elapsed. ## 2020-04-15 11:56:52 : Adding Loop Tracks (9 of 9), 0.58 mins elapsed. ## 2020-04-15 11:56:53 : Adding Gene Tracks (9 of 9), 0.589 mins elapsed. ## 2020-04-15 11:56:53 : Plotting, 0.594 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-11a703dda2936-Date-2020-04-15_Time-11-56-18.log To plot a track we can simply print one from the list grid::grid.newpage() grid::grid.draw(p$CD14) plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes-with-CoAccessibility.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## [1] 0 Download PDF : Plot-Tracks-Marker-Genes.pdf "],
["peak2genelinkage-with-archr.html", "15.2 Peak2GeneLinkage with ArchR", " 15.2 Peak2GeneLinkage with ArchR projHeme5 &lt;- addPeak2GeneLinks( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-addPeak2GeneLinks-11a7017ae41d-Date-2020-04-15_Time-11-57-10.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:57:11 : Getting Available Matrices, 0.006 mins elapsed. ## 2020-04-15 11:57:11 : Filtered Low Prediction Score Cells (1049 of 10251, 0.102), 0.004 mins elapsed. ## 2020-04-15 11:57:12 : Computing KNN, 0.009 mins elapsed. ## 2020-04-15 11:57:12 : Identifying Non-Overlapping KNN pairs, 0.016 mins elapsed. ## 2020-04-15 11:57:15 : Identified 491 Groupings!, 0.07 mins elapsed. ## 2020-04-15 11:57:15 : Getting Group RNA Matrix, 0.071 mins elapsed. ## 2020-04-15 11:57:43 : Getting Group ATAC Matrix, 0.536 mins elapsed. ## 2020-04-15 11:58:18 : Normalizing Group Matrices, 1.112 mins elapsed. ## 2020-04-15 11:58:24 : Finding Peak Gene Pairings, 1.218 mins elapsed. ## 2020-04-15 11:58:25 : Computing Correlations, 1.227 mins elapsed. ## 2020-04-15 11:58:34 : Completed Peak2Gene Correlations!, 1.382 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-addPeak2GeneLinks-11a7017ae41d-Date-2020-04-15_Time-11-57-10.log p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1, returnLoops = FALSE ) p2g ## DataFrame with 43754 rows and 6 columns ## idxATAC idxRNA Correlation FDR ## ## 1 47 5 0.549552663393716 1.34094093110629e-38 ## 2 3 6 0.487418258348982 2.1460798658766e-29 ## 3 3 7 0.821369314290254 1.70141157082175e-118 ## 4 47 7 0.569899085935183 4.61958766180263e-42 ## 5 59 7 0.549954043409585 1.15152278593831e-38 ## … … … … … ## 43750 143964 18590 0.520703047216992 4.37554114264876e-34 ## 43751 143977 18590 0.546301068655939 4.54936701954597e-38 ## 43752 144004 18594 0.47934214168793 2.47516776950818e-28 ## 43753 143999 18598 0.49092225993235 7.28579053551407e-30 ## 43754 144005 18598 0.493389088498317 3.37643947034054e-30 ## VarQATAC VarQRNA ## ## 1 0.948753202924817 0.793290683296597 ## 2 0.253206396822421 0.445890005913661 ## 3 0.253206396822421 0.42728885543788 ## 4 0.948753202924817 0.42728885543788 ## 5 0.916137185870328 0.42728885543788 ## … … … ## 43750 0.629044018082203 0.960701037578625 ## 43751 0.701518655084057 0.960701037578625 ## 43752 0.814587977140318 0.802537497983979 ## 43753 0.0392197709865356 0.901295629267244 ## 43754 0.158948399058392 0.901295629267244 metadata(p2g)[[1]] ## GRanges object with 144009 ranges and 0 metadata columns: ## seqnames ranges strand ## ## [1] chr1 752499-752999 * ## [2] chr1 762651-763151 * ## [3] chr1 801006-801506 * ## [4] chr1 805039-805539 * ## [5] chr1 845325-845825 * ## … … … … ## [144005] chrX 154664540-154665040 * ## [144006] chrX 154807324-154807824 * ## [144007] chrX 154840785-154841285 * ## [144008] chrX 154842404-154842904 * ## [144009] chrX 154862017-154862517 * ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 43695 ranges and 2 metadata columns: ## seqnames ranges strand | value ## | ## [1] chr1 762901-948847 * | 0.533350285896763 ## [2] chr1 801256-895967 * | 0.487418258348982 ## [3] chr1 801256-901877 * | 0.821369314290254 ## [4] chr1 852367-955503 * | 0.487693663181145 ## [5] chr1 894679-968584 * | 0.549552663393716 ## … … … … . … ## [43691] chrX 153962451-153979858 * | 0.453720046871409 ## [43692] chrX 153980218-153991031 * | 0.546301068655939 ## [43693] chrX 154255064-154493795 * | 0.47934214168793 ## [43694] chrX 154356425-154444701 * | 0.49092225993235 ## [43695] chrX 154444701-154664790 * | 0.493389088498317 ## FDR ## ## [1] 5.20045729958651e-36 ## [2] 2.1460798658766e-29 ## [3] 1.70141157082175e-118 ## [4] 1.97244775926907e-29 ## [5] 1.34094093110629e-38 ## … … ## [43691] 3.78754241443136e-25 ## [43692] 4.54936701954597e-38 ## [43693] 2.47516776950818e-28 ## [43694] 7.28579053551407e-30 ## [43695] 3.37643947034054e-30 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 1000, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 42126 ranges and 2 metadata columns: ## seqnames ranges strand | value ## | ## [1] chr1 762500-948500 * | 0.533350285896763 ## [2] chr1 801500-895500 * | 0.487418258348982 ## [3] chr1 801500-901500 * | 0.821369314290254 ## [4] chr1 852500-955500 * | 0.487693663181145 ## [5] chr1 894500-968500 * | 0.549552663393716 ## … … … … . … ## [42122] chrX 153962500-153979500 * | 0.453720046871409 ## [42123] chrX 153980500-153991500 * | 0.546301068655939 ## [42124] chrX 154255500-154493500 * | 0.47934214168793 ## [42125] chrX 154356500-154444500 * | 0.49092225993235 ## [42126] chrX 154444500-154664500 * | 0.493389088498317 ## FDR ## ## [1] 5.20045729958651e-36 ## [2] 2.1460798658766e-29 ## [3] 1.70141157082175e-118 ## [4] 1.97244775926907e-29 ## [5] 1.34094093110629e-38 ## … … ## [42122] 3.78754241443136e-25 ## [42123] 4.54936701954597e-38 ## [42124] 2.47516776950818e-28 ## [42125] 7.28579053551407e-30 ## [42126] 3.37643947034054e-30 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths p2g &lt;- getPeak2GeneLinks( ArchRProj = projHeme5, corCutOff = 0.45, resolution = 10000, returnLoops = TRUE ) p2g[[1]] ## GRanges object with 33645 ranges and 2 metadata columns: ## seqnames ranges strand | value ## | ## [1] chr1 765000-945000 * | 0.533350285896763 ## [2] chr1 805000-895000 * | 0.487418258348982 ## [3] chr1 805000-905000 * | 0.821369314290254 ## [4] chr1 855000-955000 * | 0.487693663181145 ## [5] chr1 895000-965000 * | 0.549552663393716 ## … … … … . … ## [33641] chrX 153965000-153975000 * | 0.453720046871409 ## [33642] chrX 153985000-153995000 * | 0.546301068655939 ## [33643] chrX 154255000-154495000 * | 0.47934214168793 ## [33644] chrX 154355000-154445000 * | 0.49092225993235 ## [33645] chrX 154445000-154665000 * | 0.493389088498317 ## FDR ## ## [1] 5.20045729958651e-36 ## [2] 2.1460798658766e-29 ## [3] 1.70141157082175e-118 ## [4] 1.97244775926907e-29 ## [5] 1.34094093110629e-38 ## … … ## [33641] 3.78754241443136e-25 ## [33642] 4.54936701954597e-38 ## [33643] 2.47516776950818e-28 ## [33644] 7.28579053551407e-30 ## [33645] 3.37643947034054e-30 ## ——- ## seqinfo: 23 sequences from an unspecified genome; no seqlengths Plotting browser tracks with Peak2Gene Links markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000, loops = getPeak2GeneLinks(projHeme5) ) ## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-11a7048fa912a-Date-2020-04-15_Time-11-58-35.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:58:36 : Validating Region, 0.012 mins elapsed. ## GRanges object with 9 ranges and 2 metadata columns: ## seqnames ranges strand | gene_id symbol ## | ## [1] chr1 208059883-208084683 - | 947 CD34 ## [2] chrX 48644982-48652717 + | 2623 GATA1 ## [3] chr9 36838531-37034476 - | 5079 PAX5 ## [4] chr11 60223282-60238225 + | 931 MS4A1 ## [5] chr5 140011313-140013286 - | 929 CD14 ## [6] chr11 118209789-118213459 - | 915 CD3D ## [7] chr2 87011728-87035519 - | 925 CD8A ## [8] chr17 45810610-45823485 + | 30009 TBX21 ## [9] chr5 35856977-35879705 + | 3575 IL7R ## ——- ## seqinfo: 24 sequences from hg19 genome ## 2020-04-15 11:58:36 : Adding Bulk Tracks (1 of 9), 0.015 mins elapsed. ## 2020-04-15 11:58:37 : Adding Feature Tracks (1 of 9), 0.038 mins elapsed. ## 2020-04-15 11:58:37 : Adding Loop Tracks (1 of 9), 0.039 mins elapsed. ## 2020-04-15 11:58:37 : Adding Gene Tracks (1 of 9), 0.041 mins elapsed. ## 2020-04-15 11:58:38 : Plotting, 0.045 mins elapsed. ## 2020-04-15 11:58:39 : Adding Bulk Tracks (2 of 9), 0.076 mins elapsed. ## 2020-04-15 11:58:40 : Adding Feature Tracks (2 of 9), 0.091 mins elapsed. ## 2020-04-15 11:58:41 : Adding Loop Tracks (2 of 9), 0.095 mins elapsed. ## 2020-04-15 11:58:41 : Adding Gene Tracks (2 of 9), 0.098 mins elapsed. ## 2020-04-15 11:58:41 : Plotting, 0.104 mins elapsed. ## 2020-04-15 11:58:43 : Adding Bulk Tracks (3 of 9), 0.134 mins elapsed. ## 2020-04-15 11:58:44 : Adding Feature Tracks (3 of 9), 0.151 mins elapsed. ## 2020-04-15 11:58:44 : Adding Loop Tracks (3 of 9), 0.153 mins elapsed. ## 2020-04-15 11:58:44 : Adding Gene Tracks (3 of 9), 0.157 mins elapsed. ## 2020-04-15 11:58:45 : Plotting, 0.162 mins elapsed. ## 2020-04-15 11:58:47 : Adding Bulk Tracks (4 of 9), 0.196 mins elapsed. ## 2020-04-15 11:58:48 : Adding Feature Tracks (4 of 9), 0.212 mins elapsed. ## 2020-04-15 11:58:48 : Adding Loop Tracks (4 of 9), 0.213 mins elapsed. ## 2020-04-15 11:58:48 : Adding Gene Tracks (4 of 9), 0.216 mins elapsed. ## 2020-04-15 11:58:48 : Plotting, 0.22 mins elapsed. ## 2020-04-15 11:58:49 : Adding Bulk Tracks (5 of 9), 0.242 mins elapsed. ## 2020-04-15 11:58:50 : Adding Feature Tracks (5 of 9), 0.258 mins elapsed. ## 2020-04-15 11:58:51 : Adding Loop Tracks (5 of 9), 0.26 mins elapsed. ## 2020-04-15 11:58:51 : Adding Gene Tracks (5 of 9), 0.268 mins elapsed. ## 2020-04-15 11:58:51 : Plotting, 0.273 mins elapsed. ## 2020-04-15 11:58:53 : Adding Bulk Tracks (6 of 9), 0.307 mins elapsed. ## 2020-04-15 11:58:54 : Adding Feature Tracks (6 of 9), 0.323 mins elapsed. ## 2020-04-15 11:58:54 : Adding Loop Tracks (6 of 9), 0.325 mins elapsed. ## 2020-04-15 11:58:55 : Adding Gene Tracks (6 of 9), 0.333 mins elapsed. ## 2020-04-15 11:58:55 : Plotting, 0.338 mins elapsed. ## 2020-04-15 11:58:57 : Adding Bulk Tracks (7 of 9), 0.369 mins elapsed. ## 2020-04-15 11:58:58 : Adding Feature Tracks (7 of 9), 0.389 mins elapsed. ## 2020-04-15 11:58:58 : Adding Loop Tracks (7 of 9), 0.391 mins elapsed. ## 2020-04-15 11:58:59 : Adding Gene Tracks (7 of 9), 0.397 mins elapsed. ## 2020-04-15 11:58:59 : Plotting, 0.403 mins elapsed. ## 2020-04-15 11:59:01 : Adding Bulk Tracks (8 of 9), 0.443 mins elapsed. ## 2020-04-15 11:59:03 : Adding Feature Tracks (8 of 9), 0.462 mins elapsed. ## 2020-04-15 11:59:03 : Adding Loop Tracks (8 of 9), 0.464 mins elapsed. ## 2020-04-15 11:59:03 : Adding Gene Tracks (8 of 9), 0.468 mins elapsed. ## 2020-04-15 11:59:03 : Plotting, 0.473 mins elapsed. ## 2020-04-15 11:59:06 : Adding Bulk Tracks (9 of 9), 0.515 mins elapsed. ## 2020-04-15 11:59:07 : Adding Feature Tracks (9 of 9), 0.533 mins elapsed. ## 2020-04-15 11:59:07 : Adding Loop Tracks (9 of 9), 0.536 mins elapsed. ## 2020-04-15 11:59:07 : Adding Gene Tracks (9 of 9), 0.543 mins elapsed. ## 2020-04-15 11:59:08 : Plotting, 0.549 mins elapsed. ## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-11a7048fa912a-Date-2020-04-15_Time-11-58-35.log To plot a track we can simply print one from the list grid::grid.newpage() grid::grid.draw(p$CD14) plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes-with-Peak2GeneLinks.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## NULL ## [1] 0 Download PDF : Plot-Tracks-Marker-Genes.pdf Lastly we can make a peak2gene heatmap p &lt;- peak2GeneHeatmap(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) ## ArchR logging to : ArchRLogs/ArchR-peak2GeneHeatmap-11a707e40d64f-Date-2020-04-15_Time-11-59-30.log ## If there is an issue, please report to github with logFile! ## 2020-04-15 11:59:34 : Determining KNN Groups!, 0.071 mins elapsed. ## 2020-04-15 11:59:39 : Ordering Peak2Gene Links!, 0.15 mins elapsed. ## 2020-04-15 11:59:48 : Constructing ATAC Heatmap!, 0.309 mins elapsed. ## Adding Annotations.. ## Preparing Main Heatmap.. ## 2020-04-15 11:59:49 : Constructing RNA Heatmap!, 0.32 mins elapsed. ## Adding Annotations.. ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-peak2GeneHeatmap-11a707e40d64f-Date-2020-04-15_Time-11-59-30.log p "],
["identification-of-positive-tf-regulators.html", "15.3 Identification of Positive TF-Regulators", " 15.3 Identification of Positive TF-Regulators Step 1. Identify Deviant TF Motifs seGroupMotif &lt;- exportGroupSE(ArchRProj = projHeme5, useMatrix = &quot;MotifMatrix&quot;, groupBy = &quot;Clusters2&quot;) ## 2020-04-15 12:03:08 : Successfully Created Group Matrix, 0.133 mins elapsed. seGroupMotif ## class: SummarizedExperiment ## dim: 1740 11 ## metadata(0): ## assays(1): MotifMatrix ## rownames(1740): f1 f2 … f1739 f1740 ## rowData names(3): seqnames idx name ## colnames(11): B CD4.M … PreB Progenitor ## colData names(16): TSSEnrichment ReadsInTSS … FRIP nCells #Get Deviation Z-Scores seZ &lt;- seGroupMotif[rowData(seGroupMotif)$seqnames==&quot;z&quot;,] #Max Delta rowData(seZ)$maxDelta &lt;- lapply(seq_len(ncol(seZ)), function(x){ rowMaxs(assay(seZ) - assay(seZ)[,x]) }) %&gt;% Reduce(&quot;cbind&quot;, .) %&gt;% rowMaxs Step 2. Identify Correlated TF Motifs and TF Gene Score/Expression corGSM_MM &lt;- correlateMatrices( ArchRProj = projHeme5, useMatrix1 = &quot;GeneScoreMatrix&quot;, useMatrix2 = &quot;MotifMatrix&quot;, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-correlateMatrices-11a7038ad0163-Date-2020-04-15_Time-12-03-11.log ## If there is an issue, please report to github with logFile! ## When accessing features from a matrix of class Sparse.Assays.Matrix it requires 1 seqname! ## Continuing with first seqname ‘z’! ## If confused, try getFeatures(ArchRProj, ‘MotifMatrix’) to list out available seqnames for input! ## 2020-04-15 12:03:16 : Testing 825 Mappings!, 0.091 mins elapsed. ## 2020-04-15 12:03:16 : Computing KNN, 0.091 mins elapsed. ## 2020-04-15 12:03:16 : Identifying Non-Overlapping KNN pairs, 0.095 mins elapsed. ## 2020-04-15 12:03:19 : Identified 491 Groupings!, 0.138 mins elapsed. ## 2020-04-15 12:03:21 : Getting Group Matrix 1, 0.17 mins elapsed. ## 2020-04-15 12:03:33 : Getting Group Matrix 2, 0.365 mins elapsed. ## Some entries in groupMat2 are less than 0, continuing without Log2 Normalization. ## Most likely this assay is a deviations matrix. ## Getting Correlations… ## 2020-04-15 12:03:40 : ## Computing Correlation (250 of 825) ## Computing Correlation (500 of 825) ## Computing Correlation (750 of 825) ## ArchR logging successful to : ArchRLogs/ArchR-correlateMatrices-11a7038ad0163-Date-2020-04-15_Time-12-03-11.log corGSM_MM ## DataFrame with 825 rows and 14 columns ## GeneScoreMatrix_name MotifMatrix_name cor ## ## 1 HES4 HES4_95 0.154455056755803 ## 2 HES5 HES5_98 0.337473683281965 ## 3 PRDM16 PRDM16_211 0.491297659378326 ## 4 TP73 TP73_705 0.528916107713827 ## 5 TP73-AS1 TP73_705 -0.0522225826610403 ## … … … … ## 821 TFDP3 TFDP3_309 -0.0747374184980152 ## 822 ZNF75D ZNF75D_272 -0.0515391773083338 ## 823 ZIC3 ZIC3_215 0.3158469818621 ## 824 SOX3 SOX3_759 -0.016068246967503 ## 825 MECP2 MECP2_645 0.0629645419544807 ## padj pval GeneScoreMatrix_seqnames ## ## 1 0.48577773775473 0.000593860315103582 chr1 ## 2 1.24697036872354e-11 1.52441365369626e-14 chr1 ## 3 2.77075935285262e-28 3.38723637268047e-31 chr1 ## 4 7.91605921989722e-34 9.6773340096543e-37 chr1 ## 5 1 0.248084710011419 chr1 ## … … … … ## 821 1 0.0980942700648066 chrX ## 822 1 0.254336826019648 chrX ## 823 6.35887872390377e-10 7.77369037152051e-13 chrX ## 824 1 0.722466734136741 chrX ## 825 1 0.163611488297825 chrX ## GeneScoreMatrix_start GeneScoreMatrix_end GeneScoreMatrix_strand ## ## 1 935552 934342 2 ## 2 2461684 2460184 2 ## 3 2985742 3355185 1 ## 4 3569129 3652765 1 ## 5 3663937 3652548 2 ## … … … … ## 821 132352376 132350697 2 ## 822 134429965 134419723 2 ## 823 136648346 136654259 1 ## 824 139587225 139585152 2 ## 825 153363188 153287264 2 ## GeneScoreMatrix_idx GeneScoreMatrix_matchName MotifMatrix_seqnames ## ## 1 15 HES4 z ## 2 74 HES5 z ## 3 82 PRDM16 z ## 4 89 TP73 z ## 5 90 TP73 z ## … … … … ## 821 697 TFDP3 z ## 822 728 ZNF75D z ## 823 753 ZIC3 z ## 824 765 SOX3 z ## 825 874 MECP2 z ## MotifMatrix_idx MotifMatrix_matchName ## ## 1 95 HES4 ## 2 98 HES5 ## 3 211 PRDM16 ## 4 705 TP73 ## 5 705 TP73 ## … … … ## 821 309 TFDP3 ## 822 272 ZNF75D ## 823 215 ZIC3 ## 824 759 SOX3 ## 825 645 MECP2 corGIM_MM &lt;- correlateMatrices( ArchRProj = projHeme5, useMatrix1 = &quot;GeneIntegrationMatrix&quot;, useMatrix2 = &quot;MotifMatrix&quot;, reducedDims = &quot;IterativeLSI&quot; ) ## ArchR logging to : ArchRLogs/ArchR-correlateMatrices-11a70642ae62f-Date-2020-04-15_Time-12-03-41.log ## If there is an issue, please report to github with logFile! ## When accessing features from a matrix of class Sparse.Assays.Matrix it requires 1 seqname! ## Continuing with first seqname ‘z’! ## If confused, try getFeatures(ArchRProj, ‘MotifMatrix’) to list out available seqnames for input! ## 2020-04-15 12:03:44 : Testing 798 Mappings!, 0.062 mins elapsed. ## 2020-04-15 12:03:44 : Computing KNN, 0.062 mins elapsed. ## 2020-04-15 12:03:45 : Identifying Non-Overlapping KNN pairs, 0.066 mins elapsed. ## 2020-04-15 12:03:47 : Identified 491 Groupings!, 0.108 mins elapsed. ## 2020-04-15 12:03:50 : Getting Group Matrix 1, 0.147 mins elapsed. ## 2020-04-15 12:04:03 : Getting Group Matrix 2, 0.368 mins elapsed. ## Some entries in groupMat2 are less than 0, continuing without Log2 Normalization. ## Most likely this assay is a deviations matrix. ## Getting Correlations… ## 2020-04-15 12:04:10 : ## Computing Correlation (250 of 798) ## Computing Correlation (500 of 798) ## Computing Correlation (750 of 798) ## ArchR logging successful to : ArchRLogs/ArchR-correlateMatrices-11a70642ae62f-Date-2020-04-15_Time-12-03-41.log corGIM_MM ## DataFrame with 798 rows and 14 columns ## GeneIntegrationMatrix_name MotifMatrix_name cor ## ## 1 HES4 HES4_95 -0.0623909761741224 ## 2 HES5 HES5_98 -0.130794628882194 ## 3 PRDM16 PRDM16_211 0.526453624653558 ## 4 TP73 TP73_705 NA ## 5 HES2 HES2_19 -0.267296043452788 ## … … … … ## 794 TFDP3 TFDP3_309 NA ## 795 ZNF75D ZNF75D_272 -0.253529703381296 ## 796 ZIC3 ZIC3_215 NA ## 797 SOX3 SOX3_759 NA ## 798 MECP2 MECP2_645 0.150328680116803 ## padj pval GeneIntegrationMatrix_seqnames ## ## 1 1 0.167490297051793 chr1 ## 2 1 0.00369241031157534 chr1 ## 3 1.23364764777334e-33 2.34533773340939e-36 chr1 ## 4 NA NA chr1 ## 5 9.31006760220939e-07 1.76997482931738e-09 chr1 ## … … … … ## 794 NA NA chrX ## 795 6.41888945797785e-06 1.22032118972963e-08 chrX ## 796 NA NA chrX ## 797 NA NA chrX ## 798 0.438175655348636 0.000833033565301589 chrX ## GeneIntegrationMatrix_start GeneIntegrationMatrix_end ## ## 1 935552 934342 ## 2 2461684 2460184 ## 3 2985742 3355185 ## 4 3569129 3652765 ## 5 6484730 6472498 ## … … … ## 794 132352376 132350697 ## 795 134429965 134419723 ## 796 136648346 136654259 ## 797 139587225 139585152 ## 798 153363188 153287264 ## GeneIntegrationMatrix_strand GeneIntegrationMatrix_idx ## ## 1 2 8 ## 2 2 53 ## 3 1 59 ## 4 1 64 ## 5 2 81 ## … … … ## 794 2 562 ## 795 2 576 ## 796 1 595 ## 797 2 602 ## 798 2 680 ## GeneIntegrationMatrix_matchName MotifMatrix_seqnames MotifMatrix_idx ## ## 1 HES4 z 95 ## 2 HES5 z 98 ## 3 PRDM16 z 211 ## 4 TP73 z 705 ## 5 HES2 z 19 ## … … … … ## 794 TFDP3 z 309 ## 795 ZNF75D z 272 ## 796 ZIC3 z 215 ## 797 SOX3 z 759 ## 798 MECP2 z 645 ## MotifMatrix_matchName ## ## 1 HES4 ## 2 HES5 ## 3 PRDM16 ## 4 TP73 ## 5 HES2 ## … … ## 794 TFDP3 ## 795 ZNF75D ## 796 ZIC3 ## 797 SOX3 ## 798 MECP2 Step 3. Add Maximum Delta Deviation to the Correlation Data Frame corGSM_MM$maxDelta &lt;- rowData(seZ)[match(corGSM_MM$MotifMatrix_name, rowData(seZ)$name), &quot;maxDelta&quot;] corGIM_MM$maxDelta &lt;- rowData(seZ)[match(corGIM_MM$MotifMatrix_name, rowData(seZ)$name), &quot;maxDelta&quot;] Step 4. Identify Positive TF Regulators For Gene Scores corGSM_MM &lt;- corGSM_MM[order(abs(corGSM_MM$cor), decreasing = TRUE), ] corGSM_MM &lt;- corGSM_MM[which(!duplicated(gsub(&quot;\\\\-.*&quot;,&quot;&quot;,corGSM_MM[,&quot;MotifMatrix_name&quot;]))), ] corGSM_MM$TFRegulator &lt;- &quot;NO&quot; corGSM_MM$TFRegulator[which(corGSM_MM$cor &gt; 0.5 &amp; corGSM_MM$padj &lt; 0.01 &amp; corGSM_MM$maxDelta &gt; quantile(corGSM_MM$maxDelta, 0.75))] &lt;- &quot;YES&quot; sort(corGSM_MM[corGSM_MM$TFRegulator==&quot;YES&quot;,1]) ## [1] “ATOH1” “BCL11A” “CEBPA-DT” “CEBPB” “CEBPD” “CREB1” ## [7] “CREB3L4” “EBF1” “EGR2” “EOMES” “ERF” “ESR1” ## [13] “ETS1” “ETV3” “FUBP1” “GATA1” “GATA2” “GATA5” ## [19] “GATA6” “IRF1” “JDP2” “KLF11” “KLF2” “LYL1” ## [25] “MECOM” “MITF” “NFE2” “NFIA” “NFIB” “NFIC” ## [31] “NFIX” “NHLH1” “POU2F1” “RUNX2” “SIX5” “SMAD1” ## [37] “SMAD9” “SP4” “SPI1” “SPIB” “TAL1” “TCF15” ## [43] “TCF23” “TCF4” “TFAP2C” “TWIST1” “TWIST2” “YY1” ## [49] “ZEB1-AS1” p &lt;- ggplot(data.frame(corGSM_MM), aes(cor, maxDelta, color = TFRegulator)) + geom_point() + theme_ArchR() + geom_vline(xintercept = 0, lty = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;NO&quot;=&quot;darkgrey&quot;, &quot;YES&quot;=&quot;firebrick3&quot;)) + xlab(&quot;Correlation To Gene Expression&quot;) + ylab(&quot;Max TF Motif Delta&quot;) + scale_y_continuous( expand = c(0,0), limits = c(0, max(corGSM_MM$maxDelta)*1.05) ) p ## Warning: Removed 7 rows containing missing values (geom_point). For Gene Expression corGIM_MM &lt;- corGIM_MM[order(abs(corGIM_MM$cor), decreasing = TRUE), ] corGIM_MM &lt;- corGIM_MM[which(!duplicated(gsub(&quot;\\\\-.*&quot;,&quot;&quot;,corGIM_MM[,&quot;MotifMatrix_name&quot;]))), ] corGIM_MM$TFRegulator &lt;- &quot;NO&quot; corGIM_MM$TFRegulator[which(corGIM_MM$cor &gt; 0.5 &amp; corGIM_MM$padj &lt; 0.01 &amp; corGIM_MM$maxDelta &gt; quantile(corGIM_MM$maxDelta, 0.75))] &lt;- &quot;YES&quot; sort(corGIM_MM[corGIM_MM$TFRegulator==&quot;YES&quot;,1]) ## [1] “ATF1” “BACH1” “CEBPA” “CEBPB” “CEBPD” “CEBPE” “CEBPG” “CTCF” ## [9] “EBF1” “ELK1” “EOMES” “ETS1” “FOS” “FOSB” “FOSL2” “GATA1” ## [17] “GATA2” “IRF1” “IRF2” “IRF9” “JDP2” “KLF2” “MECOM” “MITF” ## [25] “NFE2” “NFIA” “NFIB” “NFIC” “NFIX” “NR4A1” “POU2F2” “PRDM16” ## [33] “RUNX1” “SMAD1” “SPI1” “STAT2” “TCF3” “TCF4” “UBP1” p &lt;- ggplot(data.frame(corGIM_MM), aes(cor, maxDelta, color = TFRegulator)) + geom_point() + theme_ArchR() + geom_vline(xintercept = 0, lty = &quot;dashed&quot;) + scale_color_manual(values = c(&quot;NO&quot;=&quot;darkgrey&quot;, &quot;YES&quot;=&quot;firebrick3&quot;)) + xlab(&quot;Correlation To Gene Expression&quot;) + ylab(&quot;Max TF Motif Delta&quot;) + scale_y_continuous( expand = c(0,0), limits = c(0, max(corGIM_MM$maxDelta)*1.05) ) p ## Warning: Removed 255 rows containing missing values (geom_point). "],
["trajectory-analysis-with-archr.html", "Chapter 16 Trajectory Analysis with ArchR ", " Chapter 16 Trajectory Analysis with ArchR "],
["myeloid-trajectory.html", "16.1 Myeloid Trajectory", " 16.1 Myeloid Trajectory p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1326ab29a8-Date-2020-04-15_Time-14-59-47.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1326ab29a8-Date-2020-04-15_Time-14-59-47.log p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1339bfbfcf-Date-2020-04-15_Time-14-59-49.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1339bfbfcf-Date-2020-04-15_Time-14-59-49.log ggAlignPlots(p1, p2, type = &quot;h&quot;) #Trajectory to add trajectory &lt;- c(&quot;Progenitor&quot;, &quot;GMP&quot;, &quot;Mono&quot;) trajectory ## [1] “Progenitor” “GMP” “Mono” #First we need to create a Trajectory and add it to ArchRProj cellColData projHeme5 &lt;- addTrajectory( ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, groupBy = &quot;Clusters2&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE ) ## ArchR logging to : ArchRLogs/ArchR-addTrajectory-15e132f14b12b-Date-2020-04-15_Time-15-00-01.log ## If there is an issue, please report to github with logFile! ## Filtering outliers ## Initial Alignment Before Spline Fit ## Spline Fit ## KNN to Spline ## Aligning cells not in trajectory ## ArchR logging successful to : ArchRLogs/ArchR-addTrajectory-15e132f14b12b-Date-2020-04-15_Time-15-00-01.log head(projHeme5$MyeloidU[!is.na(projHeme5$MyeloidU)]) #NA means not in trajectory ## [1] 46.07479 53.75027 44.82834 43.18828 47.49617 43.21015 p &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;colData&quot;, name = &quot;MyeloidU&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e136ad2f619-Date-2020-04-15_Time-15-00-03.log ## If there is an issue, please report to github with logFile! ## Plotting ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e136ad2f619-Date-2020-04-15_Time-15-00-03.log p[[1]] ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p, name = &quot;Plot-MyeloidU-Traj-UMAP.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## [1] “plotting ggplot!” ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## [1] 0 We can overlay other features on the UMAP projHeme5 &lt;- addImputeWeights(projHeme5) ## 2020-04-15 15:00:28 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed. ## 2020-04-15 15:00:40 : Completed Getting Magic Weights!, 0.206 mins elapsed. p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;horizonExtra&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e13179524ae-Date-2020-04-15_Time-15-00-40.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e13179524ae-Date-2020-04-15_Time-15-00-40.log p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;blueYellow&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e133644196a-Date-2020-04-15_Time-15-00-47.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e133644196a-Date-2020-04-15_Time-15-00-47.log ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 5678 rows containing non-finite values (stat_summary_hex). ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ We can then make a heatmap for trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Some values are below 0, this could be a DeviationsMatrix in which scaleTo should be set = NULL. ## Continuing without depth normalization! ## Smoothing… p1 &lt;- trajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131c8ea2de-Date-2020-04-15_Time-15-01-31.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:01:31 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:01:31 : ## Removing rows with NA values… ## 2020-04-15 15:01:31 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131c8ea2de-Date-2020-04-15_Time-15-01-31.log trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p2 &lt;- trajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e132f1f4173-Date-2020-04-15_Time-15-01-51.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e132f1f4173-Date-2020-04-15_Time-15-01-51.log trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Smoothing… p3 &lt;- trajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1333158a4-Date-2020-04-15_Time-15-02-18.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1333158a4-Date-2020-04-15_Time-15-02-18.log trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p4 &lt;- trajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131ecfb872-Date-2020-04-15_Time-15-03-01.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131ecfb872-Date-2020-04-15_Time-15-03-01.log To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, p2, p3, p4, name = &quot;Plot-MyeloidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) ## [1] 0 We can also perform integrative analyses such as identifying positive regulators with RNA #Gene Scores corGSM_MM &lt;- correlateTrajectories(trajGSM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e13b9ca02a-Date-2020-04-15_Time-15-03-37.log ## If there is an issue, please report to github with logFile! ## Found 36 Correlated Pairings! ## 2020-04-15 15:03:56 : corGSM_MM[[1]]$matchname1 ## [1] “PRDM16” “TAL1” “JUN” “ATF3” “GATA3” “GATA3” “ZEB1” “NFKB2” ## [9] “IRF7” “KLF12” “FOS” “MEF2A” “IRF8” “NR1D1” “HOXB1” “JUNB” ## [17] “NFIX” “LYL1” “KLF2” “FOSB” “NR1H2” “KLF11” “GLI2” “NR4A2” ## [25] “TCF15” “CEBPB” “ETS2” “XBP1” “GATA2” “MECOM” “IRF1” “CEBPD” ## [33] “SNAI2” “NFIL3” “KLF4” “RXRA” corGSM_MM[[1]] ## DataFrame with 36 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 82 1081 PRDM16 PRDM16 chr1:PRDM16 z:PRDM16_211 ## 2 731 932 TAL1 TAL1 chr1:TAL1 z:TAL1_62 ## 3 818 1013 JUN JUN chr1:JUN z:JUN_143 ## 4 2034 1002 ATF3 ATF3 chr1:ATF3 z:ATF3_132 ## 5 2369 1254 GATA3 GATA3 chr10:GATA3 z:GATA3_384 ## … … … … … … … ## 32 20775 1022 CEBPD CEBPD chr8:CEBPD z:CEBPD_152 ## 33 20780 1031 SNAI2 SNAI2 chr8:SNAI2 z:SNAI2_161 ## 34 21658 1003 NFIL3 NFIL3 chr9:NFIL3 z:NFIL3_133 ## 35 21793 1078 KLF4 KLF4 chr9:KLF4 z:KLF4_208 ## 36 22097 1565 RXRA RXRA chr9:RXRA z:RXRA_695 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.859588836579798 0.999783802481948 0.860344827586207 16.6530781620713 ## 2 0.687938524545333 0.866735849872443 0.987931034482759 9.38348743943718 ## 3 0.530335586469274 0.993989708998141 0.963218390804598 6.19265152142139 ## 4 0.776280918431044 0.985168850261599 0.936781609195402 12.1905867620732 ## 5 0.714559116657296 0.801573917931422 0.989655172413793 10.111530171907 ## … … … … … ## 32 0.73809434207349 0.993816750983699 0.998275862068966 10.8296844080467 ## 33 0.643337129188769 0.87252994335625 0.983333333333333 8.31877485229719 ## 34 0.833740261914099 0.992303368357331 0.893103448275862 14.9479403447508 ## 35 0.82265894955927 0.998702814891685 0.905747126436782 14.3243696597426 ## 36 0.59509316489084 0.88640982401522 0.890229885057471 7.33039570155334 ## Pval FDR ## ## 1 2.47466579579935e-30 4.04855324192774e-27 ## 2 2.63756432350363e-15 1.00350121703533e-13 ## 3 1.38781951660218e-08 1.55511830764464e-07 ## 4 2.36537648993666e-21 3.22479661461365e-19 ## 5 6.9322610846337e-17 3.78039304482025e-15 ## … … … ## 32 1.93304822797782e-18 1.31769454207155e-16 ## 33 5.27319420246801e-13 1.3914428572964e-11 ## 34 5.06319064599113e-27 2.70186610322912e-24 ## 35 8.9984663184347e-26 2.45358181615986e-23 ## 36 6.60626612679289e-11 1.25672690505037e-09 #We can plot these identified regulators trajGSM2 &lt;- trajGSM[corGSM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGSM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGSM2 assay(trajCombined) &lt;- t(apply(assay(trajGSM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e136ff55add-Date-2020-04-15_Time-15-03-56.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e136ff55add-Date-2020-04-15_Time-15-03-56.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGSM2)) #Now we can plot the heatmaps ht1 &lt;- trajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e13aac5f3b-Date-2020-04-15_Time-15-03-57.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e13aac5f3b-Date-2020-04-15_Time-15-03-57.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1323caf784-Date-2020-04-15_Time-15-03-57.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:03:58 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:03:58 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1323caf784-Date-2020-04-15_Time-15-03-57.log ht1 + ht2 #Gene Expression corGIM_MM &lt;- correlateTrajectories(trajGIM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e13f7dfd04-Date-2020-04-15_Time-15-04-14.log ## If there is an issue, please report to github with logFile! ## Found 54 Correlated Pairings! ## 2020-04-15 15:04:30 : corGIM_MM[[1]]$matchname1 ## [1] “RUNX3” “NFIA” “MEF2D” “USF1” “ATF3” “ZEB1” “NFKB2” ## [8] “IRF7” “SPI1” “ESRRA” “STAT2” “FOS” “JDP2” “KLF13” ## [15] “CTCF” “IRF8” “RARA” “MLX” “MBD2” “TCF4” “HMG20B” ## [22] “JUNB” “LYL1” “KLF2” “JUND” “CEBPA” “USF2” “FOSB” ## [29] “FOSL2” “REL” “NR4A2” “SP3” “NFE2L2” “STAT1” “KLF7” ## [36] “TGIF2” “CEBPB” “BACH1” “RUNX1” “BHLHE40” “GATA2” “HLTF” ## [43] “REST” “MEF2C” “RREB1” “TFEB” “PLAGL1” “CREB5” “CEBPD” ## [50] “KLF10” “NFIL3” “KLF4” “RXRA” “TFE3” corGIM_MM[[1]] ## DataFrame with 54 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 295 1601 RUNX3 RUNX3 chr1:RUNX3 z:RUNX3_731 ## 2 680 1612 NFIA NFIA chr1:NFIA z:NFIA_742 ## 3 1227 1512 MEF2D MEF2D chr1:MEF2D z:MEF2D_642 ## 4 1317 930 USF1 USF1 chr1:USF1 z:USF1_60 ## 5 1664 1002 ATF3 ATF3 chr1:ATF3 z:ATF3_132 ## … … … … … … … ## 50 16981 1696 KLF10 KLF10 chr8:KLF10 z:KLF10_826 ## 51 17463 1003 NFIL3 NFIL3 chr9:NFIL3 z:NFIL3_133 ## 52 17560 1078 KLF4 KLF4 chr9:KLF4 z:KLF4_208 ## 53 17803 1565 RXRA RXRA chr9:RXRA z:RXRA_695 ## 54 18090 888 TFE3 TFE3 chrX:TFE3 z:TFE3_18 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.506721180509532 0.871189720982743 0.98448275862069 5.81861222342308 ## 2 0.899884055575892 0.878017310897264 0.919540229885057 20.4260514493749 ## 3 0.787682536829653 0.815493790656416 0.841379310344828 12.656866457322 ## 4 0.653303634000368 0.804204075049728 0.875287356321839 8.54234597517229 ## 5 0.847460093565636 0.813020805333047 0.936781609195402 15.8034906427774 ## … … … … … ## 50 0.57964654735637 0.953335842159024 0.864367816091954 7.04188649257934 ## 51 0.849563937747037 0.933928283425622 0.893103448275862 15.9440428922802 ## 52 0.820699669277503 0.98876404494382 0.905747126436782 14.2196070232556 ## 53 0.899871735441299 0.960485995376593 0.890229885057471 20.424581355724 ## 54 0.832322259515336 0.801247244771786 0.886206896551724 14.8650341763864 ## Pval FDR ## ## 1 7.47838268446286e-08 2.00835886256963e-07 ## 2 4.28849849649256e-37 2.40519926139511e-35 ## 3 2.45911764921563e-22 2.0096926995314e-21 ## 4 1.7427906036477e-13 7.90509804908143e-13 ## 5 1.05531067509617e-28 1.5631789374862e-27 ## … … … ## 50 2.63272438071192e-10 8.66605108651006e-10 ## 51 5.63648466586524e-29 9.05658892074619e-28 ## 52 1.46590261078753e-25 1.5687313439583e-24 ## 53 4.31312103836676e-37 2.40519926139511e-35 ## 54 7.4030081939147e-27 8.88360983269764e-26 #We can plot these identified regulators trajGIM2 &lt;- trajGIM[corGIM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGIM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGIM2 assay(trajCombined) &lt;- t(apply(assay(trajGIM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e137bbcc972-Date-2020-04-15_Time-15-04-30.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e137bbcc972-Date-2020-04-15_Time-15-04-30.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGIM2)) #Now we can plot the heatmaps ht1 &lt;- trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1331e06f29-Date-2020-04-15_Time-15-04-31.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1331e06f29-Date-2020-04-15_Time-15-04-31.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1345e2da25-Date-2020-04-15_Time-15-04-32.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:04:32 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:04:32 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1345e2da25-Date-2020-04-15_Time-15-04-32.log ht1 + ht2 "],
["lymphoid-trajectory.html", "16.2 Lymphoid Trajectory", " 16.2 Lymphoid Trajectory p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1340853c58-Date-2020-04-15_Time-15-04-41.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1340853c58-Date-2020-04-15_Time-15-04-41.log p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-15e1326401e05-Date-2020-04-15_Time-15-04-42.log ## If there is an issue, please report to github with logFile! ## Getting UMAP Embedding ## ColorBy = cellColData ## Plotting Embedding ## 1 ## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-15e1326401e05-Date-2020-04-15_Time-15-04-42.log ggAlignPlots(p1, p2, type = &quot;h&quot;) #Trajectory to add trajectory &lt;- c(&quot;Progenitor&quot;, &quot;CLP&quot;, &quot;PreB&quot;, &quot;B&quot;) trajectory ## [1] “Progenitor” “CLP” “PreB” “B” #First we need to create a Trajectory and add it to ArchRProj cellColData projHeme5 &lt;- addTrajectory( ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, groupBy = &quot;Clusters2&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE ) ## ArchR logging to : ArchRLogs/ArchR-addTrajectory-15e1351d16b68-Date-2020-04-15_Time-15-04-55.log ## If there is an issue, please report to github with logFile! ## Filtering outliers ## Initial Alignment Before Spline Fit ## Spline Fit ## KNN to Spline ## Aligning cells not in trajectory ## ArchR logging successful to : ArchRLogs/ArchR-addTrajectory-15e1351d16b68-Date-2020-04-15_Time-15-04-55.log head(projHeme5$LymphoidU[!is.na(projHeme5$LymphoidU)]) #NA means not in trajectory ## [1] 87.630792 81.913303 84.342302 81.763827 83.632287 4.073244 p &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;colData&quot;, name = &quot;LymphoidU&quot;) ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e1377b52455-Date-2020-04-15_Time-15-04-56.log ## If there is an issue, please report to github with logFile! ## Plotting ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e1377b52455-Date-2020-04-15_Time-15-04-56.log p[[1]] ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p, name = &quot;Plot-LymphoidU-Traj-UMAP.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) ## [1] “plotting ggplot!” ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## [1] “plotting ggplot!” ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## [1] 0 We can overlay other features on the UMAP p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;horizonExtra&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e13576dc585-Date-2020-04-15_Time-15-05-20.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e13576dc585-Date-2020-04-15_Time-15-05-20.log p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;blueYellow&quot;) ## Getting ImputeWeights ## ArchR logging to : ArchRLogs/ArchR-plotTrajectory-15e13ed9c20a-Date-2020-04-15_Time-15-05-27.log ## If there is an issue, please report to github with logFile! ## Getting Matrix Values… ## Getting Matrix Values… ## ## Imputing Matrix ## Using weights on disk ## Using weights on disk ## Plotting ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Plotting Trajectory ## Adding Inferred Arrow Trajectory to Plot ## ArchR logging successful to : ArchRLogs/ArchR-plotTrajectory-15e13ed9c20a-Date-2020-04-15_Time-15-05-27.log ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ## Warning: Removed 7575 rows containing non-finite values (stat_summary_hex). ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ ## geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’ We can then make a heatmap for trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Some values are below 0, this could be a DeviationsMatrix in which scaleTo should be set = NULL. ## Continuing without depth normalization! ## Smoothing… p1 &lt;- trajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e133830d097-Date-2020-04-15_Time-15-06-14.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:06:15 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:06:15 : ## Removing rows with NA values… ## 2020-04-15 15:06:15 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e133830d097-Date-2020-04-15_Time-15-06-14.log trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p2 &lt;- trajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e13357a3282-Date-2020-04-15_Time-15-06-36.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e13357a3282-Date-2020-04-15_Time-15-06-36.log trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE) ## Creating Trajectory Group Matrix.. ## Smoothing… p3 &lt;- trajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131325dad9-Date-2020-04-15_Time-15-07-06.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131325dad9-Date-2020-04-15_Time-15-07-06.log trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE) ## Creating Trajectory Group Matrix.. ## Smoothing… p4 &lt;- trajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1351d7cd4d-Date-2020-04-15_Time-15-07-48.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1351d7cd4d-Date-2020-04-15_Time-15-07-48.log To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, p2, p3, p4, name = &quot;Plot-LymphoidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) ## [1] 0 We can also perform integrative analyses such as identifying positive regulators with RNA #Gene Scores corGSM_MM &lt;- correlateTrajectories(trajGSM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e133e72f66-Date-2020-04-15_Time-15-08-26.log ## If there is an issue, please report to github with logFile! ## Found 16 Correlated Pairings! ## 2020-04-15 15:08:47 : corGSM_MM[[1]]$matchname1 ## [1] “CREM” “NFE2” “FOXO1” “JDP2” “MAFG” “MAFG” “RFX2” “KLF2” ## [9] “CEBPA” “CEBPA” “FOSL2” “BCL11A” “GATA2” “IRF2” “IRF4” “PAX5” corGSM_MM[[1]] ## DataFrame with 16 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 2503 978 CREM CREM chr10:CREM z:CREM_108 ## 2 5181 989 NFE2 NFE2 chr12:NFE2 z:NFE2_119 ## 3 5958 1231 FOXO1 FOXO1 chr13:FOXO1 z:FOXO1_361 ## 4 6721 995 JDP2 JDP2 chr14:JDP2 z:JDP2_125 ## 5 10077 1018 MAFG MAFG chr17:MAFG z:MAFG_148 ## … … … … … … … ## 12 12398 1064 BCL11A BCL11A chr2:BCL11A z:BCL11A_194 ## 13 15802 1258 GATA2 GATA2 chr3:GATA2 z:GATA2_388 ## 14 17102 1504 IRF2 IRF2 chr4:IRF2 z:IRF2_634 ## 15 18161 1502 IRF4 IRF4 chr6:IRF4 z:IRF4_632 ## 16 21499 1579 PAX5 PAX5 chr9:PAX5 z:PAX5_709 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.592000045415225 0.812340554330436 0.875287356321839 7.27165360687288 ## 2 0.762361661991419 0.993427595451204 0.989655172413793 11.6618731859923 ## 3 0.658467426103544 0.855580057940935 0.879310344827586 8.66119456905554 ## 4 0.649844641802372 0.819518311929779 0.991954022988506 8.46390278863183 ## 5 0.502090536187102 0.886798979547715 0.935632183908046 5.74740534991767 ## … … … … … ## 12 0.609993999834133 0.867557400441043 0.968965517241379 7.62062915462215 ## 13 0.549172289236984 0.945561464954382 0.986781609195402 6.5052874492361 ## 14 0.643963832332729 0.828685086695205 0.970114942528736 8.33261518735298 ## 15 0.536406221175027 0.8282526916591 0.952873563218391 6.2919464214338 ## 16 0.803092200275283 0.978942361741687 0.962068965517241 13.3425248033796 ## Pval FDR ## ## 1 8.76476821331047e-11 4.6198810517901e-09 ## 2 3.15171893793416e-20 1.02998174891688e-17 ## 3 9.66043618744996e-14 1.43501388457211e-11 ## 4 2.57124018372512e-13 3.50117205017237e-11 ## 5 1.02530728526766e-07 2.83957983750399e-06 ## … … … ## 12 1.62079037573397e-11 1.10348811414554e-09 ## 13 3.29134663353072e-09 1.25071172074167e-07 ## 14 4.92446003514203e-13 6.18966745955545e-11 ## 15 8.81247545774464e-09 2.93869079550097e-07 ## 16 9.15917087670499e-24 3.74152130313399e-21 #We can plot these identified regulators trajGSM2 &lt;- trajGSM[corGSM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGSM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGSM2 assay(trajCombined) &lt;- t(apply(assay(trajGSM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e136c64f4ee-Date-2020-04-15_Time-15-08-47.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e136c64f4ee-Date-2020-04-15_Time-15-08-47.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGSM2)) ht1 &lt;- trajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1344a2d751-Date-2020-04-15_Time-15-08-47.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1344a2d751-Date-2020-04-15_Time-15-08-47.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e1365304b53-Date-2020-04-15_Time-15-08-48.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:08:49 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:08:49 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e1365304b53-Date-2020-04-15_Time-15-08-48.log ht1 + ht2 #Gene Expression corGIM_MM &lt;- correlateTrajectories(trajGIM, trajMM) ## ArchR logging to : ArchRLogs/ArchR-correlateTrajectories-15e134c10b516-Date-2020-04-15_Time-15-09-05.log ## If there is an issue, please report to github with logFile! ## Found 37 Correlated Pairings! ## 2020-04-15 15:09:20 : corGIM_MM[[1]]$matchname1 ## [1] “NFIA” “NFKB2” “IRF7” “ETS1” “NFE2” “STAT2” “FOXO1” ## [8] “IRF9” “FOS” “MEF2A” “IRF8” “MAFG” “TCF4” “TCF3” ## [15] “NFIC” “KLF2” “CEBPA” “POU2F2” “FOSB” “FOSL2” “REL” ## [22] “NFE2L2” “CREB1” “RUNX1” “ATF4” “SMARCC1” “FOXP1” “GATA2” ## [29] “HLTF” “REST” “LEF1” “IRF2” “MEF2C” “IRF1” “EBF1” ## [36] “TFEB” “PAX5” corGIM_MM[[1]] ## DataFrame with 37 rows and 12 columns ## idx1 idx2 matchname1 matchname2 name1 name2 ## ## 1 680 1612 NFIA NFIA chr1:NFIA z:NFIA_742 ## 2 2428 1584 NFKB2 NFKB2 chr10:NFKB2 z:NFKB2_714 ## 3 2625 1505 IRF7 IRF7 chr11:IRF7 z:IRF7_635 ## 4 3790 1202 ETS1 ETS1 chr11:ETS1 z:ETS1_332 ## 5 4287 989 NFE2 NFE2 chr12:NFE2 z:NFE2_119 ## … … … … … … … ## 33 14165 1510 MEF2C MEF2C chr5:MEF2C z:MEF2C_640 ## 34 14287 1499 IRF1 IRF1 chr5:IRF1 z:IRF1_629 ## 35 14558 937 EBF1 EBF1 chr5:EBF1 z:EBF1_67 ## 36 15164 902 TFEB TFEB chr6:TFEB z:TFEB_32 ## 37 17354 1579 PAX5 PAX5 chr9:PAX5 z:PAX5_709 ## Correlation VarAssay1 VarAssay2 TStat ## ## 1 0.776554032919386 0.895435729261868 0.955747126436782 12.2013882485613 ## 2 0.842642341279197 0.893070265039514 0.88735632183908 15.4914421620131 ## 3 0.829368082571345 0.919144132035912 0.91551724137931 14.6953411117392 ## 4 0.85457028998599 0.947529702704156 0.901724137931034 16.2896821299438 ## 5 0.710070464598055 0.928874791677867 0.989655172413793 9.98300419241652 ## … … … … … ## 33 0.65886205886934 0.990860706413634 0.904597701149425 8.67036514488553 ## 34 0.852573236159675 0.977151766034084 0.981609195402299 16.1498641717228 ## 35 0.947958169110169 0.986344820170959 0.992528735632184 29.4737987999312 ## 36 0.71455800087286 0.934842212784259 0.842528735632184 10.1114979100535 ## 37 0.835610609654717 0.968066232998226 0.962068965517241 15.0587807907066 ## Pval FDR ## ## 1 2.24403341264388e-21 3.40224420626652e-20 ## 2 4.28486739529724e-28 1.38888805226876e-26 ## 3 1.61521163596779e-26 4.05409887519786e-25 ## 4 1.21844806414286e-29 5.72670590147145e-28 ## 5 1.31753444224449e-16 1.51034436062174e-15 ## … … … ## 33 9.23012667696911e-14 7.74671346102765e-13 ## 34 2.25997962853195e-29 9.23643848182623e-28 ## 35 1.65431752552523e-50 3.88764618498429e-48 ## 36 6.93337834458196e-17 8.04614277025561e-16 ## 37 3.05084830514743e-27 8.43469825540759e-26 #We can plot these identified regulators trajGIM2 &lt;- trajGIM[corGIM_MM[[1]]$name1, ] trajMM2 &lt;- trajMM[corGIM_MM[[1]]$name2, ] #To Order We Can Create a Trajectory of these assays Multiplied trajCombined &lt;- trajGIM2 assay(trajCombined) &lt;- t(apply(assay(trajGIM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale)) #We can get the row order from the heatmap function combinedMat &lt;- trajectoryHeatmap(trajCombined, returnMat = TRUE, varCutOff = 0) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e131cd6b30f-Date-2020-04-15_Time-15-09-21.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e131cd6b30f-Date-2020-04-15_Time-15-09-21.log rowOrder &lt;- match(rownames(combinedMat), rownames(trajGIM2)) #Now we can plot the heatmaps ht1 &lt;- trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e137c439868-Date-2020-04-15_Time-15-09-21.log ## If there is an issue, please report to github with logFile! ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e137c439868-Date-2020-04-15_Time-15-09-21.log ht2 &lt;- trajectoryHeatmap(trajMM2, pal = paletteContinuous(set = &quot;solarExtra&quot;), varCutOff = 0, rowOrder = rowOrder) ## ArchR logging to : ArchRLogs/ArchR-trajectoryHeatmap-15e13755647e8-Date-2020-04-15_Time-15-09-22.log ## If there is an issue, please report to github with logFile! ## useSeqnames is NULL or greater than 1 with a Sparse.Assays.Matrix trajectory input. ## 2020-04-15 15:09:23 : ## force=FALSE thus continuing with subsetting useSeqnames = z ## 2020-04-15 15:09:23 : ## Preparing Main Heatmap.. ## ArchR logging successful to : ArchRLogs/ArchR-trajectoryHeatmap-15e13755647e8-Date-2020-04-15_Time-15-09-22.log ht1 + ht2 "],
["plot-aesthetics-in-archr.html", "Chapter 17 Plot aesthetics in ArchR", " Chapter 17 Plot aesthetics in ArchR Coming soon… "],
["session-information.html", "Chapter 18 Session Information", " Chapter 18 Session Information This tutorial was run on the date specified below. Sys.Date() ## [1] “2020-04-15” The sessionInfo() at run time was: sessionInfo() ## R version 3.6.1 (2019-07-05) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: CentOS Linux 7 (Core) ## ## Matrix products: default ## BLAS/LAPACK: /share/software/user/open/openblas/0.2.19/lib/libopenblasp-r0.2.19.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] grid parallel stats4 stats graphics grDevices utils ## [8] datasets methods base ## ## other attached packages: ## [1] circlize_0.4.8 ComplexHeatmap_2.2.0 ## [3] gridExtra_2.3 pdftools_2.3 ## [5] gtable_0.3.0 ggrastr_0.1.7 ## [7] ArchR_0.9.1 magrittr_1.5 ## [9] rhdf5_2.30.1 Matrix_1.2-17 ## [11] data.table_1.12.8 SummarizedExperiment_1.16.1 ## [13] DelayedArray_0.12.2 BiocParallel_1.20.1 ## [15] matrixStats_0.56.0 Biobase_2.46.0 ## [17] GenomicRanges_1.38.0 GenomeInfoDb_1.22.1 ## [19] IRanges_2.20.2 S4Vectors_0.24.3 ## [21] BiocGenerics_0.32.0 ggplot2_3.2.1 ## ## loaded via a namespace (and not attached): ## [1] nlme_3.1-140 bitops_1.0-6 ## [3] fs_1.3.1 usethis_1.5.1 ## [5] devtools_2.2.1 RColorBrewer_1.1-2 ## [7] rprojroot_1.3-2 tools_3.6.1 ## [9] backports_1.1.6 R6_2.4.1 ## [11] mgcv_1.8-28 lazyeval_0.2.2 ## [13] colorspace_1.4-1 GetoptLong_0.1.8 ## [15] withr_2.1.2 tidyselect_1.0.0 ## [17] prettyunits_1.1.1 processx_3.4.1 ## [19] curl_4.3 compiler_3.6.1 ## [21] cli_2.0.1 Cairo_1.5-10 ## [23] desc_1.2.0 labeling_0.3 ## [25] rtracklayer_1.46.0 scales_1.1.0 ## [27] hexbin_1.28.1 askpass_1.1 ## [29] callr_3.4.1 nabor_0.5.0 ## [31] stringr_1.4.0 digest_0.6.25 ## [33] Rsamtools_2.2.3 rmarkdown_2.1 ## [35] BSgenome.Hsapiens.UCSC.hg19_1.4.0 XVector_0.26.0 ## [37] pkgconfig_2.0.3 htmltools_0.4.0 ## [39] sessioninfo_1.1.1 BSgenome_1.54.0 ## [41] rlang_0.4.5 GlobalOptions_0.1.1 ## [43] farver_2.0.3 shape_1.4.4 ## [45] gtools_3.8.2 dplyr_0.8.4 ## [47] RCurl_1.98-1.1 GenomeInfoDbData_1.2.2 ## [49] Rcpp_1.0.4 munsell_0.5.0 ## [51] Rhdf5lib_1.8.0 fansi_0.4.1 ## [53] lifecycle_0.1.0 stringi_1.4.6 ## [55] yaml_2.2.1 zlibbioc_1.32.0 ## [57] pkgbuild_1.0.6 ggrepel_0.8.1 ## [59] crayon_1.3.4 lattice_0.20-38 ## [61] splines_3.6.1 Biostrings_2.54.0 ## [63] knitr_1.27 ps_1.3.2 ## [65] pillar_1.4.3 rjson_0.2.20 ## [67] codetools_0.2-16 pkgload_1.0.2 ## [69] XML_3.99-0.3 glue_1.4.0 ## [71] evaluate_0.14 qpdf_1.1 ## [73] remotes_2.1.0 png_0.1-7 ## [75] testthat_2.3.1 purrr_0.3.3 ## [77] clue_0.3-57 assertthat_0.2.1 ## [79] xfun_0.12 tibble_2.1.3 ## [81] GenomicAlignments_1.22.1 memoise_1.1.0 ## [83] cluster_2.1.0 ellipsis_0.3.0 "]
]
