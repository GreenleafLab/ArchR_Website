[
["index.html", "ArchR: Robust and scaleable analysis of single-cell chromatin accessibility data. ", " ArchR: Robust and scaleable analysis of single-cell chromatin accessibility data. Jeffrey Granja and Ryan Corces 2020-03-31 ArchR is a full-featured software suite for the analysis of single-cell chromatin accessibility data. It is designed to handle hundreds of thousands of single cells without large memory or computational requirements, keeping pace with the experimental scale that is achievable with commercial platforms such as the 10x Genomics Chromium system. This website is a complete user’s guide to ArchR. We explain how to use ArchR by walking through examples of every analysis we could think of. We also include some more extensive documention on some of the more salient points of scATAC-seq analysis such as dimensionality reduction and clustering. All of the chapters will utilize the same gold-standard downsampled dataset of hematopoietic cells Granja* et al. Nature Biotechnology 2019. Each chapter will build on the previous and we provide intermediate files for you to jump in at any point. Importantly, these tutorials assume that you are running ArchR locally. This walkthrough assumes that you have already successfully installed ArchR and all dependencies. If that is not the case, please visit the home page for installation instructions. Cant find what you are looking for? There is a search feature that can be enabled using the magnifying glass in the navigation bar above which will help you find whatever it is you are looking for. If you dont find it in this book, or if you think the documentation on this website or in the function annotations is unclear, please submit an issue on Github with the documentation tag and we will do our best to clarify. If none of these options help, send us an email and we will do our best to respond in a timely fashion. "],
["getting-started-with-archr.html", "Chapter 1 Getting Started with ArchR", " Chapter 1 Getting Started with ArchR This chapter will introduce you to how to import data into ArchR and how to create ArrowFiles, the base unit of ArchR analysis. "],
["a-brief-primer-on-atac-seq-terminology.html", "1.1 A Brief Primer on ATAC-seq Terminology", " 1.1 A Brief Primer on ATAC-seq Terminology The most fundamental component of any ATAC-seq experiment is a “fragment”. In ATAC-seq, a fragment refers to a sequenceable DNA molecule created by two transposition events. Each end of that fragment is sequenced using paired-end sequencing. The inferred single-base position of the start and end of the fragment is adjusted based on the insertion offset of Tn5. As reported previously26, Tn5 transposase binds to DNA as a homodimer with 9-bp of DNA between the two Tn5 molecules. Because of this, each Tn5 homodimer binding event creates two insertions, separated by 9 bp. Thus, the actual central point of the “accessible” site is in the very center of the Tn5 dimer, not the location of each Tn5 insertion. To account for this, we apply an offset to the individual Tn5 insertions, adjusting plus-stranded insertion events by +4 bp and minus-stranded insertion events by -5 bp. This is consistent with the convention put forth during the original description of ATAC-seq27. Thus, in ArchR, “fragments” refers to a table or genomic ranges containing the chromosome, offset-adjusted chromosome start position, offset-adjusted chromosome end position, and unique cellular barcode ID corresponding to each sequenced fragment. Similarly, “insertions” refer to the offset-adjuset single-base position at the very center of an accessible site. "],
["why-use-archr.html", "1.2 Why use ArchR?", " 1.2 Why use ArchR? QQQ include some benchmarking figures "],
["what-is-an-arrow-file-archrproject.html", "1.3 What is an Arrow file / ArchRProject?", " 1.3 What is an Arrow file / ArchRProject? The base unit of an analytical project in ArchR is called an Arrow file. Each Arrow file stores all of the data associated with an individual sample (i.e. metadata, accessible fragments, and data matrices). Here, an “individual sample” would be the most detailed unit of analysis desired (for ex. a single replicate of a particular condition). During creation and as additional analyses are performed, ArchR updates and edits each Arrow file to contain additional layers of information. It is worth noting that, to ArchR, an Arrow file is actually just a path to an external file stored on disk. More explicitly, an Arrow file is not an R-language object that is stored in memory but rather an HDF5-format file stored on disk. Because of this, we use an ArchRProject object to associate these Arrow files together into a single analytical framework that can be rapidly accessed in R. This ArchRProject object is small in size and is stored in memory. Certain actions can be taken directly on Arrow files while other actions are taken on an ArchRProject which in turn updates each associated Arrow file. Because Arrow files are stored as large HDF5-format files, “get-er” functions in ArchR retrieve data by interacting with the ArchRProject while “add-er” functions either (i) add data directly to Arrow files, (ii) add data directly to an ArchRProject, or (iii) add data to Arrow files by interacting with an ArchRProject. "],
["input-file-types-in-archr.html", "1.4 Input File Types in ArchR", " 1.4 Input File Types in ArchR QQQ "],
["getting-set-up.html", "1.5 Getting Set Up", " 1.5 Getting Set Up The first thing we do is set up our working directory and set the number of threads we would like to use, and load our gene and genome annotations. Depending on the configuration of your local environment, you may need to modify the number of threads used below in addArchRThreads(). By default ArchR uses half of the total number of threads available but you can adjust this manually as you see fit. If you are using windows, the usable threads will automatically be set to 1 because the parallel processing in ArchR is build for Unix-based operating systems. #Load R Libraries library(ArchR) #Create a new folder and set this as the working directory for tutorial analyses wd &lt;- &quot;ArchR_Walkthrough&quot; dir.create(wd, showWarnings = FALSE, recursive = TRUE) setwd(wd) #Set Default Threads for ArchR Functions #The recommendation is to set it around 1/2 to 3/4 of the total available cores. addArchRThreads(threads = 6) #Set Gene and Genome Annotations to be used addArchRGenome(&quot;hg19&quot;) "],
["setting-a-genome-and-geneannotation.html", "1.6 Setting a Genome and GeneAnnotation", " 1.6 Setting a Genome and GeneAnnotation ArchR requires gene and genome annotations to do things such as calculate TSS enrichment scores, nucleotide content, and gene activity scores. Because our tutorial dataset uses scATAC-seq data that has already been aligned to the hg19 reference genome, we have set “hg19” as the default genome above. However, ArchR supports “hg19”, “hg38”, “mm9”, and “mm10” natively but you can create your own using the createGeneAnnotation() and createGenomeAnnotation() functions. Providing this information to ArchR is streamlined through the addArchRGenome() function. This function tells ArchR that, for all analyses in the current session, it should use the genomeAnnotation and geneAnnotation associated with the defined ArchRGenome. Each of the natively supported genomes are composed of a BSgenome object and a GRanges object containing a set of blacklisted regions. Below are examples of how to load gene and genome annotations for the natively supported genomes as well as information on their BSgenome and blacklist components. The precompiled version of the hg19 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg19 and a blacklist that was merged using ArchR::mergeGR() from the hg19 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg19 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg19 genome: addArchRGenome(&quot;hg19&quot;) # Setting default genome to Hg19. The precompiled version of the hg38 genome in ArchR uses BSgenome.Hsapiens.UCSC.hg38 and a blacklist that was merged using ArchR::mergeGR() from the hg38 v2 blacklist regions and from mitochondrial regions that show high mappability to the hg38 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg38 genome: addArchRGenome(&quot;hg38&quot;) # Setting default genome to Hg38. The precompiled version of the mm9 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm9 and a blacklist that was merged using ArchR::mergeGR() from the mm9 v1 blacklist regions from Anshul Kundaje and from mitochondrial regions that show high mappability to the mm9 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled mm9 genome: addArchRGenome(&quot;mm9&quot;) # Setting default genome to Mm9. The precompiled version of the mm10 genome in ArchR uses BSgenome.Mmusculus.UCSC.mm10 and a blacklist that was merged using ArchR::mergeGR() from the mm10 v2 blacklist regions and from mitochondrial regions that show high mappability to the mm10 nuclear genome from Caleb Lareau and Jason Buenrostro. To set a global genome default to the precompiled hg38 genome: addArchRGenome(&quot;mm10&quot;) # Setting default genome to Mm10. 1.6.1 Creating a custom genome annotation To instead create a custom genome annotation, we can use createGenomeAnnotation(). To do this, you will need the following information: A BSgenome object which contains the sequence information for a genome. These are commonly Bioconductor packages (for example, BSgenome.Hsapiens.UCSC.hg38) that can be easily found with google. A GRanges genomic ranges object containing a set of blacklisted regions that will be used to filter out unwanted regions from downstream analysis. This is not required but is recommended. #QQQ CHANGED TO DROSOPHILA TO MAKE THIS RELEVANT SINCE HG38 IS ALREADY SUPPORTED library(BSgenome.Dmelanogaster.UCSC.dm6) genomeAnnotation &lt;- createGenomeAnnotation(genome = BSgenome.Dmelanogaster.UCSC.dm6) # List of length 3 # names(3): genome chromSizes blacklist To create a custom gene annotation for use instead we can use createGeneAnnotation(). To do this, you will need the following information: A TxDb object (transcript database) from Bioconductor which contains information for gene/transcript coordinates. For example, from txdb &lt;- TxDb.Hsapiens.UCSC.hg38.knownGene. An OrgDb object (organism database) from Bioconductor which contains information for gene/transcript symbols from ids. For example, from orgdb &lt;- org.Hs.eg.db. #QQQ DOUBLE CHECK. I CHANGED THIS TO REMOVE THE txdb &lt;- TxDb.Hsapiens.UCSC.hg38.knownGene ASSIGNMENTS TO MAKE IT THE SAME FORMAT AS genomeAnnotation ABOVE #QQQ ALSO CHANGED TO DROSOPHILA library(TxDb.Dmelanogaster.UCSC.dm6.ensGene) library(org.Dm.eg.db) geneAnnotation &lt;- createGeneAnnnotation(TxDb = TxDb.Dmelanogaster.UCSC.dm6.ensGene, OrgDb = org.Dm.eg.db) # List of length 3 # names(3): genes exons TSS Alternatively, if you dont have a TxDb and OrgDb object, you can create a geneAnnotation object from the following information : A GRanges object containing gene coordinates (start to end). Must have a symbols column matching the symbols column of exons. A GRanges object containing gene exon coordinates. Must have a symbols column matching the symbols column of genes. A GRanges object containing standed transcription start site (TSS) coordinates. #QQQ THIS SEEMS ODD. YOU ARE TAKING AN OBJECT NAMED geneAnnotation THAT ALREADY HAS ALL THESE THINGS AND MAKING IT INTO AN OBJECT NAMED geneAnnotation geneAnnotation &lt;- createGeneAnnnotation(TSS = geneAnnotation$TSS, exons = geneAnnotation$exons, genes = geneAnnotation$genes) geneAnnotation # List of length 3 # names(3): genes exons TSS "],
["creating-arrow-files.html", "1.7 Creating Arrow Files", " 1.7 Creating Arrow Files For this tutorial, we will use data from a downsampled dataset of hematopoietic cells Granja* et al. Nature Biotechnology 2019. This includes data from bone marrow mononuclear cells (BMMC), peripheral blood mononuclear cells (PBMC), and CD34+ hematopoietic stem and progenitor cells from bone marrow (CD34 BMMC). This data is downloaded as fragment files which contain the start and end genomic coordinates of all aligned sequenced fragments. Fragment files are one of the base file types of the 10x Genomics analytical platform (and other platforms) and can be easily created from any BAM file. See QQQ for information on making your own fragment files for input to ArchR. Once we have our fragment files, we provide their paths as a character vector to createArrowFiles(). During creation, some basic metadata and matrices are added to each ArrowFile including a “TileMatrix” containing insertion counts across genome-wide 500-bp bins (see addTileMatrix()) and a “GeneScoreMatrix” that is determined based on weighting insertion counts in tiles nearby a gene promoter (see addGeneScoreMatrix()). library(ArchR) #Get Tutorial Data ~0.6GB To Download (if downloaded already ArchR will bypass downloading). inputFiles &lt;- getTutorialData(&quot;Hematopoiesis&quot;) inputFiles # scATAC_BMMC_R1 # &quot;HemeFragments/scATAC_BMMC_R1.fragments.tsv.gz&quot; # scATAC_CD34_BMMC_R1 # &quot;HemeFragments/scATAC_CD34_BMMC_R1.fragments.tsv.gz&quot; # scATAC_PBMC_R1 # &quot;HemeFragments/scATAC_PBMC_R1.fragments.tsv.gz&quot; Now we will create our Arrow Files (10-15 minutes). For each sample, this step will: Read accessible fragments from the provided input files. Calculate quality control information for each cell (i.e. TSS enrichment scores and nucleosome info). Filter cells based on quality control parameters. Create a genome-wide TileMatrix using 500-bp bins. Create a GeneScoreMatrix using the custom geneAnnotation that was defined when we called addArchRGenome(). #Set Genome Annotations to be used to hg19 addArchRGenome(&quot;hg19&quot;) #Set Default Threads for ArchR Functions addArchRThreads(threads = 6) ArrowFiles &lt;- createArrowFiles( inputFiles = inputFiles, sampleNames = names(inputFiles), filterTSS = 4, #Dont set this too high because you can always increase later filterFrags = 1000, addTileMat = TRUE, addGeneScoreMat = TRUE ) ArrowFiles # [1] &quot;scATAC_BMMC_R1.arrow&quot; &quot;scATAC_CD34_BMMC_R1.arrow&quot; # [3] &quot;scATAC_PBMC_R1.arrow&quot; This step will create a folder called “QualityControl” in your current working directory that will contain 2 plots associated with each of your samples: 1. TSS Enrichment Score by log10(Unique Fragments) For BMMC: For CD34 BMMC: For PBMC: 2. Fragment Size Distribution For BMMC : For CD34 BMMC : For PBMC : To download the TSS by Frags PDFs for each sample: Download PDF : scATAC_BMMC_R1-TSS_by_Unique_Frags.pdf Download PDF : scATAC_CD34_BMMC_R1-TSS_by_Unique_Frags.pdf Download PDF : scATAC_PBMC_R1-TSS_by_Unique_Frags.pdf To download the Fragment Sizes PDFs for each sample: Download PDF : scATAC_BMMC_R1-Fragment_Size_Distribution.pdf Download PDF : scATAC_CD34_BMMC_R1-Fragment_Size_Distribution.pdf Download PDF : scATAC_PBMC_R1-Fragment_Size_Distribution.pdf "],
["doublet-inference-with-archr.html", "Chapter 2 Doublet Inference with ArchR", " Chapter 2 Doublet Inference with ArchR One major source of trouble in single-cell data is the contribution of “doublets” to the analysis. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell that is effectively the average of the two cells. We remove these computationally and describe this doublet removal process in depth in this chapter. "],
["inferring-scatac-seq-doublets-with-archr.html", "2.1 Inferring scATAC-seq Doublets with ArchR", " 2.1 Inferring scATAC-seq Doublets with ArchR Single-cell data generated on essentially any platform is susceptible to the presence of doublets. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell. For 10x, the percentage of total “cells” that are actually doublets is proportional to the number of cells loaded into the reaction. Even at the lower levels of doublets that result from standard kit use, more than 5% of the data may come from doublets and this exerts substantial effects on clustering. This issue becomes particularly problematic in the context of developmental/trajectory data because doublets look like a mixture between two cell types and this can be confounded with intermediate cell types or cell states. To predict which “cells” are actually doublets, we synthesize in silico doublets from the data by mixing the reads from thousands of combinations of individual cells. We then project these synthetic doublets into the UMAP embedding and identify their nearest neighbor. By iterating this procedure thousands of times, we can identify “cells” in our data whose signal looks very similar to synthetic doublets. By default ArchR uses the doublet parameters described in the ArchR manuscript. This is likely a good place to start but we encourage all users to inspect the pre- and post-doublet removal data to understand how doublet removal is affecting the cells. We show some of the main adjustable features below to illustrate how this can be customized to a given application. In ArchR, doublet removal is performed in a single step using addDoubletScores(). #Add Infered Doublet Scores to each Arrow File (~2-5 min per sample) #Try ?addDoubletScores to see further documentation on parameters for doublet identification. doubScores &lt;- addDoubletScores( input = ArrowFiles, k = 10, #Refers to how many cells near a &quot;pseudo-doublet&quot; to count. knnMethod = &quot;UMAP&quot;, #Refers to embedding to use for nearest neighbor search with doublet projection. LSIMethod = 1 ) This command will create plots in the “QualityControl” directory. There are 3 plots associated with each of your samples in this folder: 1. Doublet Enrichments - These represent the enrichment of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. For BMMC : For CD34 BMMC : For PBMC : 2. Doublet Scores - These represent the significance (-log10(binomial adjusted p-value)) of simulated doublets nearby each single cell compared to the expected if we assume a uniform distribution. We have found this value to be less consistent than the doublet enrichments and therefore use doublet enrichments for doublet identification. For BMMC : For CD34 BMMC : For PBMC : 3. Doublet Density - This represents the density of the simulated doublet projections so you can visualize where the synthetic doublets were located after projection into your 2-dimensional embedding. For BMMC : For CD34 BMMC : For PBMC : QQQ - I would have liked to see a pre- and post- doublet removal UMAP here so that we can illustrate what happens. To download the PDFs for each sample Download PDF : scATAC_BMMC_R1-Doublet-Summary.pdf Download PDF : scATAC_CD34_BMMC_R1-Doublet-Summary.pdf Download PDF : scATAC_PBMC_R1-Doublet-Summary.pdf "],
["creating-an-archrproject.html", "Chapter 3 Creating an ArchRProject", " Chapter 3 Creating an ArchRProject An ArchRProject allows us to group multiple Arrow files together into a single project. This ArchRProject is small and is stored in memory. By interacting with the ArchRProject we can rapidly push and pull data from the Arrow files. As such, it forms the basis of nearly all ArchR functions and analytical workflows. This chapter describes how to create and interact with an ArchRProject object. "],
["creating-an-archrproject-1.html", "3.1 Creating An ArchRProject", " 3.1 Creating An ArchRProject First, we must create our ArchRProject by providing a list of Arrow files and a few other parameters. The outputDirectory here describes where all downstream analyses and plots will be saved. ArchR will automatically associate the geneAnnotation and genomeAnnotation with the new ArchRProject. These were stored when we ran addArchRGenome(\"hg19\") in a previous chapter. #Create ArchRProject projHeme1 &lt;- ArchRProject( ArrowFiles = ArrowFiles, outputDirectory = &quot;HemeTutorial&quot;, copyArrows = TRUE #This is recommened so that if you modify the ArrowFiles you have an original copy for later usage. ) We call this ArchRProject “projHeme1” because it is the first iteration of our hematopoiesis project. Throughout this walkthrough we will modify and update this ArchRProject and keep track of which version of the project we are using by iterating the project number (i.e. “projHeme2”). Lets look at our ArchRProject: projHeme1 # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 10661 # medianTSS(1): 16.832 # medianFrags(1): 3050 We can see from the above that our ArchRProject has been initialized with a few important attributes: The specified outputDirectory. The sampleNames of each sample which were obtained from the Arrow files. A matrix called sampleColData which contains data associated with each sample. A matrix called cellColData which contains data associated with each cell. Because we already computed doublet enrichment scores (using addDoubletScores()), which added those values to each cell in the Arrow files, we can see columns corresponding to the “DoubletEnrichment” and “DoubletScore” in the cellColData matrix. The total number of cells in our project which represents all samples after doublet identification and removal. The median TSS enrichment score and the median number of fragments across all cells and all samples. We can check how much memory is used to store the ArchRProject in memory within R: paste0(&quot;Memory Size = &quot;, round(object.size(projHeme1) / 10^6, 3), &quot; MB&quot;) #[1] &quot;Memory Size = 37.135 MB&quot; We can also ask which data matrices are available within the ArchRProject which will be useful downstream once we start adding to this project: getAvailableMatrices(projHeme1) #[1] &quot;GeneScoreMatrix&quot; &quot;TileMatrix&quot; "],
["manipulating-an-archrproject.html", "3.2 Manipulating An ArchRProject", " 3.2 Manipulating An ArchRProject Now that we have created an ArchRProject, there are many things that we can do to easily access or manipulate the associated data. Example 1. The $ accessor allows direct access to cellColData #A. Access cell names associated with each cell head(projHeme1$cellNames) # [1] &quot;scATAC_BMMC_R1#TTATGTCAGTGATTAG-1&quot; &quot;scATAC_BMMC_R1#AAGATAGTCACCGCGA-1&quot; # [3] &quot;scATAC_BMMC_R1#GCATTGAAGATTCCGT-1&quot; &quot;scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1&quot; # [5] &quot;scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1&quot; &quot;scATAC_BMMC_R1#AGTTACGAGAACGTCG-1&quot; #B. Access sample names associated with each cell projHeme1$Sample # character-Rle of length 10661 with 3 runs # Lengths: 4932 3275 2454 # Values : &quot;scATAC_BMMC_R1&quot; &quot;scATAC_CD34_BMMC_R1&quot; &quot;scATAC_PBMC_R1&quot; #C. Access TSS Enrichment Scores for each cell quantile(projHeme1$TSSEnrichment) # 0% 25% 50% 75% 100% # 4.027 13.922 16.832 19.937 41.782 Example 2. Subsetting an ArchRProject by cells #A. Subset the project numerically projHeme1[1:100, ] #First 100 cells # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 100 # medianTSS(1): 10.7725 # medianFrags(1): 10200.5 #B. Subset the project using cellNames projHeme1[projHeme1$cellNames[1:100], ] # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 100 # medianTSS(1): 10.7725 # medianFrags(1): 10200.5 #C. Subset the project to return all cells corresponding to a specific sample idxSample &lt;- BiocGenerics::which(projHeme1$Sample %in% &quot;scATAC_BMMC_R1&quot;) cellsSample &lt;- projHeme1$cellNames[idxSample] projHeme1[cellsSample, ] # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 4932 # medianTSS(1): 15.254 # medianFrags(1): 2771 #D. Subset the project based on a specific TSS enrichment score cutoff idxPass &lt;- which(projHeme1$TSSEnrichment &gt;= 8) cellsPass &lt;- projHeme1$cellNames[idxPass] projHeme1[cellsPass, ] # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 10500 # medianTSS(1): 16.9275 # medianFrags(1): 3042 Example 3. Adding data to an ArchRProject #Add a column to cellColData that contains more legible sample names by removing excess info from the original sample names bioNames &lt;- gsub(&quot;_R2|_R1|scATAC_&quot;,&quot;&quot;,projHeme1$Sample) bioNames # character-Rle of length 10661 with 3 runs # Lengths: 4932 3275 2454 # Values : &quot;BMMC&quot; &quot;CD34_BMMC&quot; &quot;PBMC&quot; projHeme1$bioNames &lt;- bioNames #Add a column to cellColData that only contains information for a subset of cells bioNames &lt;- bioNames[1:10] cellNames &lt;- projHeme1$cellNames[1:10] projHeme1 &lt;- addCellColData(ArchRProj = projHeme1, data = paste0(bioNames), cells = cellNames, name = &quot;bioNames2&quot;) #We can compare these two columns to see &quot;NA&quot; filled in where data wasnt available for bioNames2 getCellColData(projHeme1, select = c(&quot;bioNames&quot;, &quot;bioNames2&quot;)) # DataFrame with 10661 rows and 2 columns # bioNames bioNames2 # &lt;character&gt; &lt;character&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 BMMC BMMC # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 BMMC BMMC # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 BMMC BMMC # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 BMMC BMMC # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 BMMC BMMC # ... ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 PBMC NA # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 PBMC NA # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 PBMC NA # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 PBMC NA # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 PBMC NA Example 4. Obtaining unique fragment counts #Select the column from cellColData corresponding to the number of unique #nuclear (non-mitochondrial) fragments per cell df &lt;- getCellColData(projHeme1, select = &quot;nFrags&quot;) df # DataFrame with 10661 rows and 1 column # nFrags # &lt;numeric&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 26189 # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 20648 # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 18991 # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 18296 # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 17458 # ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 1038 # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 1037 # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 1033 # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 1033 # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 1002 #Or, instead of selecting a column by name, we can actually perform operations on a given #column using its column name df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;nFrags - 1&quot;)) df # DataFrame with 10661 rows and 2 columns # log10(nFrags) nFrags - 1 # &lt;numeric&gt; &lt;numeric&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 26188 # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 20647 # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 18990 # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 18295 # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 17457 # ... ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 1037 # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 1036 # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 1032 # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 1032 # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 1001 Example 5. Plotting QC metrics - log10(Unique Fragments) vs TSS enrichment score df &lt;- getCellColData(projHeme1, select = c(&quot;log10(nFrags)&quot;, &quot;TSSEnrichment&quot;)) df # DataFrame with 10661 rows and 2 columns # log10(nFrags) TSSEnrichment # &lt;numeric&gt; &lt;numeric&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 7.149 # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 7.911 # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 4.505 # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 6.946 # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 4.799 # ... ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 24.356 # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 22.537 # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 20.146 # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 30.198 # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 21.485 Now lets plot the number of unique nuclear fragments (log10) by the TSS enrichment score. This type of plot is key for identifying high quality cells. We can further adjust our cutoffs based on this plot if need be. p &lt;- ggPoint( x = df[,1], y = df[,2], colorDensity = TRUE, continuousSet = &quot;sambaNight&quot;, xlabel = &quot;Log10 Unique Fragments&quot;, ylabel = &quot;TSS Enrichment&quot;, xlim = c(log10(500), quantile(df[,1], probs = 0.99)), ylim = c(0, quantile(df[,2], probs = 0.99)) ) + geom_hline(yintercept = 4, lty = &quot;dashed&quot;) + geom_vline(xintercept = 3, lty = &quot;dashed&quot;) p To save an editable vectorized version of this plot, we use plotPDF(). plotPDF(p, name = &quot;TSS-vs-Frags.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE) Download PDF : TSS-vs-Frags.pdf "],
["plotting-sample-statistics-from-an-archrproject.html", "3.3 Plotting Sample Statistics from an ArchRProject", " 3.3 Plotting Sample Statistics from an ArchRProject When working with multiple distinct samples in a single integrated data set, it can be important to compare various metrics across all samples. ArchR provides two main plotting mechanisms for grouped data: ridge plots and violin plots. These are both accessed through the plotGroups() function. Of course, this plot type is not limited to sample-level data and can be used for plotting of downstream group-level information for groups such as clusters. Example 1. Make a ridge plot for each sample for the TSS enrichment scores. To make a ridge plot, we set plotAs = \"ridges\". p1 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;ridges&quot; ) p1 Example 2. Make a violin plot for each sample for the TSS enrichment scores. To make a violin plot, we set plotAs = \"violin\". p2 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) p2 Example 3. Make a ridge plot for each sample for the log10(unique nuclear fragments). p3 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;ridges&quot; ) p3 Example 4. Make a violin plot for each sample for the log10(unique nuclear fragments). p4 &lt;- plotGroups( ArchRProj = projHeme1, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) p4 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2,p3,p4, name = &quot;QC-Sample-Statistics.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 4, height = 4) Download PDF : QC-Sample-Statistics.pdf "],
["plotting-sample-fragment-size-distribution-and-tss-enrichment-profiles-.html", "3.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles.", " 3.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles. Because of how the data is stored and accessed, ArchR can compute fragment size distributions and TSS enrichment profiles from Arrow files very quickly. Fragment size distributions: p1 &lt;- plotFragmentSizes(ArchRProj = projHeme1) p1 TSS enrichment profiles: p2 &lt;- plotTSSEnrichment(ArchRProj = projHeme1) p2 To save editable vectorized versions of these plots, we use plotPDF(). plotPDF(p1,p2, name = &quot;QC-Sample-FragSizes-TSSProfile.pdf&quot;, ArchRProj = projHeme1, addDOC = FALSE, width = 5, height = 5) Download PDF : QC-Sample-FragSizes-TSSProfile.pdf "],
["filtering-doublets-from-an-archrproject.html", "3.5 Filtering Doublets from an ArchRProject", " 3.5 Filtering Doublets from an ArchRProject After we have added information on the predicted doublets using addDoubletScores(), we can remove these predicted doublets using filterDoublets(). One of the key elements of this filtering step is the filterRatio which is the maximum ratio of predicted doublets to filter based on the number of pass-filter cells. For example, if there are 5000 cells, the maximum number of filtered predicted doublets would be filterRatio * 5000^2 / (100000) (which simplifies to filterRatio * 5000 * 0.05). This filterRatio allows you to apply a consistent filter across multiple different samples that may have different percentages of doublets because they were run with different cell loading concentrations. The higher the filterRatio, the greater the number of cells potentially removed as doublets. #Remove doublets as normal projHeme2 &lt;- filterDoublets(projHeme1) # Filtering 410 cells from ArchRProject! # scATAC_BMMC_R1 : 243 of 4932 (4.9%) # scATAC_CD34_BMMC_R1 : 107 of 3275 (3.3%) # scATAC_PBMC_R1 : 60 of 2454 (2.4%) #Lets see the project now projHeme2 # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 10251 # medianTSS(1): 16.851 # medianFrags(1): 2994 If you wanted to filter more cells from the ArchR Project, you would try a higher filterRatio. To see additional arguments that can be tweaked, try ?filterDoublets. projHemeTmp &lt;- filterDoublets(projHeme1, filterRatio = 1.5) # Filtering 614 cells from ArchRProject! # scATAC_BMMC_R1 : 364 of 4932 (7.4%) # scATAC_CD34_BMMC_R1 : 160 of 3275 (4.9%) # scATAC_PBMC_R1 : 90 of 2454 (3.7%) rm(projHemeTmp) We can now save our updated projHeme2 using saveArchRProject() which will allow us to use this project in future chapters. saveArchRProject(projHeme2, copyArrows = FALSE) "],
["dimensionality-reduction-with-archr.html", "Chapter 4 Dimensionality Reduction with ArchR", " Chapter 4 Dimensionality Reduction with ArchR Dimensionality reduction with scATAC-seq is challenging due to the sparsity of the data. In scATAC-seq, a particular site can either be accessible on one allele, both alleles, or no alleles. Even in higher-quality scATAC-seq data, the majority of accesible regions are not transposed and this leads to many loci having 0 accessibile alleles. Moreover, when we see (for example) three Tn5 insertions within a single peak region in a single cell, the sparsity of the data prevents us from confidently determining that this site in this cell is actually three times more accessible than another cell that only has one insertion in the same site. For this reason a lot of analytical strategies work on a binarized scATAC-seq data matrix. This binarized matrix still ends up being mostly 0s because transposition is rare. However, it is important to note that a 0 in scATAC-seq could mean “non-accessible” or “not sampled” and these two inferences are very different from a biological standpoint. Because of this, the 1s have information and the 0s do not. This low information content is what makes our scATAC-seq data sparse. If you were to perform a standard dimensionality reduction, like Principal Component Analysis, on this sparse insertion counts matrix and plot the top two principal components, you would not obtain the desired result because the sparsity causes high inter-cell similarity at all of the 0 positions. To get around this issue, we use a layered dimensionality reduction approach. First, we use Latent Semantic Indexing (LSI), an approach from natural language processing that was originally designed to assess document similarity based on word counts. This solution was created for natural language processing because the data is sparse and noisy (many different words and many low frequency words). LSI was first introduced for scATAC-seq by Cusanovich et al. (Science 2015). In the case of scATAC-seq, different samples are the documents and different regions/peaks are the words. First, we calculate the term frequency by depth normalization per single cell. These values are then normalized by the inverse document frequency which weights features by how often they occur to identify featres that are more “specific” rather than commonly accessible. The resultant term frequency-inverse document frequency (TF-IDF) matrix reflects how important a word (aka region/peak) is to a document (aka sample). Then, through a technique called singular value decomposition (SVD), the most valuable information across samples is identified and represented in a lower dimensional space. LSI allows you to reduce the dimensionality of the sparse insertion counts matrix from many thousands to tens or hundreds. Then, a more conventional dimensionality reduction technique, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE) can be used to visualize the data. In ArchR, these visualization methods are referred to as embeddings. "],
["archrs-lsi-implementation.html", "4.1 ArchR’s LSI Implementation", " 4.1 ArchR’s LSI Implementation ArchR implements a few different LSI implementations and we have benchmarked many of these methods across multiple different test data sets. ArchR’s default LSI implementation is related to the method introduced by Timothy Stuart in Signac, which uses a term frequency that has been depth normalized to a constant (10,000) followed by normalization with the inverse document frequency and then log-transforming the resultant matrix (aka log(TF-IDF)). One of the key inputs to LSI dimensionality reduction is the starting matrix. Thus far, the main two strategies in scATAC-seq have been to (1) use peak regions or (2) genome-wide tiles. However, using peak regions for LSI is inherently challenging because we do not have clusters or cluster-specific peaks prior to dimensionality reduction. Moreover, calling peaks on aggregated cells prior to clustering obscures cell type-specific peaks. Moreover, any union peak set will change when new samples are added to an experiment, making this strategy less stable. The second strategy, using genome-wide tiles, mitigates these issues by using a consistent and unbiased feature set (genome-wide tiles). However, a genome-wide tile matrix of all cells by all regions can become prohibitively large. For this reason, most implementations use tiles that are greater than or equal to 5 kilobases in size. This drastically reduces the resolution of the approach because most accessible regions are only a few hundred basepairs long. Because of the way that Arrow files are designed, ArchR is able to perform LSI very rapidly using genome-wide 500-bp tiles. This solves the problem of resolution and allows for the identification of clusters prior to calling peaks. The challenge is that 500-bp bins generate around 6 million features to be included in the cell by tile matrix. While ArchR is able to read this large amount of data into R by chunking the relevant matrices, we have also implemented an “estimated LSI” approach that performs the initial dimensionality reduction on a subset of the total cells. This estimated LSI approach has two main utilities - (i) it speeds up dimensionality reduction (ii) as you decrease the number of cells used in the intial dimensionality reduction, this decreases the granularity of the data. This reduction in granularity can be used to your advantage to reduce batch effects in your data. However, it can also obscure true biology so estimated LSI approaches should be used under close manual supervision. "],
["iterative-latent-semantic-indexing-lsi.html", "4.2 Iterative Latent Semantic Indexing (LSI)", " 4.2 Iterative Latent Semantic Indexing (LSI) In scRNA-seq identifying variable genes is a common way to compute dimensionality reduction (such as PCA). This is done because these genes are more likely to be biologically important and this reduces experimental noise. In scATAC-seq the data is binary and thus you cannot identify variable peaks for dimensionality reduction. Rather than identifying the most variable peaks, we have tried using the most accessible features as input to LSI; however, the results when running multiple samples have shown high degrees of noise and low reproducibility. To remedy this we introduced the “iterative LSI” approach (Satpathy*, Granja* et al. Nature Biotechnology 2019 and Granja*, Klemm* and McGinnis* et al. Nature Biotechnology 2019). This approach computes an inital LSI transformation on the most accessible tiles and identifies lower resolution clusters that are not batch confounded. For example, when performed on peripheral blood mononuclear cells, this will identify clusters corresponding to the major cell types (T cells, B cells, and monocytes). Then ArchR computes the average accessibility for each of these clusters across all features creating “pseudo-bulks”. ArchR then identifies the most variable peaks across these pseudo-bulks and uses these features for LSI again. In this second iteration, the most variable peaks are more similar to the variable genes used in scRNA-seq LSI implementations. The user can set how many iterations of LSI should be performed. QQQ add new info on LSI implementation. We have found this approach to be very good for batch minimization and allows operations on a more reasonably sized feature matrix. To perform iterative LSI in ArchR, we use the addIterativeLSI() function. The default parameters which should cover most cases but we encourage you to explore the available parameters and how they each affect your particular data set. See ?addIterativeLSI for more details on inputs. projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) If you see downstream that you have subtle batch effects, another option is to add more LSI iterations and to start from a lower intial clustering resolution as shown below. Additionally the number of variable features can be lowered to increase focus on the more variable features. QQQ would be nice to see an example of what these batch effects look like and how this corrects them projHeme2 &lt;- addIterativeLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI2&quot;, iterations = 4, clusterParams = list( resolution = c(0.1, 0.2, 0.4), sampleCells = 10000, n.start = 10 ), varFeatures = 15000, dimsToUse = 1:30 ) Additionally ArchR allows for a normal (non-iterative) LSI transformation via the addLSI() function, however we recommend the iterative procedure. projHeme2 &lt;- addLSI( ArchRProj = projHeme2, useMatrix = &quot;TileMatrix&quot;, name = &quot;LSI&quot;, topFeatures = 25000, dimsToUse = 1:30 ) For the purposes of this tutorial, we will compute the iterative LSI for the ArchRProject that still contains doublets. projHeme1 &lt;- addIterativeLSI( ArchRProj = projHeme1, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) "],
["batch-effect-correction-wtih-harmony.html", "4.3 Batch Effect Correction wtih Harmony", " 4.3 Batch Effect Correction wtih Harmony Sometimes the iterative LSI approach isnt enough of a correction for strong batch effect differences. For this reason, ArchR implements a commonly used batch effect correction tool called Harmony which was originally designed for scRNA-seq. We provide a wrapper that will pass a dimensionality reduction object from ArchR directly to the HarmonyMatrix() function. Additional arguments can be directly passed to HarmonyMatrix() in the function via the additional parameters (...) . See ?addHarmony() for more details. Users should be aware of the caveats of batch correction for their particular application. projHeme2 &lt;- addHarmony( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;Harmony&quot;, groupBy = &quot;Sample&quot; ) QQQ Would like to see a before and after batch correction plot here "],
["clustering-with-archr.html", "Chapter 5 Clustering with ArchR", " Chapter 5 Clustering with ArchR Most single-cell clustering methods focus on computing nearest neighbor graphs in reduced dimensions and then identifying “communities” or clusters of cells. These approaches work extremely well and are a standard practice in scRNA-seq. For this reason, ArchR uses existing state-of-the-art clustering methods from scRNA-seq packages for clustering. 5.0.1 Clustering using Seurat’s FindClusters() function We have had the most success using the graph clustering approach implemented by Seurat. In ArchR, clustering is performed using the addClusters() function which permits additional clustering parameters to be passed to the Seurat::FindClusters() function. projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;Seurat&quot;, name = &quot;Clusters&quot;, resolution = 0.8 ) To access these clusters we can use the $ accessor head(projHeme2$Clusters) # [1] &quot;Cluster11&quot; &quot;Cluster2&quot; &quot;Cluster12&quot; &quot;Cluster1&quot; &quot;Cluster12&quot; &quot;Cluster8&quot; table(projHeme2$Clusters) # Cluster1 Cluster10 Cluster11 Cluster12 Cluster13 Cluster14 Cluster2 Cluster3 # 28 1070 425 351 408 345 1330 562 # Cluster4 Cluster5 Cluster6 Cluster7 Cluster8 Cluster9 # 901 860 1218 974 274 1505 To better understand which samples reside in which clusters, we can create a cluster confusion matrix across each sample. JJJ QQQ Seems weird to use a hidden function like this in the tutorial ArchR:::.confusionMatrix(paste0(projHeme2$Clusters), paste0(projHeme2$Sample)) # 14 x 3 sparse Matrix of class &quot;dgCMatrix&quot; # scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # Cluster11 247 6 172 # Cluster2 1254 . 76 # Cluster12 351 . . # Cluster1 28 . . # Cluster8 247 27 . # Cluster4 315 . 586 # Cluster9 1456 5 44 # Cluster5 214 639 7 # Cluster7 83 887 4 # Cluster14 161 174 10 # Cluster3 52 . 510 # Cluster10 84 1 985 # Cluster6 117 1101 . # Cluster13 80 328 . QQQ Show how to turn this confusion matrix into a plot QQQ This is confusing. Expand on this - Determining the appropriate cluster parameters is useful once you have computed a 2-dimensional embedding. This is because you should be adjusting both the clustering and embedding parameters to where they both agree. 5.0.2 Clustering using scran Additionally, ArchR allows for the identification of clusters with scran by changing the method parameter in addClusters(). projHeme2 &lt;- addClusters( input = projHeme2, reducedDims = &quot;IterativeLSI&quot;, method = &quot;scran&quot;, name = &quot;ScranClusters&quot;, k = 15 ) "],
["single-cell-embeddings.html", "Chapter 6 Single Cell Embeddings", " Chapter 6 Single Cell Embeddings In ArchR, embeddings, such as Uniform Manifold Approximation and Projection (UMAP) or t-distributed stochastic neighbor embedding (t-SNE), are used to visualize single cells in reduced dimension space. These embeddings each have distinct advantages and disadvantages. We call these “embeddings” because they are strictly used to visualize the clusters and are not used to identify clusters which is done using LSI as mentioned in previous chapters. The primary difference between UMAP and t-SNE is the interpretatino of the distance between cells or clusters. t-SNE is designed to preserve the local structure in the data while UMAP is designed to preserve both the local and most of the global structure in the data. In theory, this means that the distance between two clusters is not informative in t-SNE but is informative in UMAP. For example, t-SNE does not allow you to say that Cluster A is more similar to Cluster B than it is to Cluster C based on the observation that Cluster A is located closer to Cluster B than Cluster C on the t-SNE. UMAP, on the other hand, is designed to permit this type of comparison, though it is worth noting that UMAP is a new enough method that this is still being flushed out in the literature. It is important to note that neither t-SNE nor UMAP are deterministic. Moreover, tweaking the input parameters will lead to different results. In the context of t-SNE and UMAP, you can effectively make the algorithm deterministic by using the same random seed. However, the remaining input parameters still have drastic effects on the resulting embedding. Because of this, it is important to understand the various input parameters and to tweak these to best meet the needs of your own data. ArchR implements a default set of input parameters that work for most applications but there is really no single set of parameters that will produce the desired results for datasets that vary greatly in cell number, complexity, and quality. QQQ would be nice to show the mouse atlas UMAP vs t-SNE to illustrate when t-SNE may be better than UMAP here "],
["umap.html", "6.1 UMAP", " 6.1 UMAP projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;UMAP&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-UMAP-Sample-Clusters.pdf We can also see the results from scran clustering p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;UMAP&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-UMAP-Sample-ScranClusters.pdf "],
["tsne.html", "6.2 tSNE", " 6.2 tSNE projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI&quot;, name = &quot;TSNE&quot;, perplexity = 30 ) p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-TSNE-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-TSNE-Sample-Clusters.pdf We can also see the results from scran clustering p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;ScranClusters&quot;, embedding = &quot;TSNE&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-tSNE-Sample-ScranClusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-tSNE-Sample-ScranClusters.pdf "],
["umap-of-previous-reduced-dimensions.html", "6.3 UMAP of previous Reduced Dimensions", " 6.3 UMAP of previous Reduced Dimensions projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI2&quot;, name = &quot;UMAP2&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP2&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP2&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) projHeme2 &lt;- addUMAP( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;UMAPHarmony&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAPHarmony&quot;) p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAPHarmony&quot;) ggAlignPlots(p3, p4, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2,p3,p4, name = &quot;Plot-UMAP2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-UMAP2Harmony-Sample-Clusters.pdf "],
["tsne-of-previous-reduced-dimensions.html", "6.4 tSNE of previous Reduced Dimensions", " 6.4 tSNE of previous Reduced Dimensions projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;IterativeLSI2&quot;, name = &quot;TSNE2&quot;, perplexity = 30 ) p1 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE2&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE2&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) projHeme2 &lt;- addTSNE( ArchRProj = projHeme2, reducedDims = &quot;Harmony&quot;, name = &quot;TSNEHarmony&quot;, perplexity = 30 ) p3 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNEHarmony&quot;) p4 &lt;- plotEmbedding(ArchRProj = projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNEHarmony&quot;) ggAlignPlots(p3, p4, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2,p3,p4, name = &quot;Plot-TSNE2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-TSNE2Harmony-Sample-Clusters.pdf "],
["marker-genes-with-scatac.html", "Chapter 7 Marker Genes with scATAC ", " Chapter 7 Marker Genes with scATAC "],
["identification-of-marker-genes.html", "7.1 Identification of Marker Genes", " 7.1 Identification of Marker Genes Identify Marker Gene through Pairwise Test vs Bias-Matched Background markersGS &lt;- markerFeatures( ArchRProj = projHeme2, useMatrix = &quot;GeneScoreMatrix&quot;, groupBy = &quot;Clusters&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) markerList &lt;- getMarkers(markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;) markerList$Cluster4 # DataFrame with 210 rows and 6 columns # seqnames start name idx Log2FC # &lt;Rle&gt; &lt;array&gt; &lt;array&gt; &lt;array&gt; &lt;numeric&gt; # 14759 chr22 37545962 IL2RB 301 2.09731361787433 # 6856 chr14 99737822 BCL11B 595 1.42193213075962 # 13123 chr2 192038902 STAT4 1064 1.90075014141832 # 12597 chr2 87035519 CD8A 538 1.96747880033344 # 9299 chr17 34207377 CCL5 540 2.65385587389937 # ... ... ... ... ... ... # 1488 chr1 156182779 PMF1 1488 1.35708770978464 # 22735 chrX 101854276 ARMCX5-GPRASP2 518 1.59283344451927 # 19680 chr7 45144641 SNORA5C 318 1.27027443652085 # 1856 chr1 196659182 CFHR4 1856 1.92661384224492 # 17830 chr5 140739703 PCDHGB2 690 2.93899133419389 We can then plot this as a heatmap markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) heatmapGS &lt;- markerHeatmap( seMarker = markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;, labelMarkers = markerGenes, transpose = TRUE ) draw(heatmapGS, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapGS, name = &quot;GeneScores-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE) Download PDF : GeneScores-Marker-Heatmap.pdf "],
["marker-genes.html", "7.2 Marker Genes", " 7.2 Marker Genes markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, quantCut = c(0.01, 0.95), imputeWeights = NULL ) To plot a specific gene try p$CD14 To plot all genes we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-WO-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-UMAP-Marker-Genes-WO-Imputation.pdf "],
["marker-genes-imputation-with-magic.html", "7.3 Marker Genes Imputation with Magic", " 7.3 Marker Genes Imputation with Magic projHeme2 &lt;- addImputeWeights(projHeme2) # 2020-02-15 00:15:35 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed.. # 2020-02-15 00:15:35 : Computing Partial Diffusion Matrix with Magic (1 of 2), 0 mins elapsed.. # 2020-02-15 00:15:37 : Computing Partial Diffusion Matrix with Magic (2 of 2), 0.047 mins elapsed.. # 2020-02-15 00:15:41 : Completed Getting Magic Weights (Size = 0.197 GB)!, 0.112 mins elapsed.. Now lets see how this effects our marker gene scores overlayed on our 2-d embedding. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotEmbedding( ArchRProj = projHeme2, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme2) ) To plot a specific gene try p$CD14 To plot all genes we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-W-Imputation.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-UMAP-Marker-Genes-W-Imputation.pdf "],
["track-plotting-with-archrbrowser.html", "7.4 Track Plotting with ArchRBrowser", " 7.4 Track Plotting with ArchRBrowser markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- ArchRBrowserTrack( ArchRProj = projHeme2, groupBy = &quot;Clusters&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000 ) # 2020-02-15 00:23:11 : Adding Bulk Tracks (1 of 9), 0 mins elapsed.. # 2020-02-15 00:23:12 : Adding Gene Tracks (1 of 9), 0.015 mins elapsed.. # 2020-02-15 00:23:12 : Plotting, 0.018 mins elapsed.. # 2020-02-15 00:23:13 : Adding Bulk Tracks (2 of 9), 0.045 mins elapsed.. # 2020-02-15 00:23:14 : Adding Gene Tracks (2 of 9), 0.055 mins elapsed.. # 2020-02-15 00:23:14 : Plotting, 0.058 mins elapsed.. # 2020-02-15 00:23:16 : Adding Bulk Tracks (3 of 9), 0.08 mins elapsed.. # 2020-02-15 00:23:16 : Adding Gene Tracks (3 of 9), 0.09 mins elapsed.. # 2020-02-15 00:23:16 : Plotting, 0.095 mins elapsed.. # 2020-02-15 00:23:18 : Adding Bulk Tracks (4 of 9), 0.12 mins elapsed.. # 2020-02-15 00:23:19 : Adding Gene Tracks (4 of 9), 0.131 mins elapsed.. # 2020-02-15 00:23:19 : Plotting, 0.135 mins elapsed.. # 2020-02-15 00:23:20 : Adding Bulk Tracks (5 of 9), 0.153 mins elapsed.. # 2020-02-15 00:23:21 : Adding Gene Tracks (5 of 9), 0.167 mins elapsed.. # 2020-02-15 00:23:21 : Plotting, 0.171 mins elapsed.. # 2020-02-15 00:23:22 : Adding Bulk Tracks (6 of 9), 0.195 mins elapsed.. # 2020-02-15 00:23:23 : Adding Gene Tracks (6 of 9), 0.206 mins elapsed.. # 2020-02-15 00:23:23 : Plotting, 0.209 mins elapsed.. # 2020-02-15 00:23:25 : Adding Bulk Tracks (7 of 9), 0.234 mins elapsed.. # 2020-02-15 00:23:26 : Adding Gene Tracks (7 of 9), 0.247 mins elapsed.. # 2020-02-15 00:23:26 : Plotting, 0.25 mins elapsed.. # 2020-02-15 00:23:27 : Adding Bulk Tracks (8 of 9), 0.278 mins elapsed.. # 2020-02-15 00:23:28 : Adding Gene Tracks (8 of 9), 0.291 mins elapsed.. # 2020-02-15 00:23:28 : Plotting, 0.294 mins elapsed.. # 2020-02-15 00:23:30 : Adding Bulk Tracks (9 of 9), 0.326 mins elapsed.. # 2020-02-15 00:23:31 : Adding Gene Tracks (9 of 9), 0.338 mins elapsed.. # 2020-02-15 00:23:31 : Plotting, 0.341 mins elapsed.. To plot a track we can simply print one from the list grid::grid.newpage() grid::grid.draw(p$CD14) plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-Tracks-Marker-Genes.pdf "],
["launching-the-archrbrowser.html", "7.5 Launching the ArchRBrowser", " 7.5 Launching the ArchRBrowser ArchRBrowser(projHeme2) We can now save our original projHeme1 using saveArchRProject from ArchR. saveArchRProject(projHeme2) "],
["labeling-clusters-with-scrna.html", "Chapter 8 Labeling Clusters with scRNA ", " Chapter 8 Labeling Clusters with scRNA "],
["labeling-scatac-cells-with-scrna-clusters.html", "8.1 Labeling scATAC cells with scRNA clusters", " 8.1 Labeling scATAC cells with scRNA clusters First we need to download scRNA data for hematopoiesis from Granja* et al (2019). #259 MB Download if(!file.exists(&quot;scRNA-Healthy-Hematopoiesis-191120.rds&quot;)){ download.file( url = &quot;https://jeffgranja.s3.amazonaws.com/MPAL-10x/Supplementary_Data/Healthy-Data/scRNA-Healthy-Hematopoiesis-191120.rds&quot;, destfile = &quot;scRNA-Healthy-Hematopoiesis-191120.rds&quot; ) } seRNA &lt;- readRDS(&quot;scRNA-Healthy-Hematopoiesis-191120.rds&quot;) seRNA # class: RangedSummarizedExperiment # dim: 20287 35582 # metadata(6): variableGenes optimizeLSI ... UMAP_Params colorMap # assays(1): counts # rownames(20287): FAM138A OR4F5 ... S100B PRMT2 # rowData names(3): gene_name gene_id exonLength # colnames(35582): CD34_32_R5:AAACCTGAGTATCGAA-1 # CD34_32_R5:AAACCTGAGTCGTTTG-1 ... # BMMC_10x_GREENLEAF_REP2:TTTGTTGCATGTGTCA-1 # BMMC_10x_GREENLEAF_REP2:TTTGTTGCATTGAAAG-1 # colData names(10): Group nUMI_pre ... BioClassification Barcode colnames(colData(seRNA)) # [1] &quot;Group&quot; &quot;nUMI_pre&quot; &quot;nUMI&quot; # [4] &quot;nGene&quot; &quot;initialClusters&quot; &quot;UMAP1&quot; # [7] &quot;UMAP2&quot; &quot;Clusters&quot; &quot;BioClassification&quot; # [10] &quot;Barcode&quot; table(colData(seRNA)$BioClassification) # 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP # 1425 1653 446 111 2260 # 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC # 903 2097 1050 544 325 # 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 # 1800 4222 292 520 377 # 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 # 710 1711 62 1521 2470 # 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK # 2364 3539 796 2080 2143 # 26_Unk # 161 Unconstrained Integration (not-recommended) #~5 minutes projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, seRNA = seRNA, addToArrow = FALSE, groupBy = &quot;BioClassification&quot;, nameGroup = &quot;predictedGroup1&quot;, nameScore = &quot;predictedScore1&quot; ) Constrained Integration (recommended) sampleList &lt;- SimpleList( scATAC_BMMC_R1 = grep(&quot;BMMC&quot;, colnames(seRNA), ignore.case = TRUE, value = TRUE), scATAC_CD34_BMMC_R1 = grep(&quot;CD34&quot;, colnames(seRNA), ignore.case = TRUE, value = TRUE), scATAC_PBMC_R1 = grep(&quot;PBMC&quot;, colnames(seRNA), ignore.case = TRUE, value = TRUE) ) #To see size of each list element lapply(sampleList, length) # $scATAC_BMMC_R1 # [1] 12602 # $scATAC_CD34_BMMC_R1 # [1] 8176 # $scATAC_PBMC_R1 # [1] 14804 #~5 minutes projHeme2 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, seRNA = seRNA, sampleList = sampleList, addToArrow = FALSE, groupBy = &quot;BioClassification&quot;, nameGroup = &quot;predictedGroup2&quot;, nameScore = &quot;predictedScore2&quot; ) Compare results pal &lt;- paletteDiscrete(values = colData(seRNA)$BioClassification) pal # 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP # &quot;#D51F26&quot; &quot;#502A59&quot; &quot;#235D55&quot; &quot;#3D6E57&quot; &quot;#8D2B8B&quot; # 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC # &quot;#DE6C3E&quot; &quot;#F9B712&quot; &quot;#D8CE42&quot; &quot;#8E9ACD&quot; &quot;#B774B1&quot; # 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 # &quot;#D69FC8&quot; &quot;#C7C8DE&quot; &quot;#8FD3D4&quot; &quot;#89C86E&quot; &quot;#CC9672&quot; # 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 # &quot;#CF7E96&quot; &quot;#A27AA4&quot; &quot;#CD4F32&quot; &quot;#6B977E&quot; &quot;#518AA3&quot; # 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK # &quot;#5A5297&quot; &quot;#0F707D&quot; &quot;#5E2E32&quot; &quot;#A95A3C&quot; &quot;#B28D5C&quot; # 26_Unk # &quot;#3D3D3D&quot; p1 &lt;- plotEmbedding(projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup1&quot;, pal = pal) p1 p2 &lt;- plotEmbedding(projHeme2, colorBy = &quot;cellColData&quot;, name = &quot;predictedGroup2&quot;, pal = pal) p2 To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-RNA-Integration.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) "],
["adding-pseudo-scrna-profiles-for-each-scatac-cell.html", "8.2 Adding Pseudo-scRNA profiles for each scATAC cell", " 8.2 Adding Pseudo-scRNA profiles for each scATAC cell First we need to download scRNA data for hematopoiesis from Granja* et al (2019). #259 MB Download if(!file.exists(&quot;scRNA-Healthy-Hematopoiesis-191120.rds&quot;)){ download.file( url = &quot;https://jeffgranja.s3.amazonaws.com/MPAL-10x/Supplementary_Data/Healthy-Data/scRNA-Healthy-Hematopoiesis-191120.rds&quot;, destfile = &quot;scRNA-Healthy-Hematopoiesis-191120.rds&quot; ) } seRNA &lt;- readRDS(&quot;scRNA-Healthy-Hematopoiesis-191120.rds&quot;) seRNA # class: RangedSummarizedExperiment # dim: 20287 35582 # metadata(6): variableGenes optimizeLSI ... UMAP_Params colorMap # assays(1): counts # rownames(20287): FAM138A OR4F5 ... S100B PRMT2 # rowData names(3): gene_name gene_id exonLength # colnames(35582): CD34_32_R5:AAACCTGAGTATCGAA-1 # CD34_32_R5:AAACCTGAGTCGTTTG-1 ... # BMMC_10x_GREENLEAF_REP2:TTTGTTGCATGTGTCA-1 # BMMC_10x_GREENLEAF_REP2:TTTGTTGCATTGAAAG-1 # colData names(10): Group nUMI_pre ... BioClassification Barcode colnames(colData(seRNA)) # [1] &quot;Group&quot; &quot;nUMI_pre&quot; &quot;nUMI&quot; # [4] &quot;nGene&quot; &quot;initialClusters&quot; &quot;UMAP1&quot; # [7] &quot;UMAP2&quot; &quot;Clusters&quot; &quot;BioClassification&quot; # [10] &quot;Barcode&quot; table(colData(seRNA)$BioClassification) # 01_HSC 02_Early.Eryth 03_Late.Eryth 04_Early.Baso 05_CMP.LMPP # 1425 1653 446 111 2260 # 06_CLP.1 07_GMP 08_GMP.Neut 09_pDC 10_cDC # 903 2097 1050 544 325 # 11_CD14.Mono.1 12_CD14.Mono.2 13_CD16.Mono 14_Unk 15_CLP.2 # 1800 4222 292 520 377 # 16_Pre.B 17_B 18_Plasma 19_CD8.N 20_CD4.N1 # 710 1711 62 1521 2470 # 21_CD4.N2 22_CD4.M 23_CD8.EM 24_CD8.CM 25_NK # 2364 3539 796 2080 2143 # 26_Unk # 161 We can now save our original projHeme2 using saveArchRProject from ArchR. saveArchRProject(projHeme2) Constrained Integration (recommended) sampleList &lt;- SimpleList( scATAC_BMMC_R1 = grep(&quot;BMMC&quot;, colnames(seRNA), ignore.case = TRUE, value = TRUE), scATAC_CD34_BMMC_R1 = grep(&quot;CD34&quot;, colnames(seRNA), ignore.case = TRUE, value = TRUE), scATAC_PBMC_R1 = grep(&quot;PBMC&quot;, colnames(seRNA), ignore.case = TRUE, value = TRUE) ) #To see size of each list element lapply(sampleList, length) # $scATAC_BMMC_R1 # [1] 12602 # $scATAC_CD34_BMMC_R1 # [1] 8176 # $scATAC_PBMC_R1 # [1] 14804 #~5 minutes projHeme3 &lt;- addGeneIntegrationMatrix( ArchRProj = projHeme2, seRNA = seRNA, sampleList = sampleList, addToArrow = TRUE, # We are going to add scRNA to each Arrow groupBy = &quot;BioClassification&quot;, nameGroup = &quot;predictedGroup&quot;, nameScore = &quot;predictedScore&quot; ) What matrices are available? getAvailableMatrices(projHeme3) #[1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;TileMatrix&quot; Now lets see how this effects our marker gene scores overlayed on our 2-d embedding. markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p1 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneIntegrationMatrix&quot;, name = markerGenes, continuousSet = &quot;horizonExtra&quot;, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) p2 &lt;- plotEmbedding( ArchRProj = projHeme3, colorBy = &quot;GeneScoreMatrix&quot;, continuousSet = &quot;horizonExtra&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme3) ) To plot all marker genes we can use cowplot #Rearrange for grid plotting p1c &lt;- lapply(p1, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) #Rearrange for grid plotting p2c &lt;- lapply(p2, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3), p1c)) do.call(cowplot::plot_grid, c(list(ncol = 3), p2c)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p1, name = &quot;Plot-UMAP-Marker-Genes-RNA-W-Imputation.pdf&quot;, ArchRProj = projHeme3, addDOC = FALSE, width = 5, height = 5) "],
["labeling-scatac-clusters-with-scrna.html", "8.3 Labeling scATAC clusters with scRNA", " 8.3 Labeling scATAC clusters with scRNA Now that we have pretty good scRNA and scATAC correspondence we can label our clusters with scRNA To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, name = &quot;Plot-UMAP-Remap-Clusters.pdf&quot;, ArchRProj = projHeme2, addDOC = FALSE, width = 5, height = 5) "],
["calling-peaks-with-archr.html", "Chapter 9 Calling Peaks with ArchR ", " Chapter 9 Calling Peaks with ArchR "],
["calling-peaks-w-macs2.html", "9.1 Calling Peaks w/ Macs2", " 9.1 Calling Peaks w/ Macs2 We can now save our original projHeme3 using saveArchRProject from ArchR. saveArchRProject(projHeme3) #Create Group Coverage Files that can be used for downstream analysis (~5-10 minutes) projHeme4 &lt;- addGroupCoverages(ArchRProj = projHeme3, groupBy = &quot;Clusters&quot;) #Find Path to Macs2 binary. This function sometimes struggles if you are using conda environment #for installation of python packages. If this function fails try providing a direct path manually pathToMacs2 &lt;- findMacs2() #Call Reproducible Peaks w/ Macs2 (~5-10 minutes) projHeme4 &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters&quot;, pathToMacs2 = pathToMacs2 ) getPeakSet(projHeme4) # GRanges object with 158378 ranges and 12 metadata columns: # seqnames ranges strand | score # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; # Cluster10 chr1 752327-752827 * | 2.74288 # Cluster9 chr1 760866-761366 * | 2.65888 # Cluster2 chr1 762700-763200 * | 18.7147 # Cluster2 chr1 779639-780139 * | 2.81931 # Cluster8 chr1 793519-794019 * | 3.74498 # ... ... ... ... . ... # Cluster5 chrX 154841853-154842353 * | 3.43901 # Cluster12 chrX 154842354-154842854 * | 7.60796 # Cluster4 chrX 154862032-154862532 * | 9.27826 # Cluster5 chrX 154912371-154912871 * | 6.27394 # Cluster6 chrX 154996898-154997398 * | 2.65432 "],
["calling-peaks-w-tilematrix.html", "9.2 Calling Peaks w/ TileMatrix", " 9.2 Calling Peaks w/ TileMatrix #Call Reproducible Peaks w/ TileMatrix (~2 minutes) projHemeTmp &lt;- addReproduciblePeakSet( ArchRProj = projHeme4, groupBy = &quot;Clusters&quot;, peakMethod = &quot;Tiles&quot;, method = &quot;p&quot; ) getPeakSet(projHemeTmp) # GRanges object with 277187 ranges and 9 metadata columns: # seqnames ranges strand | mlog10p Group # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;Rle&gt; # [1] chr1 752000-752499 * | 1.682 Cluster10 # [2] chr1 752500-752999 * | 4.952 Cluster10 # [3] chr1 758500-758999 * | 1.037 Cluster4 # [4] chr1 761000-761499 * | 2.204 Cluster9 # [5] chr1 762000-762499 * | 3.246 Cluster4 # ... ... ... ... . ... ... # [277183] chrX 154842000-154842499 * | 8.936 Cluster12 # [277184] chrX 154842500-154842999 * | 12.546 Cluster12 # [277185] chrX 154862000-154862499 * | 2.449 Cluster4 # [277186] chrX 154912500-154912999 * | 2.484 Cluster5 # [277187] chrX 154997000-154997499 * | 4.236 Cluster8 Lets see how well this compares to Macs2 #Peak Overlap length(subsetByOverlaps(getPeakSet(projHeme4), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) # 0.9681079 length(subsetByOverlaps(getPeakSet(projHemeTmp), getPeakSet(projHeme4))) / length(getPeakSet(projHemeTmp)) # 0.7902066 #Extend to 1kb length(subsetByOverlaps(resize(getPeakSet(projHeme4), 1000, &quot;center&quot;), getPeakSet(projHemeTmp))) / length(getPeakSet(projHeme4)) # 0.9750028 length(subsetByOverlaps(getPeakSet(projHemeTmp), resize(getPeakSet(projHeme4), 1000, &quot;center&quot;))) / length(getPeakSet(projHemeTmp)) # 0.858287 "],
["add-peak-matrix.html", "9.3 Add Peak Matrix", " 9.3 Add Peak Matrix We can now save our original projHeme4 using saveArchRProject from ArchR. saveArchRProject(projHeme4) getPeakSet(projHeme4) # GRanges object with 158378 ranges and 12 metadata columns: # seqnames ranges strand | score # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; # Cluster10 chr1 752327-752827 * | 2.74288 # Cluster9 chr1 760866-761366 * | 2.65888 # Cluster2 chr1 762700-763200 * | 18.7147 # Cluster2 chr1 779639-780139 * | 2.81931 # Cluster8 chr1 793519-794019 * | 3.74498 # ... ... ... ... . ... # Cluster5 chrX 154841853-154842353 * | 3.43901 # Cluster12 chrX 154842354-154842854 * | 7.60796 # Cluster4 chrX 154862032-154862532 * | 9.27826 # Cluster5 chrX 154912371-154912871 * | 6.27394 # Cluster6 chrX 154996898-154997398 * | 2.65432 #~1-2 Minutes projHeme5 &lt;- addPeakMatrix(projHeme4) getAvailableMatrices(projHeme5) # [1] &quot;GeneIntegrationMatrix&quot; &quot;GeneScoreMatrix&quot; &quot;PeakMatrix&quot; # [4] &quot;TileMatrix&quot; "],
["identifying-marker-peaks-with-archr.html", "Chapter 10 Identifying Marker Peaks with ArchR ", " Chapter 10 Identifying Marker Peaks with ArchR "],
["identifying-marker-peaks-with-archr-1.html", "10.1 Identifying Marker Peaks with ArchR", " 10.1 Identifying Marker Peaks with ArchR Often times, we are interested to know which peaks are unique to an individual cluster or a small group of clusters. We can do this in an unsupervised fashion in ArchR: addArchRThreads(8) #Our scRNA labels table(projHeme5$Clusters2) # C1_Early.Eryth C10_CD14.Mono.2 C11_B C12_Pre.B C13_CLP.2 # 28 1070 425 351 408 # C14_pDC C2_CD4.N1 C3_CD4.N2 C4_NK C5_Late.Eryth # 345 1330 562 901 860 # C6_HSC C7_CMP.LMPP C8_GMP.Neut C9_CD14.Mono.1 # 1218 974 274 1505 #Identify Marker Peaks while controling for TSS and Depth Biases markersPeaks &lt;- markerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) markersPeaks # class: SummarizedExperiment # dim: 158378 14 # metadata(2): MatchInfo Params # assays(5): Log2FC Mean FDR AUC MeanBGD # rownames(158378): 1 2 ... 158377 158378 # rowData names(4): seqnames idx start end # colnames(14): C1_Early.Eryth C2_CD4.N1 ... C13_CLP.2 C14_pDC # colData names(0): We can get the peak regions for each marker as DataFrame or GRanges. #DataFrame markerList &lt;- getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;) markerList # List of length 14 # names(14): C1_Early.Eryth C2_CD4.N1 C3_CD4.N2 ... C12_Pre.B C13_CLP.2 C14_pDC markerList$C5_Late.Eryth # DataFrame with 2262 rows and 6 columns # seqnames idx start end Log2FC # &lt;Rle&gt; &lt;array&gt; &lt;array&gt; &lt;array&gt; &lt;numeric&gt; # 97705 chr22 1313 30129829 30130329 3.51592607805769 # 10135 chr1 10135 164681301 164681801 4.44617535438744 # 48828 chr15 1349 50552672 50553172 5.18141784055201 # 54061 chr16 1457 15615745 15616245 8.33999798117364 # 2928 chr1 2928 27869062 27869562 5.21444029812509 # ... ... ... ... ... ... # 41787 chr13 3145 112037183 112037683 3.09392983218513 # 97647 chr22 1255 29702383 29702883 2.97001510006876 # 143218 chr8 1908 37949093 37949593 2.9624832757185 # 39746 chr13 1104 41255455 41255955 1.27203148042162 # 128023 chr6 3784 41169564 41170064 2.67070386367678 #GRanges markerList &lt;- getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE) markerList # GenomicRangesList of length 14 # names(14): C1_Early.Eryth C2_CD4.N1 C3_CD4.N2 ... C12_Pre.B C13_CLP.2 C14_pDC markerList$C5_Late.Eryth # GRanges object with 2262 ranges and 2 metadata columns: # seqnames ranges strand | Log2FC # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; # [1] chr22 30129829-30130329 * | 3.51592607805769 # [2] chr1 164681301-164681801 * | 4.44617535438744 # [3] chr15 50552672-50553172 * | 5.18141784055201 # [4] chr16 15615745-15616245 * | 8.33999798117364 # [5] chr1 27869062-27869562 * | 5.21444029812509 # ... ... ... ... . ... # [2258] chr13 112037183-112037683 * | 3.09392983218513 # [2259] chr22 29702383-29702883 * | 2.97001510006876 # [2260] chr8 37949093-37949593 * | 2.9624832757185 # [2261] chr13 41255455-41255955 * | 1.27203148042162 # [2262] chr6 41169564-41170064 * | 2.67070386367678 We can visualize this as a heatmap #Visualize Markers as a heatmap heatmapPeaks &lt;- markerHeatmap( seMarker = markersPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot;, transpose = TRUE ) draw(heatmapPeaks, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapPeaks, name = &quot;Peak-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) We can also plot an MA/Volcano Plot for any individual cluster #Marker Peaks for Erythroid pma &lt;- markerPlot(seMarker = markersPeaks, name = &quot;C5_Late.Eryth&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma pv &lt;- markerPlot(seMarker = markersPeaks, name = &quot;C5_Late.Eryth&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv We can then plot this as a nice pdf plotPDF(pma, pv, name = &quot;Erythroid-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) Additionally we can see these peak regions overlayed on our browser tracks p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters&quot;, geneSymbol = c(&quot;GATA1&quot;), features = getMarkers(markersPeaks, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 1&quot;, returnGR = TRUE)[&quot;C5_Late.Eryth&quot;], upstream = 50000, downstream = 50000 ) grid::grid.newpage() grid::grid.draw(p$GATA1) We can then plot this as a nice pdf plotPDF(p, name = &quot;Plot-Tracks-With-Features&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) "],
["pairwise-testing-groups.html", "10.2 Pairwise Testing Groups", " 10.2 Pairwise Testing Groups #Pairwise Test between Erythroid Cells (Cluster5) and Early Progenitors (HSC) markerTest &lt;- markerFeatures( ArchRProj = projHeme5, useMatrix = &quot;PeakMatrix&quot;, groupBy = &quot;Clusters2&quot;, testMethod = &quot;wilcoxon&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), useGroups = &quot;C5_Late.Eryth&quot;, bgdGroups = &quot;C6_HSC&quot; ) We can then plot an MA/Volcano Plot #Marker Peaks for Erythroid pma &lt;- markerPlot(seMarker = markerTest, name = &quot;C5_Late.Eryth&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;MA&quot;) pma pv &lt;- markerPlot(seMarker = markerTest, name = &quot;C5_Late.Eryth&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; abs(Log2FC) &gt;= 1&quot;, plotAs = &quot;Volcano&quot;) pv We can then plot this as a nice pdf plotPDF(pma, pv, name = &quot;Erythroid-vs-HSC-Markers-MA-Volcano&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) We can look for enriched motifs (see next chapter for more details) #Add Motif Peak Annotations if not already added! projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) #Identify Motif Enrichments motifsUp &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) motifsUp # class: SummarizedExperiment # dim: 870 1 # metadata(0): # assays(10): mlog10Padj mlog10p ... CompareFrequency feature # rownames(870): TFAP2B_1 TFAP2D_2 ... TBX18_869 TBX22_870 # rowData names(0): # colnames(1): C5_Late.Eryth # colData names(0): #Create data.frame df &lt;- data.frame(TF = rownames(motifsUp), mlog10Padj = assay(motifsUp)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) head(df) # TF mlog10Padj rank # 383 GATA1_383 501.1950 1 # 388 GATA2_388 485.3875 2 # 384 GATA3_384 382.2286 3 # 385 GATA5_385 378.4617 4 # 386 GATA4_386 310.1231 5 # 387 GATA6_387 196.2290 6 #Ggplot ggUp &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(P-adj) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggUp #Identify Motif Enrichments motifsDo &lt;- peakAnnoEnrichment( seMarker = markerTest, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &lt;= -0.5&quot; ) motifsDo # class: SummarizedExperiment # dim: 870 1 # metadata(0): # assays(10): mlog10Padj mlog10p ... CompareFrequency feature # rownames(870): TFAP2B_1 TFAP2D_2 ... TBX18_869 TBX22_870 # rowData names(0): # colnames(1): C5_Late.Eryth # colData names(0): #Create data.frame df &lt;- data.frame(TF = rownames(motifsDo), mlog10Padj = assay(motifsDo)[,1]) df &lt;- df[order(df$mlog10Padj, decreasing = TRUE),] df$rank &lt;- seq_len(nrow(df)) head(df) # TF mlog10Padj rank # 326 ELF2_326 106.76416 1 # 56 TCF12_56 96.54526 2 # 733 RUNX1_733 68.21896 3 # 843 ASCL1_843 64.71306 4 # 41 MYOG_41 63.21656 5 # 801 CBFB_801 55.31786 6 #Ggplot ggDo &lt;- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + geom_point(size = 1) + ggrepel::geom_label_repel( data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), size = 1.5, nudge_x = 2, color = &quot;black&quot; ) + theme_ArchR() + ylab(&quot;-log10(FDR) Motif Enrichment&quot;) + xlab(&quot;Rank Sorted TFs Enriched&quot;) + scale_color_gradientn(colors = paletteContinuous(set = &quot;comet&quot;)) ggDo We can then plot this as a nice pdf plotPDF(ggUp, ggDo, name = &quot;Erythroid-vs-HSC-Markers-Motifs-Enriched&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) "],
["peak-annotation-enrichment-with-archr.html", "Chapter 11 Peak Annotation Enrichment with ArchR ", " Chapter 11 Peak Annotation Enrichment with ArchR "],
["motif-enrichment.html", "11.1 Motif Enrichment", " 11.1 Motif Enrichment #Motif Search in Peak Set and add to Peak Annotations projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) #Identify Motif Enrichments enrichMotifs &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) enrichMotifs # class: SummarizedExperiment # dim: 870 14 # metadata(0): # assays(10): mlog10Padj mlog10p ... CompareFrequency feature # rownames(870): TFAP2B_1 TFAP2D_2 ... TBX18_869 TBX22_870 # rowData names(0): # colnames(14): C1_Early.Eryth C2_CD4.N1 ... C13_CLP.2 C14_pDC # colData names(0): #Heatmap heatmapEM &lt;- enrichHeatmap(enrichMotifs, n = 7, transpose = TRUE) draw(heatmapEM, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapEM, name = &quot;Motifs-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) "],
["archr-enrichment.html", "11.2 ArchR Enrichment", " 11.2 ArchR Enrichment 11.2.1 Encode TFBS projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) #Identify EncodeTFBS Enrichments enrichEncode &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) enrichEncode # class: SummarizedExperiment # dim: 689 14 # metadata(0): # assays(10): mlog10Padj mlog10p ... CompareFrequency feature # rownames(689): 1.CTCF-Dnd41... 2.EZH2_39-Dnd41... ... # 688.CTCF-WERI_Rb_1... 689.CTCF-WI_38... # rowData names(0): # colnames(14): C1_Early.Eryth C2_CD4.N1 ... C13_CLP.2 C14_pDC # colData names(0): #Heatmap heatmapEncode &lt;- enrichHeatmap(enrichEncode, n = 7, transpose = TRUE) draw(heatmapEncode, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapEncode, name = &quot;EncodeTFBS-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) 11.2.2 Bulk ATAC-seq projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) #Identify ATAC Enrichments enrichATAC &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) enrichATAC # class: SummarizedExperiment # dim: 96 14 # metadata(0): # assays(10): mlog10Padj mlog10p ... CompareFrequency feature # rownames(96): Brain_Astrocytes Brain_Excitatory_neurons ... Heme_MPP # Heme_NK # rowData names(0): # colnames(14): C1_Early.Eryth C2_CD4.N1 ... C13_CLP.2 C14_pDC # colData names(0): #Heatmap heatmapATAC &lt;- enrichHeatmap(enrichATAC, n = 7, transpose = TRUE) draw(heatmapATAC, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapATAC, name = &quot;ATAC-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) 11.2.3 Codex TFBS projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;Codex&quot;) #Identify Codex Enrichments enrichCodex &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;Codex&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) enrichCodex # class: SummarizedExperiment # dim: 189 14 # metadata(0): # assays(10): mlog10Padj mlog10p ... CompareFrequency feature # rownames(189): 1.STAT5-No_drug_(DMSO)... 2.RUNX3-GM12878_cell_fr... ... # 188.TP53-codex_Embryonic... 189.TP53-codex_Embryonic... # rowData names(0): # colnames(14): C1_Early.Eryth C2_CD4.N1 ... C13_CLP.2 C14_pDC # colData names(0): #Heatmap heatmapCodex &lt;- enrichHeatmap(enrichCodex, n = 7, transpose = TRUE) draw(heatmapCodex, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapCodex, name = &quot;Codex-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) "],
["custom-enrichment.html", "11.3 Custom Enrichment", " 11.3 Custom Enrichment #Custom Peak Annotations EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) #Identify ChIP Enrichments enrichRegions &lt;- peakAnnoEnrichment( seMarker = markersPeaks, ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot;, cutOff = &quot;FDR &lt;= 0.1 &amp; Log2FC &gt;= 0.5&quot; ) enrichRegions # class: SummarizedExperiment # dim: 4 14 # metadata(0): # assays(10): mlog10Padj mlog10p ... CompareFrequency feature # rownames(4): Encode_K562_GATA1 Encode_GM12878_CEBPB Encode_K562_Ebf1 # Encode_K562_Pax5 # rowData names(0): # colnames(14): C1_Early.Eryth C2_CD4.N1 ... C13_CLP.2 C14_pDC # colData names(0): #Heatmap heatmapRegions &lt;- enrichHeatmap(enrichRegions, n = 7, transpose = TRUE) draw(heatmapRegions, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapRegions, name = &quot;Regions-Enriched-Marker-Heatmap&quot;, width = 8, height = 6, ArchRProj = projHeme5, addDOC = FALSE) "],
["chromvar-deviatons-enrichment-with-archr.html", "Chapter 12 ChromVAR Deviatons Enrichment with ArchR ", " Chapter 12 ChromVAR Deviatons Enrichment with ArchR "],
["motif-deviations.html", "12.1 Motif Deviations", " 12.1 Motif Deviations If you have not added motif annotations projHeme5 &lt;- addMotifAnnotations(ArchRProj = projHeme5, motifSet = &quot;cisbp&quot;, name = &quot;Motif&quot;) If you have not added background peaks projHeme5 &lt;- addBgdPeaks(projHeme5) Add ChromVAR Deviations for Motifs addArchRThreads(8) projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;Motif&quot; ) Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE) # DataFrame with 6 rows and 6 columns # seqnames idx name combinedVars combinedMeans rank # &lt;Rle&gt; &lt;array&gt; &lt;array&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; # f383 z 383 GATA1_383 12.5587654919393 -0.0467737461797836 1 # f388 z 388 GATA2_388 12.5232684663532 -0.0437582624045581 2 # f336 z 336 SPIB_336 11.1449104702032 -0.0563199587385128 3 # f385 z 385 GATA5_385 10.9268531272974 -0.0433659077435513 4 # f155 z 155 CEBPA_155 10.6045910511329 -0.14514233730257 5 # f384 z 384 GATA3_384 10.4460730802746 -0.0428770420598439 6 plotVarDev We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-Motif-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) If we want to get motif feature names for downstream plotting motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;MotifMatrix&quot;) # [1] &quot;z:TBX21_780&quot; &quot;z:PAX5_709&quot; &quot;z:IRF4_632&quot; # [4] &quot;z:GATA1_383&quot; &quot;z:CEBPA_155&quot; &quot;z:EBF1_67&quot; # [7] &quot;z:SREBF1_22&quot; &quot;deviations:TBX21_780&quot; &quot;deviations:PAX5_709&quot; # [10] &quot;deviations:IRF4_632&quot; &quot;deviations:GATA1_383&quot; &quot;deviations:CEBPA_155&quot; # [13] &quot;deviations:EBF1_67&quot; &quot;deviations:SREBF1_22&quot; To get deviation z-scores markerMotifs &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;MotifMatrix&quot;) markerMotifs &lt;- grep(&quot;z:&quot;, markerMotifs, value = TRUE) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;z:SREBF1_22&quot;] markerMotifs # [1] &quot;z:TBX21_780&quot; &quot;z:PAX5_709&quot; &quot;z:IRF4_632&quot; &quot;z:GATA1_383&quot; &quot;z:CEBPA_155&quot; # [6] &quot;z:EBF1_67&quot; We can also now plot the distribution of chromVAR deviation scores for each cluster p &lt;- plotGroups(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, colorBy = &quot;MotifMatrix&quot;, name = markerMotifs, imputeWeights = getImputeWeights(projHeme5) ) To plot all genes we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(seq_along(p), function(x){ if(x != 1){ p[[x]] + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) }else{ p[[x]] + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6) + theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), &quot;cm&quot;)) + theme( axis.ticks.y=element_blank(), axis.title.y=element_blank() ) + ylab(&quot;&quot;) } }) do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2, rep(1, length(p2) - 1))),p2)) We can then plot this as a nice PDF plotPDF(p, name = &quot;Plot-Groups-Deviations-w-Imputation&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) We can now overlay these motif deviation scores on the UMAP embedding p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;MotifMatrix&quot;, name = sort(markerMotifs), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneScoreMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA #[1] &quot;TBX21&quot; &quot;CEBPA&quot; &quot;EBF1&quot; &quot;IRF4&quot; &quot;PAX5&quot; &quot;GATA1&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneScoreMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(motifs, collapse=&quot;|&quot;), useMatrix = &quot;GeneIntegrationMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA #[1] &quot;TBX21&quot; &quot;CEBPA&quot; &quot;EBF1&quot; &quot;IRF4&quot; &quot;PAX5&quot; &quot;GATA1&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneIntegrationMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, continuousSet = &quot;blueYellow&quot;, imputeWeights = getImputeWeights(projHeme5) ) #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) "],
["archr-deviations.html", "12.2 ArchR Deviations", " 12.2 ArchR Deviations 12.2.1 Encode TFBS If you have not added motif annotations projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;EncodeTFBS&quot;) If you have not added background peaks projHeme5 &lt;- addBgdPeaks(projHeme5) Add ChromVAR Deviations for Motifs addArchRThreads(8) projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;EncodeTFBS&quot; ) Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;EncodeTFBSMatrix&quot;) # DataFrame with 6 rows and 6 columns # seqnames idx name combinedVars # &lt;Rle&gt; &lt;array&gt; &lt;array&gt; &lt;numeric&gt; # f222 z 222 222.GATA2_S-K562... 13.3776606277002 # f41 z 41 41.EZH2_39-NHEK... 12.9568688227648 # f542 z 542 542.TAL1_SC-K562... 11.3037382536044 # f498 z 498 498.GATA_2-K562... 10.2006515402356 # f584 z 584 584.GATA_1-PBDEFetal... 10.0732825204346 # f44 z 44 44.EZH2_39-NHLF... 9.67400298749933 plotVarDev We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-EncodeTFBS-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) If we want to get TF feature names for downstream plotting tfs &lt;- c(&quot;GATA_1&quot;, &quot;CEBPB&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) # [1] &quot;z:584.GATA_1-PBDEFetal...&quot; &quot;z:582.GATA_1-PBDE...&quot; # [3] &quot;z:497.GATA_1-K562...&quot; &quot;z:477.CEBPB-K562...&quot; # [5] &quot;z:462.CEBPB-IMR90...&quot; &quot;z:427.CEBPB-HepG2...&quot; # [7] &quot;z:426.CEBPB-HepG2...&quot; &quot;z:379.CEBPB-HeLa_S3...&quot; # [9] &quot;z:344.CEBPB-H1_hESC...&quot; &quot;z:293.EBF1_SC-GM12878...&quot; # [11] &quot;z:278.CEBPB-A549...&quot; &quot;z:213.CEBPB_S-K562...&quot; # [13] &quot;z:173.CEBPB_S-HepG2...&quot; &quot;z:130.PAX5_C2-GM12892...&quot; # [15] &quot;z:123.PAX5_C2-GM12891...&quot; &quot;z:102.PAX5_N1-GM12878...&quot; # [17] &quot;z:101.PAX5_C2-GM12878...&quot; &quot;z:93.IRF4_SC-GM12878...&quot; # [19] &quot;z:87.EBF1_SC-GM12878...&quot; &quot;z:86.CEBPB_S-GM12878...&quot; # [21] &quot;deviations:584.GATA_1-PBDEFetal...&quot; &quot;deviations:582.GATA_1-PBDE...&quot; # [23] &quot;deviations:497.GATA_1-K562...&quot; &quot;deviations:477.CEBPB-K562...&quot; # [25] &quot;deviations:462.CEBPB-IMR90...&quot; &quot;deviations:427.CEBPB-HepG2...&quot; # [27] &quot;deviations:426.CEBPB-HepG2...&quot; &quot;deviations:379.CEBPB-HeLa_S3...&quot; # [29] &quot;deviations:344.CEBPB-H1_hESC...&quot; &quot;deviations:293.EBF1_SC-GM12878...&quot; # [31] &quot;deviations:278.CEBPB-A549...&quot; &quot;deviations:213.CEBPB_S-K562...&quot; # [33] &quot;deviations:173.CEBPB_S-HepG2...&quot; &quot;deviations:130.PAX5_C2-GM12892...&quot; # [35] &quot;deviations:123.PAX5_C2-GM12891...&quot; &quot;deviations:102.PAX5_N1-GM12878...&quot; # [37] &quot;deviations:101.PAX5_C2-GM12878...&quot; &quot;deviations:93.IRF4_SC-GM12878...&quot; # [39] &quot;deviations:87.EBF1_SC-GM12878...&quot; &quot;deviations:86.CEBPB_S-GM12878...&quot; To get deviation z-scores markerTFs &lt;- getFeatures(projHeme5, select = paste(tfs, collapse=&quot;|&quot;), useMatrix = &quot;EncodeTFBSMatrix&quot;) markerTFs &lt;- sort(grep(&quot;z:&quot;, markerTFs, value = TRUE)) TFnames &lt;- stringr::str_split(stringr::str_split(markerTFs, pattern = &quot;\\\\.&quot;, simplify=TRUE)[,2], pattern = &quot;-&quot;, simplify = TRUE)[,1] markerTFs &lt;- markerTFs[!duplicated(TFnames)] markerTFs # [1] &quot;z:101.PAX5_C2-GM12878...&quot; &quot;z:102.PAX5_N1-GM12878...&quot; # [3] &quot;z:173.CEBPB_S-HepG2...&quot; &quot;z:278.CEBPB-A549...&quot; # [5] &quot;z:293.EBF1_SC-GM12878...&quot; &quot;z:497.GATA_1-K562...&quot; # [7] &quot;z:93.IRF4_SC-GM12878...&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;EncodeTFBSMatrix&quot;, name = markerTFs, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(gsub(&quot;_&quot;,&quot;&quot;,tfs), collapse=&quot;|&quot;), useMatrix = &quot;GeneScoreMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;)] markerRNA #[1] &quot;TBX21&quot; &quot;CEBPA&quot; &quot;EBF1&quot; &quot;IRF4&quot; &quot;PAX5&quot; &quot;GATA1&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneScoreMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) We can also plot the gene expression profiles for each of these TFs markerRNA &lt;- getFeatures(projHeme5, select = paste(gsub(&quot;_&quot;,&quot;&quot;,tfs), collapse=&quot;|&quot;), useMatrix = &quot;GeneIntegrationMatrix&quot;) markerRNA &lt;- markerRNA[markerRNA %ni% c(&quot;SREBF1&quot;,&quot;CEBPA-DT&quot;)] markerRNA #[1] &quot;TBX21&quot; &quot;CEBPA&quot; &quot;EBF1&quot; &quot;IRF4&quot; &quot;PAX5&quot; &quot;GATA1&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;GeneIntegrationMatrix&quot;, name = sort(markerRNA), embedding = &quot;UMAP&quot;, continuousSet = &quot;blueYellow&quot;, imputeWeights = getImputeWeights(projHeme5) ) #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) 12.2.2 Bulk ATAC-seq If you have not added motif annotations projHeme5 &lt;- addArchRAnnotations(ArchRProj = projHeme5, collection = &quot;ATAC&quot;) If you have not added background peaks projHeme5 &lt;- addBgdPeaks(projHeme5) Add ChromVAR Deviations for Motifs addArchRThreads(8) projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ATAC&quot; ) Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ATACMatrix&quot;) # DataFrame with 6 rows and 6 columns # seqnames idx name combinedVars # &lt;Rle&gt; &lt;array&gt; &lt;array&gt; &lt;numeric&gt; # f22 z 22 IAtlas_T_CD8posCenMem 12.0581125421541 # f86 z 86 Heme_CD8 11.6532963605177 # f85 z 85 Heme_CD4 11.5670776340581 # f23 z 23 IAtlas_T_CD8posEffMem 11.4627247478874 # f33 z 33 IAtlas_T_Th1Precursor 11.4097813814495 # f19 z 19 IAtlas_T_CD4posEffector 11.398315976261 plotVarDev We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-ATAC-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) If we want to get TF feature names for downstream plotting ATACPeaks &lt;- c(&quot;Heme_HSC&quot;, &quot;Heme_LMPP&quot;, &quot;Heme_Ery&quot;, &quot;Heme_Mono&quot;, &quot;Heme_CD4&quot;, &quot;Heme_CD8&quot;, &quot;Heme_B&quot;, &quot;Heme_NK&quot;, &quot;IAtlas_DC_Plasmacytoid&quot;) getFeatures(projHeme5, select = paste(ATACPeaks, collapse=&quot;|&quot;), useMatrix = &quot;ATACMatrix&quot;) # [1] &quot;z:Heme_NK&quot; &quot;z:Heme_Mono&quot; # [3] &quot;z:Heme_MEP&quot; &quot;z:Heme_LMPP&quot; # [5] &quot;z:Heme_HSC&quot; &quot;z:Heme_CD8&quot; # [7] &quot;z:Heme_CD4&quot; &quot;z:Heme_B&quot; # [9] &quot;z:IAtlas_DC_Plasmacytoid&quot; &quot;deviations:Heme_NK&quot; # [11] &quot;deviations:Heme_Mono&quot; &quot;deviations:Heme_MEP&quot; # [13] &quot;deviations:Heme_LMPP&quot; &quot;deviations:Heme_HSC&quot; # [15] &quot;deviations:Heme_CD8&quot; &quot;deviations:Heme_CD4&quot; # [17] &quot;deviations:Heme_B&quot; &quot;deviations:IAtlas_DC_Plasmacytoid&quot; To get deviation z-scores markerATAC &lt;- getFeatures(projHeme5, select = paste(ATACPeaks, collapse=&quot;|&quot;), useMatrix = &quot;ATACMatrix&quot;) markerATAC &lt;- sort(grep(&quot;z:&quot;, markerATAC, value = TRUE)) markerATAC # [1] &quot;z:Heme_B&quot; &quot;z:Heme_CD4&quot; # [3] &quot;z:Heme_CD8&quot; &quot;z:Heme_HSC&quot; # [5] &quot;z:Heme_MEP&quot; &quot;z:Heme_Mono&quot; # [7] &quot;z:Heme_NK&quot; &quot;z:IAtlas_DC_Plasmacytoid&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ATACMatrix&quot;, name = markerATAC, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 3),p2)) "],
["custom-deviations.html", "12.3 Custom Deviations", " 12.3 Custom Deviations If you have not added motif annotations #Custom Peak Annotations EncodePeaks &lt;- c( Encode_K562_GATA1 = &quot;https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz&quot;, Encode_GM12878_CEBPB = &quot;https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz&quot;, Encode_K562_Ebf1 = &quot;https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz&quot;, Encode_K562_Pax5 = &quot;https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz&quot; ) projHeme5 &lt;- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = &quot;ChIP&quot;) If you have not added background peaks projHeme5 &lt;- addBgdPeaks(projHeme5) Add ChromVAR Deviations for Motifs addArchRThreads(8) projHeme5 &lt;- addDeviationsMatrix( ArchRProj = projHeme5, peakAnnotation = &quot;ChIP&quot; ) Plot Variable Motif Annotations plotVarDev &lt;- getVarDeviations(projHeme5, plot = TRUE, name = &quot;ChIPMatrix&quot;) # DataFrame with 4 rows and 6 columns # seqnames idx name combinedVars combinedMeans # &lt;Rle&gt; &lt;array&gt; &lt;array&gt; &lt;numeric&gt; &lt;numeric&gt; # f1 z 1 Encode_K562_GATA1 6.19256551652079 -0.0229048763845575 # f3 z 3 Encode_K562_Ebf1 3.31156290837234 0.0394899516880888 # f4 z 4 Encode_K562_Pax5 2.93016136274537 -0.00867706262058369 # f2 z 2 Encode_GM12878_CEBPB 0.779863387389073 0.00919359271019273 plotVarDev We can then plot this as a nice PDF plotPDF(plotVarDev, name = &quot;Variable-ChIP-Deviation-Scores&quot;, width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE) To get deviation z-scores markerChIP &lt;- getFeatures(projHeme5, useMatrix = &quot;ChIPMatrix&quot;) markerChIP &lt;- sort(grep(&quot;z:&quot;, markerChIP, value = TRUE)) markerChIP # [1] &quot;z:Encode_GM12878_CEBPB&quot; &quot;z:Encode_K562_Ebf1&quot; &quot;z:Encode_K562_GATA1&quot; # [4] &quot;z:Encode_K562_Pax5&quot; p &lt;- plotEmbedding( ArchRProj = projHeme5, colorBy = &quot;ChIPMatrix&quot;, name = markerChIP, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHeme5) ) To plot all motifs we can use cowplot #Rearrange for grid plotting p2 &lt;- lapply(p, function(x){ x + guides(color = FALSE, fill = FALSE) + theme_ArchR(baseSize = 6.5) + theme(plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;)) + theme( axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) }) do.call(cowplot::plot_grid, c(list(ncol = 2),p2)) "],
["footprinting-with-archr.html", "Chapter 13 Footprinting with ArchR ", " Chapter 13 Footprinting with ArchR "],
["motif-footprinting.html", "13.1 Motif Footprinting", " 13.1 Motif Footprinting Transcription factor footprinting can also be done in ArchR with a single command. We note that the footprints generated by the tutorial data are not as clean as would be desired but this is because of the small size of the tutorial dataset. motifPositions &lt;- getPositions(projHeme5) motifPositions # GRangesList object of length 870: # $TFAP2B_1 # GRanges object with 18839 ranges and 1 metadata column: # seqnames ranges strand | score # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; # [1] chr1 874977-874988 + | 8.1040240314385 # [2] chr1 876278-876289 + | 9.07480855168228 # [3] chr1 878394-878405 + | 8.13251230888635 # [4] chr1 878394-878405 - | 8.55091380875033 # [5] chr1 896470-896481 + | 8.82805137346104 # ... ... ... ... . ... # [18835] chrX 154299568-154299579 + | 8.86292599058688 # [18836] chrX 154299568-154299579 - | 8.08701861760796 # [18837] chrX 154664929-154664940 - | 8.12813446630685 # [18838] chrX 154807684-154807695 + | 9.53908578301561 # [18839] chrX 154807684-154807695 - | 10.5729555847813 # ... # &lt;869 more elements&gt; # ------- # seqinfo: 23 sequences from an unspecified genome; no seqlengths Find TF-Motifs motifs &lt;- c(&quot;GATA1&quot;, &quot;CEBPA&quot;, &quot;EBF1&quot;, &quot;IRF4&quot;, &quot;TBX21&quot;, &quot;PAX5&quot;) markerMotifs &lt;- unlist(lapply(motifs, function(x) grep(x, names(motifPositions), value = TRUE))) markerMotifs &lt;- markerMotifs[markerMotifs %ni% &quot;SREBF1_22&quot;] markerMotifs # [1] &quot;GATA1_383&quot; &quot;CEBPA_155&quot; &quot;EBF1_67&quot; &quot;IRF4_632&quot; &quot;TBX21_780&quot; &quot;PAX5_709&quot; #Create Group Coverage Files if you have not done so already projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) 13.1.1 No Normalization #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set seFoot_None &lt;- plotFootprints( ArchRProj = projHeme5, positions = motifPositions[markerMotifs], groupBy = &quot;Clusters2&quot;, normMethod = &quot;none&quot;, plotName = &quot;Footprints-No-Normalization&quot; ) By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. 13.1.2 Divide Tn5 Bias #Re-Plot with different normalization method seFoot_Divide &lt;- plotFootprints( ArchRProj = projHeme5, inputSE = seFoot_None, positions = motifPositions[markerMotifs], groupBy = &quot;Clusters2&quot;, normMethod = &quot;divide&quot;, plotName = &quot;Footprints-Divide-Bias&quot; ) By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. 13.1.3 Subtract Tn5 Bias #Re-Plot with different normalization method seFoot_Subtract &lt;- plotFootprints( ArchRProj = projHeme5, inputSE = seFoot_None, positions = motifPositions[markerMotifs], groupBy = &quot;Clusters2&quot;, normMethod = &quot;subtract&quot;, plotName = &quot;Footprints-Subtract-Bias&quot; ) By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. "],
["feature-footprinting.html", "13.2 Feature Footprinting", " 13.2 Feature Footprinting #Create Group Coverage Files if you have not done so already projHeme5 &lt;- addGroupCoverages(ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;) 13.2.1 No Normalization #Plot Motif Footprints from positions list #Recommend doing a few motifs not entire motif set seTSS_None &lt;- plotFootprints( ArchRProj = projHeme5, positions = GRangesList(TSS = getTSS(projHeme5)), groupBy = &quot;Clusters2&quot;, normMethod = &quot;none&quot;, plotName = &quot;TSS-No-Normalization&quot;, flank = 2000, flankNorm = 100 ) By default the plots will be in the outputDirectory of the ArchRProject. The challenge is that if you requested to plot all motifs and returned this as a ggplot object it could be extremely large. An example of motif footprints ran from this function are seen below. "],
["trajectory-analysis-with-archr.html", "Chapter 14 Trajectory Analysis with ArchR ", " Chapter 14 Trajectory Analysis with ArchR "],
["myeloid-trajectory.html", "14.1 Myeloid Trajectory", " 14.1 Myeloid Trajectory p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) #Trajectory to add trajectory &lt;- c(paste0(&quot;Cluster&quot;, c(6, 7, 8, 9, 10))) trajectory # [1] &quot;Cluster6&quot; &quot;Cluster7&quot; &quot;Cluster8&quot; &quot;Cluster9&quot; &quot;Cluster10&quot; #First we need to create a Trajectory and add it to ArchRProj cellColData projHeme5 &lt;- addTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE) head(projHeme5$MyeloidU) # [1] 24.56879 44.02464 35.80082 38.66530 24.44559 38.37782 p &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;colData&quot;, name = &quot;MyeloidU&quot;) p To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p, name = &quot;Plot-MyeloidU-Traj-UMAP.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) We can overlay other features on the UMAP p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;horizonExtra&quot;) p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;MyeloidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;CEBPB&quot;, continuousSet = &quot;blueYellow&quot;) ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) We can then make a heatmap for trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE) p1 &lt;- trajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE) p2 &lt;- trajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;)) trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE) p3 &lt;- trajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;)) trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;MyeloidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE) p4 &lt;- trajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, p2, p3, p4, name = &quot;Plot-MyeloidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) We can also try integrating our gene scores with the RNA trajGSM2 &lt;- trajGSM[which(rowData(trajGSM)$name %in% rowData(trajGIM)$name), ] trajGIM2 &lt;- trajGIM[which(rowData(trajGIM)$name %in% rowData(trajGSM)$name), ] rowOrder &lt;- trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), returnMat = TRUE) plotPDF( trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), rowOrder = rownames(rowOrder)) + trajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), rowOrder = rownames(rowOrder)), name = &quot;Plot-MyeloidU-RNA-GS.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 10, height = 8) "],
["lymphoid-trajectory.html", "14.2 Lymphoid Trajectory", " 14.2 Lymphoid Trajectory p1 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHeme5, colorBy = &quot;cellColData&quot;, name = &quot;Clusters2&quot;, embedding = &quot;UMAP&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) #Trajectory to add trajectory &lt;- c(paste0(&quot;Cluster&quot;, c(6, 13, 12, 11))) trajectory # [1] &quot;Cluster6&quot; &quot;Cluster13&quot; &quot;Cluster12&quot; &quot;Cluster11&quot; #First we need to create a Trajectory and add it to ArchRProj cellColData projHeme5 &lt;- addTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, trajectory = trajectory, embedding = &quot;UMAP&quot;, force = TRUE) head(projHeme5$LymphoidU) # [1] NA NA 80.56020 NA 79.47324 NA p &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;colData&quot;, name = &quot;LymphoidU&quot;) p To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p, name = &quot;Plot-LymphoidU-Traj-UMAP.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) We can overlay other features on the UMAP p1 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneScoreMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;horizonExtra&quot;) p2 &lt;- plotTrajectory(projHeme5, trajectory = &quot;LymphoidU&quot;, colorBy = &quot;GeneIntegrationMatrix&quot;, name = &quot;PAX5&quot;, continuousSet = &quot;blueYellow&quot;) ggAlignPlots(p1[[1]], p2[[1]], type = &quot;h&quot;) ggAlignPlots(p1[[2]], p2[[2]], type = &quot;h&quot;) We can then make a heatmap for trajMM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;MotifMatrix&quot;, log2Norm = FALSE) p1 &lt;- trajectoryHeatmap(trajMM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) trajGSM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneScoreMatrix&quot;, log2Norm = TRUE) p2 &lt;- trajectoryHeatmap(trajGSM, pal = paletteContinuous(set = &quot;horizonExtra&quot;)) trajGIM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;GeneIntegrationMatrix&quot;, log2Norm = FALSE) p3 &lt;- trajectoryHeatmap(trajGIM, pal = paletteContinuous(set = &quot;blueYellow&quot;)) trajPM &lt;- getTrajectory(ArchRProj = projHeme5, name = &quot;LymphoidU&quot;, useMatrix = &quot;PeakMatrix&quot;, log2Norm = TRUE) p4 &lt;- trajectoryHeatmap(trajPM, pal = paletteContinuous(set = &quot;solarExtra&quot;)) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1, p2, p3, p4, name = &quot;Plot-LymphoidU-Traj-Heatmaps.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 6, height = 8) We can also try integrating our gene scores with the RNA trajGSM2 &lt;- trajGSM[which(rowData(trajGSM)$name %in% rowData(trajGIM)$name), ] trajGIM2 &lt;- trajGIM[which(rowData(trajGIM)$name %in% rowData(trajGSM)$name), ] rowOrder &lt;- trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), returnMat = TRUE) plotPDF( trajectoryHeatmap(trajGIM2, pal = paletteContinuous(set = &quot;blueYellow&quot;), rowOrder = rownames(rowOrder)) + trajectoryHeatmap(trajGSM2, pal = paletteContinuous(set = &quot;horizonExtra&quot;), rowOrder = rownames(rowOrder)), name = &quot;Plot-LymphoidU-RNA-GS.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 10, height = 8) "],
["peak-linkage-with-archr.html", "Chapter 15 Peak Linkage with ArchR ", " Chapter 15 Peak Linkage with ArchR "],
["coaccessibility-with-archr.html", "15.1 CoAccessibility with ArchR", " 15.1 CoAccessibility with ArchR projHeme5 &lt;- addCoAccessibility( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = FALSE ) cA # DataFrame with 65736 rows and 4 columns # queryHits subjectHits seqnames correlation # &lt;integer&gt; &lt;integer&gt; &lt;Rle&gt; &lt;numeric&gt; # 1 8 13 chr1 0.69736362363962 # 2 13 8 chr1 0.69736362363962 # 3 52 64 chr1 0.502479053390956 # 4 54 55 chr1 0.573405135422231 # 5 55 54 chr1 0.573405135422231 # ... ... ... ... ... # 65732 158297 158296 chrX 0.5541398895206 # 65733 158332 158333 chrX 0.504941172383233 # 65734 158333 158332 chrX 0.504941172383233 # 65735 158339 158340 chrX 0.506143160385986 # 65736 158340 158339 chrX 0.506143160385985 metadata(cA)[[1]] # GRanges object with 158378 ranges and 0 metadata columns: # seqnames ranges strand # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; # Cluster10 chr1 752327-752827 * # Cluster9 chr1 760866-761366 * # Cluster2 chr1 762700-763200 * # Cluster2 chr1 779639-780139 * # Cluster8 chr1 793519-794019 * # ... ... ... ... # Cluster5 chrX 154841853-154842353 * # Cluster12 chrX 154842354-154842854 * # Cluster4 chrX 154862032-154862532 * # Cluster5 chrX 154912371-154912871 * # Cluster6 chrX 154996898-154997398 * cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1, returnLoops = TRUE ) # GenomicRangesList of length 1 # names(1): CoAccessibility cA[[1]] # GRanges object with 32868 ranges and 1 metadata column: # seqnames ranges strand | value # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; # [1] chr1 845640-856561 * | 0.69736362363962 # [2] chr1 968601-1004143 * | 0.502479053390956 # [3] chr1 974287-975100 * | 0.573405135422231 # [4] chr1 1034332-1034887 * | 0.807870076075987 # [5] chr1 1072846-1079621 * | 0.591975205782561 # ... ... ... ... . ... # [32864] chrX 153597267-153637554 * | 0.501648373320333 # [32865] chrX 153637554-153659408 * | 0.534554389595235 # [32866] chrX 153659408-153659914 * | 0.5541398895206 # [32867] chrX 153959662-153960350 * | 0.504941172383233 # [32868] chrX 153980214-153990355 * | 0.506143160385986 cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 1000, returnLoops = TRUE ) cA[[1]] # GRanges object with 30315 ranges and 1 metadata column: # seqnames ranges strand | value # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; # [1] chr1 845500-856500 * | 0.69736362363962 # [2] chr1 968500-1004500 * | 0.502479053390956 # [3] chr1 974500-975500 * | 0.573405135422231 # [4] chr1 1072500-1079500 * | 0.591975205782561 # [5] chr1 1072500-1109500 * | 0.509755959269061 # ... ... ... ... . ... # [30311] chrX 153596500-153597500 * | 0.526200963980073 # [30312] chrX 153597500-153637500 * | 0.501648373320333 # [30313] chrX 153637500-153659500 * | 0.534554389595235 # [30314] chrX 153959500-153960500 * | 0.504941172383233 # [30315] chrX 153980500-153990500 * | 0.506143160385986 # ------- # seqinfo: 23 sequences from an unspecified genome; no seqlengths cA &lt;- getCoAccessibility( ArchRProj = projHeme5, corCutOff = 0.5, resolution = 10000, returnLoops = TRUE ) cA[[1]] # GRanges object with 15990 ranges and 1 metadata column: # seqnames ranges strand | value # &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; # [1] chr1 845000-855000 * | 0.69736362363962 # [2] chr1 965000-1005000 * | 0.502479053390956 # [3] chr1 1075000-1085000 * | 0.542909007799088 # [4] chr1 1075000-1105000 * | 0.522706329518404 # [5] chr1 1105000-1115000 * | 0.607428937524039 # ... ... ... ... . ... # [15986] chrX 153305000-153345000 * | 0.63313940661629 # [15987] chrX 153595000-153635000 * | 0.501648373320333 # [15988] chrX 153635000-153655000 * | 0.534554389595235 # [15989] chrX 153955000-153965000 * | 0.504941172383233 # [15990] chrX 153985000-153995000 * | 0.506143160385986 # ------- # seqinfo: 23 sequences from an unspecified genome; no seqlengths Plotting browser tracks with CoAccessibility markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- ArchRBrowserTrack( ArchRProj = projHeme5, groupBy = &quot;Clusters2&quot;, geneSymbol = markerGenes, upstream = 50000, downstream = 50000 ) To plot a track we can simply print one from the list grid::grid.newpage() grid::grid.draw(p$CD14) plotPDF(plotList = p, name = &quot;Plot-Tracks-Marker-Genes-with-CoAccessibility.pdf&quot;, ArchRProj = projHeme5, addDOC = FALSE, width = 5, height = 5) Download PDF : Plot-Tracks-Marker-Genes.pdf "],
["peak2genelinkage-with-archr.html", "15.2 Peak2GeneLinkage with ArchR", " 15.2 Peak2GeneLinkage with ArchR projHeme5 &lt;- addPeak2GeneLinks( ArchRProj = projHeme5, reducedDims = &quot;IterativeLSI&quot; ) "]
]
