[
["index.html", "ArchR Preface", " ArchR Jeffrey Granja and Ryan Corces 2020-02-14 Preface This is the ArchR documentation. "],
["getting-started-with-archr.html", "Chapter 1 Getting Started with ArchR", " Chapter 1 Getting Started with ArchR The following tutorial shows the basics of setting up and interacting with an ArchRProject using a gold-standard downsampled dataset of hematopoietic cells Granja* et al. Nature Biotechnology 2019. This tutorial and all of the accompanying vignettes assume that you are running ArchR locally. QQQ Once all of these steps work for you, feel free to set up ArchR to work in a cluster environment. This tutorial does not explain every detail of every step but rather shows you how to perform the most common analyses. Please see the Vignettes section for more details on each major analytical step and all of the major features of ArchR. "],
["what-is-an-arrowfile-archrproject.html", "1.1 What is an ArrowFile / ArchRProject?", " 1.1 What is an ArrowFile / ArchRProject? The base unit of an analytical projHemeect in ArchR is called an ArrowFile. Each ArrowFile stores all of the data associated with an individual sample (i.e. metadata, accessible fragments, and data matrices). Here, an “individual sample” would be the most detailed unit of analysis desired (for ex. a single replicate of a particular condition). During creation and as additional analyses are performed, ArchR updates and edits each ArrowFile to contain additional layers of information. It is worth noting that, to ArchR, an ArrowFile is actually just a path to an external file stored on disk. More explicitly, an ArrowFile is not an R-language object that is stored in memory. Because of this, we use an ArchRProject object to associate these ArrowFiles together into a single analytical framework that can be rapidly accessed in R. This ArchRProject object is small in size and is stored in memory. Certain actions can be taken directly on ArrowFiles while other actions are taken on an ArchRProject which in turn updates each associated ArrowFile. Because ArrowFiles are stored as large HDF5-format files, “get-er” functions in ArchR retrieve data by interacting with the ArchRProject while “add-er” functions either (i) add data directly to ArrowFiles, (ii) add data directly to an ArchRProject, or (iii) add data to ArrowFiles by interacting with an ArchRProject. "],
["getting-set-up.html", "1.2 Getting Set Up", " 1.2 Getting Set Up The first thing we do is set up our working directory, load our gene and genome annotations, and set the number of threads we would like to use. Depending on the configuration of your local environment, you may need to modify the number of threads used below in addArchRThreads(). By default ArchR uses half of the total number of threads available but you can adjust this manually as you see fit. If you are using windows, the usable threads will automatically be set to 1 because the parallel processing in ArchR is build for Unix-based operating systems. For the purposes of this tutorial, we provide the gene and genome annotations but you can create your own using the createGeneAnnotation() and createGenomeAnnotation() functions. See the Gene and Genome Annotations vignette for more information. #Load R Libraries library(ArchR) #Create a new folder and set this as the working directory for tutorial analyses wd &lt;- &quot;ArchR_Walkthrough&quot; dir.create(wd, showWarnings = FALSE, recursive = TRUE) setwd(wd) #Set Genome Annotations to be used #Since our tutorial data sets are using scATAC-seq data from hg19 we will set that as the default genome. addArchRGenome(&quot;hg19&quot;) #Set Default Threads for ArchR Functions #The recommendation is to set it around 1/2 to 3/4 of the total available cores. addArchRThreads(threads = 6) "],
["setting-a-genome-and-geneannotation.html", "1.3 Setting a Genome and GeneAnnotation", " 1.3 Setting a Genome and GeneAnnotation ArchR requires information about the genome you want to work on to do common things such as TSSEnrichment, Nucleotide Content, Gene Scores etc. To provide this information we have made this streamlined for human and mouse and provide a solution for other genome builds. To set a global genome default to hg19 simply add the ArchR genome we have precompiled. This means that for all analysis it will use the genomeAnnotation and geneAnnotation associated with the ArchRGenome. addArchRGenome(&quot;hg19&quot;) # Setting default genome to Hg19. To set a global genome default to hg38 simply add the ArchR genome we have precompiled. addArchRGenome(&quot;hg38&quot;) # Setting default genome to Hg38. To set a global genome default to mm9 simply add the ArchR genome we have precompiled. addArchRGenome(&quot;mm9&quot;) # Setting default genome to Mm9. To set a global genome default to mm10 simply add the ArchR genome we have precompiled. addArchRGenome(&quot;mm10&quot;) # Setting default genome to Mm10. To create a custom genome annotation for use instead we can use createGenomeAnnotation. To do this, you will need the following information : 1. A BSgenome which contains the sequence information for a genome. These are commonly Bioconductor packages that can be easily found with google. 2. A blacklist genomic ranges object that will be used to filter out unwanted regions for downstream analysis. This isnt required but is recommended. library(BSgenome.Hsapiens.UCSC.hg19) genomeAnnotation &lt;- createGenomeAnnotation(genome = BSgenome.Hsapiens.UCSC.hg19) # List of length 3 # names(3): genome chromSizes blacklist To create a custom gene annotation for use instead we can use createGeneAnnotation. To do this, you will need the following information : 1. A TxDb object (transcript database) from Bioconductor which contains information for gene/transcript coordinates. For example, from txdb &lt;- TxDb.Hsapiens.UCSC.hg38.knownGene. 2. An OrgDb object (organism database) from Bioconductor which contains information for gene/transcript symbols from ids. For example, from orgdb &lt;- org.Hs.eg.db. library(TxDb.Hsapiens.UCSC.hg19.knownGene) library(org.Hs.eg.db) txdb &lt;- TxDb.Hsapiens.UCSC.hg19.knownGene orgdb &lt;- org.Hs.eg.db geneAnnotation &lt;- createGeneAnnnotation(TxDb = txdb, OrgDb = orgdb) # List of length 3 # names(3): genes exons TSS or you will need the following information : A GRanges object containing gene coordinates (start to end). Must have a symbols column matching the symbols column of exons. A GRanges object containing gene exon coordinates. Must have a symbols column matching the symbols column of genes. A GRanges object containing standed transcription start site coordinates for computing TSS enrichment scores downstream. geneAnnotation &lt;- createGeneAnnnotation(TSS = geneAnnotation$TSS, exons = geneAnnotation$exons, genes = geneAnnotation$genes) geneAnnotation # List of length 3 # names(3): genes exons TSS "],
["creating-arrow-files.html", "1.4 Creating Arrow Files", " 1.4 Creating Arrow Files For this tutorial, we will download a collection of fragment files. Fragment files are one of the base file types of the 10x Genomics analytical platform (and other platforms) and can be easily created from any BAM file. See the ArchR input file types vignette for information on making your own fragment files for input to ArchR. Once we have our fragment files, we provide their paths as a character vector to createArrowFiles(). During creation, some basic metadata and matrices are added to each ArrowFile including a “TileMatrix” containing insertion counts across genome-wide 500-bp bins (see addTileMatrix()) and a “GeneScoreMatrix” that is determined based on weighting insertion counts in tiles nearby a gene promoter (see addGeneScoreMatrix()). These gene activity scores are described in more depth in the Gene Activity Score vignette. #Get Tutorial Data ~0.6GB To Download (if downloaded already ArchR will bypass downloading). inputFiles &lt;- getTutorialData(&quot;Hematopoiesis&quot;) inputFiles # scATAC_BMMC_R1 # &quot;HemeFragments/scATAC_BMMC_R1.fragments.tsv.gz&quot; # scATAC_CD34_BMMC_R1 # &quot;HemeFragments/scATAC_CD34_BMMC_R1.fragments.tsv.gz&quot; # scATAC_PBMC_R1 # &quot;HemeFragments/scATAC_PBMC_R1.fragments.tsv.gz&quot; Create Arrow Files (~10-15 minutes) w/ helpful messages displaying progress. For each sample, this step will: 1. Read accessible fragments from inputFiles. 2. Calculate QC Information for each cell (TSS Enrichment, Nucleosome info). 3. Filter cells based on QC parameters. 4. Create a genome-wide TileMatrix using 500-bp bins. 5. Create a GeneScoreMatrix using the custom geneAnnotation related to when we set addArchRGenome. #Set to hg19 addArchRGenome(&quot;hg19&quot;) ArrowFiles &lt;- createArrowFiles( inputFiles = inputFiles, sampleNames = names(inputFiles), filterTSS = 4, #Dont set this too high because you can always increase later filterFrags = 1000, addTileMat = TRUE, addGeneScoreMat = TRUE ) ArrowFiles # [1] &quot;scATAC_BMMC_R1.arrow&quot; &quot;scATAC_CD34_BMMC_R1.arrow&quot; # [3] &quot;scATAC_PBMC_R1.arrow&quot; #JJJ QualityControl/scATAC_BMMC_R2/scATAC_BMMC_R2-TSS_by_Unique_Frags.pdf #JJJ QualityControl/scATAC_BMMC_R2/scATAC_BMMC_R2-Fragment_Size_Distribution.pdf "],
["inferring-scatac-seq-doublets-with-archr.html", "1.5 Inferring scATAC-seq Doublets with ArchR", " 1.5 Inferring scATAC-seq Doublets with ArchR One major source of trouble in single-cell data is the contribution of “doublets” to the analysis. A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell. We remove these computationally and describe this doublet removal process in more depth in the doublet removal vignette. #Add Infered Doublet Scores to each Arrow File (~2-5 min per sample) #By default ArchR uses the doublet params as described in the ArchR paper. #We show some of the main adjustable features below for more information #Try ?addDoubletScores to see further documentation on parameters for doublet identification. doubScores &lt;- addDoubletScores( input = ArrowFiles, k = 10, #Refers to how many cells near a &quot;pseudo-doublet&quot; to count. knnMethod = &quot;UMAP&quot;, #Refers to embedding to use for nearest neighbor search with doublet projection. LSIMethod = 1 ) "],
["creating-an-archrproject.html", "Chapter 2 Creating an ArchRProject ", " Chapter 2 Creating an ArchRProject "],
["creating-an-archrproject-1.html", "2.1 Creating An ArchRProject", " 2.1 Creating An ArchRProject #Create ArchRProject #The outputDirectory here describes where all downstream analyses and plots go. #ArchR will add geneAnnotation and genomeAnnotations related to addArchRGenome(&quot;hg19&quot;) #as described above. projHeme &lt;- ArchRProject( ArrowFiles = ArrowFiles, outputDirectory = &quot;HemeTutorial&quot;, copyArrows = TRUE #This is recommened so that if you modify the ArrowFiles you have an original copy for later usage. ) Lets look at our ArchRProject projHeme # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 10661 # medianTSS(1): 16.832 # medianFrags(1): 3050 We can see from above the specified outputDirectory, sampleNames, sampleColData (column data associated with each sample), cellColData (column data associated with each cell), the number of cells, median TSS enrichment and median number of fragments. Additionally since we already computed doublet enrichment scores we can see in cellColData a column name “DoubletEnrichment” and “DoubletScore” which are related to the above addition of addDoubletScores. How big is the created ArchRProject in memory in R. paste0(&quot;Memory Size = &quot;, round(object.size(projHeme) / 10^6, 3), &quot; MB&quot;) #[1] &quot;Memory Size = 37.135 MB&quot; "],
["manipulating-an-archrproject.html", "2.2 Manipulating An ArchRProject", " 2.2 Manipulating An ArchRProject Now that we have created an ArchRProject, there ample things that one can do to easily access/manipulate the data associated. Example 1. The $ accessor, this allows direct access to cellColData #A. Access cell names associated with each cell head(projHeme$cellNames) # [1] &quot;scATAC_BMMC_R1#TTATGTCAGTGATTAG-1&quot; &quot;scATAC_BMMC_R1#AAGATAGTCACCGCGA-1&quot; # [3] &quot;scATAC_BMMC_R1#GCATTGAAGATTCCGT-1&quot; &quot;scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1&quot; # [5] &quot;scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1&quot; &quot;scATAC_BMMC_R1#AGTTACGAGAACGTCG-1&quot; #B. Access sample names associated with each cell projHeme$Sample # character-Rle of length 10661 with 3 runs # Lengths: 4932 3275 2454 # Values : &quot;scATAC_BMMC_R1&quot; &quot;scATAC_CD34_BMMC_R1&quot; &quot;scATAC_PBMC_R1&quot; #C. Access TSS Enrichment Scores for each cell quantile(projHeme$TSSEnrichment) # 0% 25% 50% 75% 100% # 4.027 13.922 16.832 19.937 41.782 Example 2. Subsetting an ArchRProject By Cells #A. Subsetting like a data.frame numerically projHeme[1:100, ] #First 100 cells # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 100 # medianTSS(1): 10.7725 # medianFrags(1): 10200.5 #B. Subetting like a data.frame with cellNames projHeme[projHeme$cellNames[1:100], ] # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 100 # medianTSS(1): 10.7725 # medianFrags(1): 10200.5 #C. Subsetting for 1 sample idxSample &lt;- BiocGenerics::which(projHeme$Sample %in% &quot;scATAC_BMMC_R1&quot;) cellsSample &lt;- projHeme$cellNames[idxSample] projHeme[cellsSample, ] # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 4932 # medianTSS(1): 15.254 # medianFrags(1): 2771 #D. Increasing TSS cutoff idxPass &lt;- which(projHeme$TSSEnrichment &gt;= 8) cellsPass &lt;- projHeme$cellNames[idxPass] projHeme[cellsPass, ] # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 10500 # medianTSS(1): 16.9275 # medianFrags(1): 3042 Example 3. Adding data to an ArchRProject #Add a column removing replicate info bioNames &lt;- gsub(&quot;_R2|_R1|scATAC_&quot;,&quot;&quot;,projHeme$Sample) bioNames # character-Rle of length 10661 with 3 runs # Lengths: 4932 3275 2454 # Values : &quot;BMMC&quot; &quot;CD34_BMMC&quot; &quot;PBMC&quot; projHeme$bioNames &lt;- bioNames #Add a column with partial info bioNames &lt;- bioNames[1:10] cellNames &lt;- projHeme$cellNames[1:10] projHeme &lt;- addCellColData(ArchRProj = projHeme, data = paste0(bioNames), cells = cellNames, name = &quot;bioNames2&quot;) #Lets compare the results getCellColData(projHeme, select = c(&quot;bioNames&quot;, &quot;bioNames2&quot;)) # DataFrame with 10661 rows and 2 columns # bioNames bioNames2 # &lt;character&gt; &lt;character&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 BMMC BMMC # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 BMMC BMMC # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 BMMC BMMC # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 BMMC BMMC # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 BMMC BMMC # ... ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 PBMC NA # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 PBMC NA # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 PBMC NA # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 PBMC NA # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 PBMC NA Example 4. Log10 Unique Fragments df &lt;- getCellColData(projHeme, select = &quot;nFrags&quot;) df # DataFrame with 10661 rows and 1 column # nFrags # &lt;numeric&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 26189 # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 20648 # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 18991 # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 18296 # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 17458 # ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 1038 # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 1037 # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 1033 # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 1033 # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 1002 df &lt;- getCellColData(projHeme, select = c(&quot;log10(nFrags)&quot;, &quot;nFrags - 1&quot;)) df # DataFrame with 10661 rows and 2 columns # log10(nFrags) nFrags - 1 # &lt;numeric&gt; &lt;numeric&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 26188 # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 20647 # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 18990 # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 18295 # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 17457 # ... ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 1037 # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 1036 # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 1032 # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 1032 # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 1001 Example 5. Log10 Unique Frags vs TSSEnrichment df &lt;- getCellColData(projHeme, select = c(&quot;log10(nFrags)&quot;, &quot;TSSEnrichment&quot;)) df # DataFrame with 10661 rows and 2 columns # log10(nFrags) TSSEnrichment # &lt;numeric&gt; &lt;numeric&gt; # scATAC_BMMC_R1#TTATGTCAGTGATTAG-1 4.4181189156542 7.149 # scATAC_BMMC_R1#AAGATAGTCACCGCGA-1 4.31487799153581 7.911 # scATAC_BMMC_R1#GCATTGAAGATTCCGT-1 4.27854783377585 4.505 # scATAC_BMMC_R1#TATGTTCAGGGTTCCC-1 4.26235615159869 6.946 # scATAC_BMMC_R1#TCCATCGGTCCCGTGA-1 4.24199448915678 4.799 # ... ... ... # scATAC_PBMC_R1#GCTGCGAAGATCCGAG-1 3.01619735351244 24.356 # scATAC_PBMC_R1#GCAGCTGGTGGCCTTG-1 3.01577875638904 22.537 # scATAC_PBMC_R1#GCAGATTGTACGCAAG-1 3.01410032151962 20.146 # scATAC_PBMC_R1#TTCGTTACATTGAACC-1 3.01410032151962 30.198 # scATAC_PBMC_R1#CGCTATCGTGAGGTCA-1 3.00086772153123 21.485 Now lets plot the number of unique nuclear fragments (log10) by TSS enrichment. This type of plot is key in identifying high quality cells. We can further adjust our cutoffs based on this plot if need be. p &lt;- ggPoint( x = df[,1], y = df[,2], colorDensity = TRUE, continuousSet = &quot;sambaNight&quot;, xlabel = &quot;Log10 Unique Fragments&quot;, ylabel = &quot;TSS Enrichment&quot;, xlim = c(log10(500), quantile(df[,1], probs = 0.99)), ylim = c(0, quantile(df[,2], probs = 0.99)) ) + geom_hline(yintercept = 4, lty = &quot;dashed&quot;) + geom_vline(xintercept = 3, lty = &quot;dashed&quot;) p JJJ TSS-vs-Frags.png To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p, name = &quot;TSS-vs-Frags.pdf&quot;, ArchRProj = projHeme, addDOC = FALSE) "],
["plotting-sample-statistics-from-an-archrproject.html", "2.3 Plotting Sample Statistics from an ArchRProject", " 2.3 Plotting Sample Statistics from an ArchRProject Example 1. Make a Ridge Plot for each sample for the TSS Enrichment scores. p1 &lt;- plotGroups( ArchRProj = projHeme, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;ridges&quot; ) p1 Example 2. Make a Violin Plot for each sample for the TSS Enrichment scores. p2 &lt;- plotGroups( ArchRProj = projHeme, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;TSSEnrichment&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) p2 Example 3. Make a Ridge Plot for each sample for the log10 unique nuclear fragments. p3 &lt;- plotGroups( ArchRProj = projHeme, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;ridges&quot; ) p3 Example 4. Make a Violin Plot for each sample for the log10 unique nuclear fragments. p4 &lt;- plotGroups( ArchRProj = projHeme, groupBy = &quot;Sample&quot;, colorBy = &quot;cellColData&quot;, name = &quot;log10(nFrags)&quot;, plotAs = &quot;violin&quot;, alpha = 0.4, addBoxPlot = TRUE ) p4 To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2,p3,p4, name = &quot;QC-Sample-Statistics.pdf&quot;, ArchRProj = projHeme, addDOC = FALSE, width = 4, height = 4) "],
["plotting-sample-fragment-size-distribution-and-tss-enrichment-profiles-.html", "2.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles.", " 2.4 Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles. ArchR can compute fragment size distributions after ArrowFile creation for all samples swiftly. p1 &lt;- plotFragmentSizes(ArchRProj = projHeme) p1 ArchR can compute TSS enrichment profiles after ArrowFile creation for all samples swiftly. p2 &lt;- plotTSSEnrichment(ArchRProj = projHeme) p2 To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;QC-Sample-FragSizes-TSSProfile.pdf&quot;, ArchRProj = projHeme, addDOC = FALSE, width = 5, height = 5) "],
["filtering-doublets-from-an-archrproject.html", "2.5 Filtering Doublets from an ArchRProject", " 2.5 Filtering Doublets from an ArchRProject #Remove doublets as normal #If you feel there are more doublets try increasing filterRatio like below projHemeND &lt;- filterDoublets(projHeme) # Filtering 410 cells from ArchRProject! # scATAC_BMMC_R1 : 243 of 4932 (4.9%) # scATAC_CD34_BMMC_R1 : 107 of 3275 (3.3%) # scATAC_PBMC_R1 : 60 of 2454 (2.4%) #Lets see the project now projHemeND # class: ArchRProject # outputDirectory: /Volumes/JG_SSD_2/ArchR_Walkthrough/HemeTutorial # samples(3): scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # sampleColData names(1): ArrowFiles # cellColData names(11): DoubletEnrichment DoubletScore ... Sample # TSSEnrichment # numberOfCells(1): 10251 # medianTSS(1): 16.851 # medianFrags(1): 2994 If you want to filter more cells from the ArchR Project try a higher filterRatio. To see additional arguments try ?filterDoublets projHemeND2 &lt;- filterDoublets(projHeme, filterRatio = 1.5) # Filtering 614 cells from ArchRProject! # scATAC_BMMC_R1 : 364 of 4932 (7.4%) # scATAC_CD34_BMMC_R1 : 160 of 3275 (4.9%) # scATAC_PBMC_R1 : 90 of 2454 (3.7%) "],
["dimensionality-reduction-with-archr.html", "Chapter 3 Dimensionality Reduction with ArchR", " Chapter 3 Dimensionality Reduction with ArchR Dimensionality reduction with scATAC-seq is challenging due to the sparsity of the data. When we see multiple Tn5 insertions within a single peak it does not necessarily relate to that site being multiple times more accessible than a different site. For this reason a lot of analytical strategies work on a binary scATAC-seq data matrix. First, it is important to determine which regions to use for dimensionality reduction. The main two strategies have been using ATAC-seq peaks or larger kilobase scale tiles genome-wide. However, determining a peak set is a bit challenging because it changes with the number of samples in each experiment. This makes comparisons of multiple data sets extremely challenging. Another strategy is to use large kilobase scale tiles which is promising because it solves the multiple sample comparison challenge by using a predetermined feature set. However, most of the time this is performed on a 5kb+ sized tiles which are much larger (10x) than an accessible region. ArchR was designed to merge these methods by creating a 500-bp genome-wide feature set. The challenge is that this cell by tile matrix is around 6 million features which is too large to read into R for many cells. Therefore, ArchR is designed to compute dimensionality reduction on a subset of these features that are more biologically relevant. "],
["iterative-latent-semantic-indexing-lsi.html", "3.1 Iterative Latent Semantic Indexing (LSI)", " 3.1 Iterative Latent Semantic Indexing (LSI) Latent semantic indexing (LSI) was first introduced for scATAC-seq by Cusanovich et al (Science 2015) as a form for analyzing scATAC-seq data. LSI commonly refers to computing the term frequency (TF) and then normalization by the inverse document frequency (IDF) to get a normalized matrix (TF-IDF) and then Singular Value Decomposition (SVD). The term frequency is simply dividing depth normalization per single cell. The inverse document frequency refers to weighting each feature by how often it occurs to weight features that are more “specific” rather than commonly accessible. There are many different TF-IDF transformations with their own merits. ArchR has a few LSI implementations and we have tested out many of these methods across many different test data sets. The default LSI implementation is related to the one introduced by Timothy Stuart, which depth normalizes to a constant (10,000) followed by normalization with the inverse document frequency and then log-transforming the resultant matrix (log(TF-IDF)). In scRNA-seq identifying variable genes is a common way to compute dimensionality reduction (such as PCA). This is done becasue these genes are more likely to be biologically important and this reduces experimental noise. In scATAC-seq the data is binary and thus you cant identify variable peaks for dimensionality reduction. We have tried using the most accessible features instead, however the results when running multiple samples have had strong noise. To remedy this we introduced the iterative LSI approach (Satpathy+, Granja+ et al NBT 2019 and Granja+, Klemm+ and McGinnis+ et al NBT 2019). This approach computes an intial LSI transformation on the most accessible tiles and identifies lower resolution clusters that are not batch confounded (ie. in PBMCs just classifying T cells, B cells and Monocytes). Then ArchR computes the average accessibility for each of these clusters across all features creating “pseudobulks”. Then ArchR identifies the variable peaks across these “pseudobulks” and then use these features for LSI again as these peaks are more similar to scRNA-seq’s variable peaks. We have found this approach is very good for batch minimization and allows operations on a more reasonable sized matrix than a much larger sparse matrix. To do this we run addIterativeLSI with the default parameters which should cover most cases. See ?addIterativeLSI for more details on inputs. projHemeND &lt;- addIterativeLSI( ArchRProj = projHemeND, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) If you see downstream that you have subtle batch effects still another option is to add more LSI iterations and start from a lower intial clustering resolution as shown below. Additionally the number of variable features can be lowered to increase focus on the more variable features. projHemeND &lt;- addIterativeLSI( ArchRProj = projHemeND, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI2&quot;, iterations = 4, clusterParams = list( resolution = c(0.1, 0.2, 0.4), sampleCells = 10000, n.start = 10 ), varFeatures = 15000, dimsToUse = 1:30 ) Additionally ArchR allows for a normal LSI transformation with addLSI, however we recommend the iterative procedure. projHemeND &lt;- addLSI( ArchRProj = projHemeND, useMatrix = &quot;TileMatrix&quot;, name = &quot;LSI&quot;, topFeatures = 25000, dimsToUse = 1:30 ) Lastly, lets compute the iterativeLSI for the ArchRProject still containing doublets. projHeme &lt;- addIterativeLSI( ArchRProj = projHeme, useMatrix = &quot;TileMatrix&quot;, name = &quot;IterativeLSI&quot;, iterations = 2, clusterParams = list( resolution = c(0.2), sampleCells = 10000, n.start = 10 ), varFeatures = 25000, dimsToUse = 1:30 ) "],
["batch-effect-correction-wtih-harmony.html", "3.2 Batch Effect Correction wtih Harmony", " 3.2 Batch Effect Correction wtih Harmony Sometimes the iterative LSI approach isnt enough of a correction for strong batch effect differences. For this reason we added a commonly used batch effect correction tool Harmony for scRNA (https://github.com/immunogenomics/harmony). We wrote a wrapper that will pass a dimensionality reduction object from ArchR directly to HarmonyMatrix. Additional arguments can be directly passed to HarmonyMatrix in the function. See ?addHarmony for more details. projHemeND &lt;- addHarmony( ArchRProj = projHemeND, reducedDims = &quot;IterativeLSI&quot;, name = &quot;Harmony&quot;, groupBy = &quot;Sample&quot; ) "],
["clustering-with-archr.html", "Chapter 4 Clustering with ArchR", " Chapter 4 Clustering with ArchR Most single-cell clustering methods focus on computing nearest neighbor graphs in reduced dimensions and then identifying “communities” or clusters. These approaches work extremely well and are a standard practice in scRNA. For this reason, we import existing state of the art clustering methods from scRNA-seq packages for clustering. In our experience, we have had the most success using Seurat’s (https://github.com/satijalab/seurat) graph clustering approach. Additional clustering params can be passed to Seurat::FindClusters from this function. projHemeND &lt;- addClusters( input = projHemeND, reducedDims = &quot;IterativeLSI&quot;, method = &quot;Seurat&quot;, name = &quot;Clusters&quot;, resolution = 0.8 ) To access these clusters we can use the $ accessor head(projHemeND$Clusters) # [1] &quot;Cluster11&quot; &quot;Cluster2&quot; &quot;Cluster12&quot; &quot;Cluster1&quot; &quot;Cluster12&quot; &quot;Cluster8&quot; table(projHemeND$Clusters) # Cluster1 Cluster10 Cluster11 Cluster12 Cluster13 Cluster14 Cluster2 Cluster3 # 28 1070 425 351 408 345 1330 562 # Cluster4 Cluster5 Cluster6 Cluster7 Cluster8 Cluster9 # 901 860 1218 974 274 1505 We can also create a cluster confusion matrix across each sample. JJJ ArchR:::.confusionMatrix(paste0(projHemeND$Clusters), paste0(projHemeND$Sample)) # 14 x 3 sparse Matrix of class &quot;dgCMatrix&quot; # scATAC_BMMC_R1 scATAC_CD34_BMMC_R1 scATAC_PBMC_R1 # Cluster11 247 6 172 # Cluster2 1254 . 76 # Cluster12 351 . . # Cluster1 28 . . # Cluster8 247 27 . # Cluster4 315 . 586 # Cluster9 1456 5 44 # Cluster5 214 639 7 # Cluster7 83 887 4 # Cluster14 161 174 10 # Cluster3 52 . 510 # Cluster10 84 1 985 # Cluster6 117 1101 . # Cluster13 80 328 . Determining the appropriate cluster params is useful once you have computed a 2-dimensional embedding. This is because you should be adjusting both the clustering and embedding params to where they both agree. Additionally, one can call clusters with scran (https://bioconductor.org/packages/release/bioc/html/scran.html). projHemeND &lt;- addClusters( input = projHemeND, reducedDims = &quot;IterativeLSI&quot;, method = &quot;scran&quot;, name = &quot;ScranClusters&quot;, k = 25 ) "],
["single-cell-embeddings.html", "Chapter 5 Single Cell Embeddings ", " Chapter 5 Single Cell Embeddings "],
["umap.html", "5.1 UMAP", " 5.1 UMAP projHemeND &lt;- addUMAP( ArchRProj = projHemeND, reducedDims = &quot;IterativeLSI&quot;, name = &quot;UMAP&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) p1 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-UMAP-Sample-Clusters.pdf&quot;, ArchRProj = projHemeND, addDOC = FALSE, width = 5, height = 5) "],
["tsne.html", "5.2 tSNE", " 5.2 tSNE projHemeND &lt;- addTSNE( ArchRProj = projHemeND, reducedDims = &quot;IterativeLSI&quot;, name = &quot;TSNE&quot;, perplexity = 30 ) p1 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2, name = &quot;Plot-TSNE-Sample-Clusters.pdf&quot;, ArchRProj = projHemeND, addDOC = FALSE, width = 5, height = 5) "],
["umap-of-other-reduced-dimensions.html", "5.3 UMAP of other Reduced Dimensions", " 5.3 UMAP of other Reduced Dimensions projHemeND &lt;- addUMAP( ArchRProj = projHemeND, reducedDims = &quot;IterativeLSI2&quot;, name = &quot;UMAP2&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) p1 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAP2&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAP2&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) projHemeND &lt;- addUMAP( ArchRProj = projHemeND, reducedDims = &quot;Harmony&quot;, name = &quot;UMAPHarmony&quot;, nNeighbors = 30, minDist = 0.5, metric = &quot;cosine&quot; ) p3 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;UMAPHarmony&quot;) p4 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;UMAPHarmony&quot;) ggAlignPlots(p3, p4, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2,p3,p4, name = &quot;Plot-UMAP2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHemeND, addDOC = FALSE, width = 5, height = 5) "],
["tsne-of-other-reduced-dimensions.html", "5.4 tSNE of other Reduced Dimensions", " 5.4 tSNE of other Reduced Dimensions projHemeND &lt;- addTSNE( ArchRProj = projHemeND, reducedDims = &quot;IterativeLSI2&quot;, name = &quot;TSNE2&quot;, perplexity = 30 ) p1 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNE2&quot;) p2 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNE2&quot;) ggAlignPlots(p1, p2, type = &quot;h&quot;) projHemeND &lt;- addTSNE( ArchRProj = projHemeND, reducedDims = &quot;Harmony&quot;, name = &quot;TSNEHarmony&quot;, perplexity = 30 ) p3 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Sample&quot;, embedding = &quot;TSNEHarmony&quot;) p4 &lt;- plotEmbedding(ArchRProj = projHemeND, colorBy = &quot;cellColData&quot;, name = &quot;Clusters&quot;, embedding = &quot;TSNEHarmony&quot;) ggAlignPlots(p3, p4, type = &quot;h&quot;) To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(p1,p2,p3,p4, name = &quot;Plot-TSNE2Harmony-Sample-Clusters.pdf&quot;, ArchRProj = projHemeND, addDOC = FALSE, width = 5, height = 5) "],
["marker-genes-with-scatac.html", "Chapter 6 Marker Genes with scATAC ", " Chapter 6 Marker Genes with scATAC "],
["identification-of-marker-genes.html", "6.1 Identification of Marker Genes", " 6.1 Identification of Marker Genes Identify Marker Gene through Pairwise Test vs Bias-Matched Background markersGS &lt;- markerFeatures( ArchRProj = projHemeND, useMatrix = &quot;GeneScoreMatrix&quot;, groupBy = &quot;Clusters&quot;, bias = c(&quot;TSSEnrichment&quot;, &quot;log10(nFrags)&quot;), testMethod = &quot;wilcoxon&quot; ) markerList &lt;- getMarkers(markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;) markerList$Cluster4 # DataFrame with 210 rows and 6 columns # seqnames start name idx Log2FC # &lt;Rle&gt; &lt;array&gt; &lt;array&gt; &lt;array&gt; &lt;numeric&gt; # 14759 chr22 37545962 IL2RB 301 2.09731361787433 # 6856 chr14 99737822 BCL11B 595 1.42193213075962 # 13123 chr2 192038902 STAT4 1064 1.90075014141832 # 12597 chr2 87035519 CD8A 538 1.96747880033344 # 9299 chr17 34207377 CCL5 540 2.65385587389937 # ... ... ... ... ... ... # 1488 chr1 156182779 PMF1 1488 1.35708770978464 # 22735 chrX 101854276 ARMCX5-GPRASP2 518 1.59283344451927 # 19680 chr7 45144641 SNORA5C 318 1.27027443652085 # 1856 chr1 196659182 CFHR4 1856 1.92661384224492 # 17830 chr5 140739703 PCDHGB2 690 2.93899133419389 We can then plot this as a heatmap markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) heatmapGS &lt;- markerHeatmap( seMarker = markersGS, cutOff = &quot;FDR &lt;= 0.01 &amp; Log2FC &gt;= 1.25&quot;, labelMarkers = markerGenes, transpose = TRUE ) draw(heatmapGS, heatmap_legend_side = &quot;bot&quot;, annotation_legend_side = &quot;bot&quot;) We can then plot this plotPDF(heatmapGS, name = &quot;GeneScores-Marker-Heatmap&quot;, width = 9, height = 7, ArchRProj = projHemeND, addDOC = FALSE) "],
["marker-genes.html", "6.2 Marker Genes", " 6.2 Marker Genes markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotEmbedding( ArchRProj = projHemeND, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, quantCut = c(0.01, 0.95), imputeWeights = NULL ) To plot a specific gene try To plot all genes we can use cowplot To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-WO-Imputation.pdf&quot;, ArchRProj = projHemeND, addDOC = FALSE, width = 5, height = 5) "],
["marker-genes-with-imputation.html", "6.3 Marker Genes with Imputation", " 6.3 Marker Genes with Imputation projHemeND &lt;- addImputeWeights(projHemeND) markerGenes &lt;- c( &quot;CD34&quot;, #Early Progenitor &quot;GATA1&quot;, #Erythroid &quot;PAX5&quot;, &quot;MS4A1&quot;, #B-Cell Trajectory &quot;CD14&quot;, #Monocytes &quot;CD3D&quot;, &quot;CD8A&quot;, &quot;TBX21&quot;, &quot;IL7R&quot; #TCells ) p &lt;- plotEmbedding( ArchRProj = projHemeND, colorBy = &quot;GeneScoreMatrix&quot;, name = markerGenes, embedding = &quot;UMAP&quot;, imputeWeights = getImputeWeights(projHemeND) ) To plot a specific gene try To plot all genes we can use cowplot To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots nice looking. plotPDF(plotList = p, name = &quot;Plot-UMAP-Marker-Genes-W-Imputation.pdf&quot;, ArchRProj = projHemeND, addDOC = FALSE, width = 5, height = 5) "]
]
