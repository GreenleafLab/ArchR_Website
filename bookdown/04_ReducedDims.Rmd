# Dimensionality Reduction with ArchR

```{r, include=FALSE}
setwd("/Volumes/JG_SSD_2/ArchR_Walkthrough/")
#load("Save-ArchR-Walkthrough-Chapter1-Feb13.Rdata")
save.image("Save-ArchR-Walkthrough-Feb13-2130.Rdata")
```

Dimensionality reduction with scATAC-seq is challenging due to the sparsity of the data. When we see multiple Tn5 insertions within a single peak it does not necessarily relate to that site being multiple times more accessible than 
a different site. For this reason a lot of analytical strategies work on a binary scATAC-seq data matrix. First, it is important to determine which regions to use for dimensionality reduction. The main two strategies have been using ATAC-seq peaks or larger kilobase scale tiles genome-wide. However, determining a peak set is a bit challenging because it changes with the number of samples in each experiment. This makes comparisons of multiple data sets extremely challenging. Another strategy is to use large kilobase scale tiles which is promising because it solves the multiple sample comparison challenge by using a predetermined feature set. However, most of the time this is performed on a 5kb+ sized tiles which are much larger (10x) than an accessible region. ArchR was designed to merge these methods by creating a 500-bp genome-wide feature set. The challenge is that this cell by tile matrix is around 6 million features which is too large to read into R for many cells. Therefore, ArchR is designed to compute dimensionality reduction on a subset of these features that are more biologically relevant.

## Iterative Latent Semantic Indexing (LSI)

Latent semantic indexing (LSI) was first introduced for scATAC-seq by Cusanovich et al (Science 2015) as a form for analyzing scATAC-seq data. LSI commonly refers to computing the term frequency (TF) and then normalization by the inverse document frequency (IDF) to get a normalized matrix (TF-IDF) and then Singular Value Decomposition (SVD). The term frequency is simply dividing depth normalization per single cell. The inverse document frequency refers to weighting each feature by how often it occurs to weight features that are more "specific" rather than commonly accessible. There are many different TF-IDF transformations with their own merits. ArchR has a few LSI implementations and we have tested out many of these methods across many different test data sets. The default LSI implementation is related to the one introduced by Timothy Stuart, which depth normalizes to a constant (10,000) followed by normalization with the inverse document frequency and then log-transforming the resultant matrix (log(TF-IDF)). </br>

In scRNA-seq identifying variable genes is a common way to compute dimensionality reduction (such as PCA). This is done becasue these genes are more likely to be biologically important and this reduces experimental noise. In scATAC-seq the data is binary and thus you cant identify variable peaks for dimensionality reduction. We have tried using the most accessible features instead, however the results when running multiple samples have had strong noise. To remedy this we introduced the iterative LSI approach (Satpathy+, Granja+ et al NBT 2019 and Granja+, Klemm+ and McGinnis+ et al NBT 2019). This approach computes an intial LSI transformation on the most accessible tiles and identifies lower resolution clusters that are not batch confounded (ie. in PBMCs just classifying T cells, B cells and Monocytes). Then ArchR computes the average accessibility for each of these clusters across all features creating "pseudobulks". Then ArchR identifies the variable peaks across these "pseudobulks" and then use these features for LSI again as these peaks are more similar to scRNA-seq's variable peaks. We have found this approach is very good for batch minimization and allows operations on a more reasonable sized matrix than a much larger sparse matrix.

To do this we run `addIterativeLSI` with the default parameters which should cover most cases. See ?addIterativeLSI for more details on inputs.

```{r eval=FALSE}
projHeme2 <- addIterativeLSI(
	ArchRProj = projHeme2,
	useMatrix = "TileMatrix", 
	name = "IterativeLSI", 
    iterations = 2, 
    clusterParams = list(
    	resolution = c(0.2), 
        sampleCells = 10000, 
        n.start = 10
    ), 
    varFeatures = 25000, 
    dimsToUse = 1:30
)
```

If you see downstream that you have subtle batch effects still another option is to add more LSI iterations and start from a lower intial clustering resolution as shown below. Additionally the number of variable features can be lowered to increase focus on the more variable features. 

```{r eval=FALSE}
projHeme2 <- addIterativeLSI(
	ArchRProj = projHeme2,
	useMatrix = "TileMatrix", 
	name = "IterativeLSI2", 
    iterations = 4, 
    clusterParams = list(
    	resolution = c(0.1, 0.2, 0.4), 
        sampleCells = 10000, 
        n.start = 10
    ), 
    varFeatures = 15000, 
    dimsToUse = 1:30
)
```

Additionally ArchR allows for a normal LSI transformation with `addLSI`, however we recommend the iterative procedure.

```{r eval=FALSE}
projHeme2 <- addLSI(
	ArchRProj = projHeme2,
	useMatrix = "TileMatrix", 
	name = "LSI", 
    topFeatures = 25000, 
    dimsToUse = 1:30
)
```

Lastly, lets compute the iterativeLSI for the ArchRProject still containing doublets.

```{r eval=FALSE}
projHeme1 <- addIterativeLSI(
    ArchRProj = projHeme1,
    useMatrix = "TileMatrix", 
    name = "IterativeLSI", 
    iterations = 2, 
    clusterParams = list(
        resolution = c(0.2), 
        sampleCells = 10000, 
        n.start = 10
    ), 
    varFeatures = 25000, 
    dimsToUse = 1:30
)
```

## Batch Effect Correction wtih Harmony

Sometimes the iterative LSI approach isnt enough of a correction for strong batch effect differences. For this reason we added a commonly used batch effect correction tool Harmony for scRNA (https://github.com/immunogenomics/harmony). We wrote a wrapper that will pass a dimensionality reduction object from ArchR directly to `HarmonyMatrix`. Additional arguments can be directly passed to `HarmonyMatrix` in the function. See ?addHarmony for more details.

```{r eval=FALSE}
projHeme2 <- addHarmony(
	ArchRProj = projHeme2,
	reducedDims = "IterativeLSI",
	name = "Harmony",
	groupBy = "Sample"
)
```


