---
output:
  html_document:
    theme: yeti  # many options for theme, this one is my favorite.
params:
  threads: 20
  rdata: ""
  token: ""
  ref: ""
  out: ""
---

```{r, include=FALSE, eval=FALSE}
params2 <- params
unlockBinding("params", env = .GlobalEnv)
#load("Chapter-13-Footprints.Rdata")
load(params$rdata)
params <- params2
rm(params2)
devtools::install_github("GreenleafLab/ArchR", 
  auth_token = params$token, 
  ref = params$ref,
  repos = BiocManager::repositories(),
  dependencies = FALSE
)
library(ArchR)
fn <- unclass(lsf.str(envir = asNamespace("ArchR"), all = TRUE))
fn <- fn[!grepl("\\.", fn)]
fn <- fn[fn!="ArchRProj"]
for (i in seq_along(fn)){
    tryCatch({
        eval(parse(text = paste0(fn[i], "<-ArchR::", fn[i])))
    }, error = function(x) {
    })
}
addArchRThreads(threads = params$threads)
addArchRGenome("hg19")
# fn <- unclass(lsf.str(envir = asNamespace("ArchR"), all = TRUE))
# fn <- fn[fn!="ArchRProj"]
# for (i in seq_along(fn)) {
#     tryCatch({
#         eval(parse(text = paste0(fn[i], "<-ArchR:::", fn[i])))
#     }, error = function(x) {
#     })
# }
set.seed(1)
```

# Gene Scores and Marker Genes with ArchR

While ArchR is able to robustly call clusters, it is not possible to know _a priori_ which cell type is represented by each cluster. This task is often left to manual annotation because every application is different.

To do this cell type annotation, we use prior knowledge of cell type-specific marker genes and we estimate _gene activity scores_ for these genes. A gene activity score is essentially a prediction of how highly expressed a gene will be based on the accessibility of regulatory elements in the vicinity of the gene promoter.

Specifically, the 200-kb region centered on the given TSS is tiled into 1000-bp bins and the insertions per bin are counted. Each of these bins is then weighted proportional to the distance from the TSS because regulatory elements closer to the promoter are more likely to affect the promoter.

![](/images/GeneActivityScore_Schematic.png){width=500px}

These gene activity scores are calculated for each `ArrowFile` at the time of creation if the parameter `addGeneScoreMat` is set to `TRUE` (the default) or at any time by using the `addGeneScoreMatrix()` function. Once caluclated, individual cells of a UMAP projection can be colored by their gene activity scores to help with the identification of various cell types. For example, in the plot below from the tutorial, __QQQ__ cells are highlighted based on their gene activity scores for __QQQ__.

[INSERT UMAP GENE SCORE PLOT FROM PBMCs]

It is important to note that not all genes behave well with gene activity scores. In particular, genes that reside in very gene-dense areas can be problematic because the promoter accessibility of nearby genes contribute to their score and it is also not necessarily true that nearby regulatory elements will affect their expression. Thus, it is always best to sanity check all gene activity score analyses.

## Identification of Marker Genes

An alternative less-supervised method for elucidation of cluster-specifc biology is the identification of features that are highly specific to the given cell group (or a small number of cell groups). Here, a feature could be a single regulatory element or it could be a gene. ArchR does this using the `markerFeatures()` function which can take as input any matrix via the `useMatrix` parameter and it identifies features unique to the groups indicated by the `groupBy` parameter (default is "Clusters"). If the `useMatrix` parameter is set to "GeneScoreMatrix", then the function will identify the genes that appear to be uniquely active in each cell type. This provides an unbiased way of seeing which genes are predicted to be active in each cluster and can aid in cluster annotation.

As mentioned above, the same `markerFeatures()` function can be used with any matrix stored in the ArrowFiles to identify features that are specific to certain cell groups. This is accomplished via the `useMatrix` parameter. For example, `useMatrix = "TileMatrix"` would identify genomic regions that are highly specific to a certain cell group and `useMatrix = "PeakMatrix"` would identify peaks that are highly specific to a certain cell group.

### How does this happen?

This process of marker feature identification hinges on the selection of a group of bias-matched background cells for each cell group. Across all features, each cell group is compared to its own background group of cells to determine if the given cell group has significantly higher accessibility. Then, ArchR looks for features that are uniquely significantly accessible in a single cell group (or a small number of cell groups).

![](../../images/markerFeature_schematic.png){width=500px}

The selection of these background cell groups is critical to the success of this process and is performed across the multidimensional space provided by the user via the `bias` argument to `markerFeatures()`. For each cell in the cell group, ArchR finds the nearest neighbor cell across the provided multidimensional space that is not a member of the given cell group and adds it to the background group of cells. In this way, ArchR creates a group of bias-matched cells that is as similar as possible to the given cell group, thus enabling a more robust determination of significance even if the group of cells is small.

The way ArchR does this is by taking all of the dimensions provided via the `bias` parameter and quantile normalizing their values to distribute the variance of each dimension across the same relative scale. Taking a toy example, if the parameters `TSS` and `log10(Num Fragments)` were provided to `bias`, the pre-quantile normalized values might look like this:

![](../../images/background_preNorm.png){width=500px}

Here, the relative variance across the y-axis is very small compared to the variance across the x-axis. If we normalize these axes so that their values range from 0 to 1 instead, we make the relative variance much more equal. Importantly, we also change the nearest neighbors dramatically.

![](../../images/background_postNorm.png){width=500px}

ArchR normalizes all of the dimensions and uses euclidean distance in this normalized multidimensional space to find the nearest neighbors. Using real data from __QQQ__, this process can identify __QQQ__.


Identify Marker Gene through Pairwise Test vs Bias-Matched Background

```{r eval=FALSE}
markersGS <- getMarkerFeatures(
    ArchRProj = projHeme2, 
    useMatrix = "GeneScoreMatrix", 
    groupBy = "Clusters",
    bias = c("TSSEnrichment", "log10(nFrags)"),
    testMethod = "wilcoxon"
)
```
> \## ArchR logging to : ArchRLogs/ArchR-getMarkerFeatures-f4e4232fa80b-Date-2020-04-15_Time-10-04-48.log  
## If there is an issue, please report to github with logFile!  
## MatrixClass = Sparse.Double.Matrix  
## 2020-04-15 10:04:49 : Matching Known Biases, 0.009 mins elapsed. 
##   
## ###########  
## 2020-04-15 10:05:23 : Completed Pairwise Tests, 0.585 mins elapsed.  
## ###########  
## ArchR logging successful to : ArchRLogs/ArchR-getMarkerFeatures-f4e4232fa80b-Date-2020-04-15_Time-10-04-48.log  

```{r eval=FALSE}
markerList <- getMarkers(markersGS, cutOff = "FDR <= 0.01 & Log2FC >= 1.25")
markerList$C6
```
> \## DataFrame with 291 rows and 9 columns  
##       seqnames     start       end  strand         name     idx  
##          <Rle>   <array>   <array> <array>      <array> <array>  
## 8362     chr16  49891830  49524515       2       ZNF423     539  
## 7025     chr14 105714879 105717430       1        BTBD6     764  
## 8726     chr16  89043504  88941263       2      CBFA2T3     903  
## 7024     chr14 105781914 105675623       2         BRF1     763  
## 17158     chr5    997455    988425       2 LOC100506688      18  
## ...        ...       ...       ...     ...          ...     ...  
## 19084     chr6 119812467 119773712       2    LOC285762     925  
## 18913     chr6  83072923  83077133       1         TPBG     754  
## 12814     chr2 124782864 125672863       1      CNTNAP5     755  
## 20390     chr7 150147962 150176483       1       GIMAP8    1028  
## 7384     chr15  52569397  52569314       2      MIR1266     347  
##                 Log2FC                  FDR          MeanDiff  
##              <numeric>            <numeric>         <numeric>  
## 8362  1.94888141545084 2.95473053609015e-21  2.08129078745695  
## 7025  1.88748443360838 3.25360925877231e-15  2.29925343722754  
## 8726   1.5858058377813 3.25360925877231e-15  2.11727644857422  
## 7024  1.41061475820385 2.00400144783449e-14   1.9923490244715  
## 17158 3.16686924437513 2.00400144783449e-14 0.693424444489265  
## ...                ...                  ...               ...  
## 19084 1.36625245611966  0.00853516274073803 0.211727000065234  
## 18913 2.30499450627443  0.00854168013784213 0.544454051635953  
## 12814 2.28305835231306  0.00893526022954534  0.82240450922043  
## 20390 1.52933035478039  0.00910586862792073 0.516763460205267  
## 7384  2.16292224987129  0.00986664274558125  0.22839476831448  

We can then plot this as a heatmap

```{r eval=FALSE}
markerGenes  <- c(
    "CD34", #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "EBF1", "MME", #B-Cell Trajectory
    "CD14", "CEBPB", "MPO", #Monocytes
    "IRF8", 
    "CD3D", "CD8A", "TBX21", "IL7R" #TCells
  )

heatmapGS <- markerHeatmap(
  seMarker = markersGS, 
  cutOff = "FDR <= 0.01 & Log2FC >= 1.25", 
  labelMarkers = markerGenes,
  transpose = TRUE
)
```
> \## Printing Top Marker Genes:  
## C1:  
##  PADI4, PADI6, CDA, LINC01226, TMEM61, RPE65, PIN1P1, GNAT2, HSD3BP4, SRGAP2D, SNX27, THEM5, S100A8, FCAMR, UCN3, MIR604, MIR938, MIR4679-2, OR56B4, OR52B2  
## C2:  
##  HES4, FHAD1, PLA2G2C, CELA3A, RHD, FGR, MYCL, BTBD19, TCTEX1D4, SLC5A9, L1TD1, PALMD, FRRS1, GPR88, MYBPHL, CASQ2, NHLH2, SLC22A15, CTSS, S100A11  
## C3:  
##  PLEKHM2, MIR4422, CLCA3P, LOC729970, ALG14, TMEM56, SLC16A4, FCRL3, AIM2, SLAMF6, C1orf220, MIR4424, RALGPS2, RHEX, FCMR, BPNT1, KMO, LINC00700, ARID5B, MIR548AV  
## C4:  
##  LINC01342, LINC01346, SERINC2, RIMS3, SLFNL1-AS1, EDN2, ROR1, C1orf141, CACNA1S, KLHDC8A, SLC16A9, MIR346, GLYATL2, FAM111B, OR5AN1, RAB30-AS1, BTG4, TEAD4, CD9, PIANP  
## C5:  
##  LRRC38, FAM131C, PLA2G2D, LOC653160, TSPAN1, TTC39A, GBP1P1, LOC100129046, HAO2, RORC, S100A5, S100A4, ILDR2, FMO1, ANGPTL1, LAD1, TNNI1, VASH2, GJC2, KCNK1  
## C6:  
##  TTLL10, ATP13A2, PAX7, CSMD2, MIR3659, TRABD2B, ERICH3, ABCA4, NTNG1, LOR, FAM189B, UCK2, PHLDA3, LEMD1, SERTAD4-AS1, ESRRG, TRIM67, LOC149373, C1orf131, DEPP1  
## C7:  
##  TNFRSF4, RUNX3, LEXM, IL12RB2, VCAM1, CHIA, BCL2L15, CD160, PDZK1, SH2D2A, NTRK1, PYHIN1, SLAMF7, FCGR3A, CD247, LOC100505918, FASLG, GAS5-AS1, ATP6V1G3, GREM2  
## C8:  
##  RCAN3, HPCAL4, ANKRD13C, HHLA3, ZRANB2, PLPPR5, PRMT6, AMIGO1, CHI3L2, CD2, PTGFRN, ACP6, NIT1, NUF2, MIR557, IL19, MIR1265, ANKRD26, ZEB1, ZEB1-AS1  
## C9:  
##  ESPN, MIR4252, RCAN3AS, HOOK1, ZNF37BP, ZNF239, SLC10A1, TMEM202, RRN3P1, TP53TG3D, MT1F, ZNF286B, FOXO3B, TRIM16L, PEX12, LOC729966, PDCD2L, ZNF283, ZNF610, TLX2  
## C10:  
##  MIR4689, HES2, NPPA-AS1, MFN2, FBLIM1, KLHDC7A, RPS14P3, FAM43B, MIR378F, GRHL3, TRIM63, GJB3, GJA4, EPHA10, RHBDL2, PPIE, RIMKLA, FAM183A, LINC00853, PDZK1IP1  
## C11:  
##  NPPA, SFTA1P, WT1-AS, MIR4488, LRRC10B, CACNA1C-AS4, LOC728739, CCNA1, LPO, MPO, TTR, PRTN3, ELANE, OR10H2, NCAN, OXER1, INSM1, BPIFA1, EMILIN3, COL9A3  
## C12:  
##  LINC02593, VWA1, CHD5, TMEM51-AS1, MFAP2, PADI3, HSPG2, C1QB, MIR4253, KIAA1522, C1orf94, LINC01343, KNCN, DMRTB1, CDCP2, ACOT11, ASB17, CYR61, SLC6A17, LOC643441  
## Identified 2662 markers!  
## Adding Annotations..  
## Preparing Main Heatmap..  

```{r eval=FALSE}
draw(heatmapGS, heatmap_legend_side = "bot", annotation_legend_side = "bot")
```

```{r, include=FALSE, eval=FALSE}
plotPDF(heatmapGS, name = "GeneScores-Marker-Heatmap", width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/GeneScores-Marker-Heatmap_1.png){width=800 height=600}

We can then plot this to a pdf 

```{r eval=FALSE}
plotPDF(heatmapGS, name = "GeneScores-Marker-Heatmap", width = 8, height = 6, ArchRProj = projHeme2, addDOC = FALSE)
```
> \## [1] 0

[Download PDF : GeneScores-Marker-Heatmap.pdf](images/HemeWalkthrough/PDF/GeneScores-Marker-Heatmap.pdf)

## Marker Genes

```{r eval=FALSE}
markerGenes  <- c(
    "CD34",  #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "MME", #B-Cell Trajectory
    "CD14", "MPO", #Monocytes
    "CD3D", "CD8A"#TCells
  )

p <- plotEmbedding(
    ArchRProj = projHeme2, 
    colorBy = "GeneScoreMatrix", 
    name = markerGenes, 
    embedding = "UMAP",
    quantCut = c(0.01, 0.95),
    imputeWeights = NULL
)
```
> \## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f4e44c020f3e-Date-2020-04-15_Time-10-05-43.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = GeneScoreMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## Plotting Embedding  
## 1 2 3 4 5 6 7 8 9   
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f4e44c020f3e-Date-2020-04-15_Time-10-05-43.log  

To plot a specific gene try

```{r, eval=FALSE}
p$CD14
```
![](images/HemeWalkthrough/PNG/Plot-UMAP-Marker-Genes-WO-Imputation_6.png){width=800 height=800}

To plot all genes we can use cowplot

```{r, eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 3),p2)), 
    name = "Plot-UMAP-Markers-WO-Imputation.pdf", 
    ArchRProj = projHeme2,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-Markers-WO-Imputation_1.png){width=800 height=800}


To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots
nice looking.

```{r eval=FALSE}
plotPDF(plotList = p, 
    name = "Plot-UMAP-Marker-Genes-WO-Imputation.pdf", 
    ArchRProj = projHeme2, 
    addDOC = FALSE, width = 5, height = 5)
```
> \## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] 0  

[Download PDF : Plot-UMAP-Marker-Genes-WO-Imputation.pdf](images/HemeWalkthrough/PDF/Plot-UMAP-Marker-Genes-WO-Imputation.pdf)

## Marker Genes Imputation with Magic

```{r eval=FALSE}
projHeme2 <- addImputeWeights(projHeme2)
```
> \## 2020-04-15 10:06:25 : Computing Impute Weights Using Magic (Cell 2018), 0 mins elapsed.  
## 2020-04-15 10:06:36 : Completed Getting Magic Weights!, 0.19 mins elapsed.  

Now lets see how this effects our marker gene scores overlayed on our 2-d embedding.

```{r eval=FALSE}
markerGenes  <- c(
    "CD34",  #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "MME", #B-Cell Trajectory
    "CD14", "MPO", #Monocytes
    "CD3D", "CD8A"#TCells
  )

p <- plotEmbedding(
    ArchRProj = projHeme2, 
    colorBy = "GeneScoreMatrix", 
    name = markerGenes, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme2)
)
```
> \## Getting ImputeWeights  
## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-f4e41cd9b447-Date-2020-04-15_Time-10-06-36.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = GeneScoreMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## Imputing Matrix  
## Using weights on disk  
## Using weights on disk  
## Plotting Embedding  
## 1 2 3 4 5 6 7 8 9   
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-f4e41cd9b447-Date-2020-04-15_Time-10-06-36.log  

To plot a specific gene try

```{r, eval=FALSE}
p$CD14
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-Marker-Genes-W-Imputation_6.png){width=800 height=800}

To plot all genes we can use cowplot

```{r, eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 3),p2)), 
    name = "Plot-UMAP-Markers-W-Imputation.pdf", 
    ArchRProj = projHeme2,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-Markers-W-Imputation_1.png){width=800 height=800}

To save a nice looking pdf we use plotPDF which removes white pages and tries to make the plots
nice looking.

```{r eval=FALSE}
plotPDF(plotList = p, 
    name = "Plot-UMAP-Marker-Genes-W-Imputation.pdf", 
    ArchRProj = projHeme2, 
    addDOC = FALSE, width = 5, height = 5)
```
> \## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] "plotting ggplot!"  
## [1] 0  

[Download PDF : Plot-UMAP-Marker-Genes-W-Imputation.pdf](images/HemeWalkthrough/PDF/Plot-UMAP-Marker-Genes-W-Imputation.pdf)

## Track Plotting with ArchRBrowser

```{r eval=FALSE}
markerGenes  <- c(
    "CD34", #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", #B-Cell Trajectory
    "CD14", #Monocytes
    "CD3D", "CD8A", "TBX21", "IL7R" #TCells
  )

p <- ArchRBrowserTrack(
    ArchRProj = projHeme2, 
    groupBy = "Clusters", 
    geneSymbol = markerGenes, 
    upstream = 50000,
    downstream = 50000
)
```
> \## ArchR logging to : ArchRLogs/ArchR-ArchRBrowserTrack-f4e46f9da45e-Date-2020-04-15_Time-10-07-24.log  
## If there is an issue, please report to github with logFile!  
## 2020-04-15 10:07:24 : Validating Region, 0.006 mins elapsed.  
## GRanges object with 9 ranges and 2 metadata columns:   
##       seqnames              ranges strand |     gene_id      symbol  
##          <Rle>           <IRanges>  <Rle> | <character> <character>  
##   [1]     chr1 208059883-208084683      - |         947        CD34  
##   [2]     chrX   48644982-48652717      + |        2623       GATA1  
##   [3]     chr9   36838531-37034476      - |        5079        PAX5  
##   [4]    chr11   60223282-60238225      + |         931       MS4A1  
##   [5]     chr5 140011313-140013286      - |         929        CD14  
##   [6]    chr11 118209789-118213459      - |         915        CD3D  
##   [7]     chr2   87011728-87035519      - |         925        CD8A  
##   [8]    chr17   45810610-45823485      + |       30009       TBX21  
##   [9]     chr5   35856977-35879705      + |        3575        IL7R  
##   -------  
##   seqinfo: 24 sequences from hg19 genome  
## 2020-04-15 10:07:25 : Adding Bulk Tracks (1 of 9), 0.009 mins elapsed.  
## 2020-04-15 10:07:27 : Adding Gene Tracks (1 of 9), 0.044 mins elapsed.  
## 2020-04-15 10:07:27 : Plotting, 0.054 mins elapsed.  
## 2020-04-15 10:07:29 : Adding Bulk Tracks (2 of 9), 0.09 mins elapsed.  
## 2020-04-15 10:07:31 : Adding Gene Tracks (2 of 9), 0.108 mins elapsed.  
## 2020-04-15 10:07:31 : Plotting, 0.117 mins elapsed.  
## 2020-04-15 10:07:34 : Adding Bulk Tracks (3 of 9), 0.157 mins elapsed.  
## 2020-04-15 10:07:35 : Adding Gene Tracks (3 of 9), 0.175 mins elapsed.  
## 2020-04-15 10:07:35 : Plotting, 0.183 mins elapsed.  
## 2020-04-15 10:07:37 : Adding Bulk Tracks (4 of 9), 0.221 mins elapsed.  
## 2020-04-15 10:07:38 : Adding Gene Tracks (4 of 9), 0.239 mins elapsed.  
## 2020-04-15 10:07:39 : Plotting, 0.249 mins elapsed.  
## 2020-04-15 10:07:41 : Adding Bulk Tracks (5 of 9), 0.279 mins elapsed.  
## 2020-04-15 10:07:42 : Adding Gene Tracks (5 of 9), 0.295 mins elapsed.  
## 2020-04-15 10:07:42 : Plotting, 0.301 mins elapsed.  
## 2020-04-15 10:07:44 : Adding Bulk Tracks (6 of 9), 0.339 mins elapsed.  
## 2020-04-15 10:07:46 : Adding Gene Tracks (6 of 9), 0.358 mins elapsed.  
## 2020-04-15 10:07:46 : Plotting, 0.367 mins elapsed.  
## 2020-04-15 10:07:49 : Adding Bulk Tracks (7 of 9), 0.409 mins elapsed.  
## 2020-04-15 10:07:50 : Adding Gene Tracks (7 of 9), 0.429 mins elapsed.  
## 2020-04-15 10:07:50 : Plotting, 0.44 mins elapsed.  
## 2020-04-15 10:07:54 : Adding Bulk Tracks (8 of 9), 0.502 mins elapsed.  
## 2020-04-15 10:07:55 : Adding Gene Tracks (8 of 9), 0.52 mins elapsed.  
## 2020-04-15 10:07:56 : Plotting, 0.528 mins elapsed.  
## 2020-04-15 10:07:58 : Adding Bulk Tracks (9 of 9), 0.567 mins elapsed.  
## 2020-04-15 10:07:59 : Adding Gene Tracks (9 of 9), 0.585 mins elapsed.  
## 2020-04-15 10:08:00 : Plotting, 0.593 mins elapsed.  
## ArchR logging successful to : ArchRLogs/ArchR-ArchRBrowserTrack-f4e46f9da45e-Date-2020-04-15_Time-10-07-24.log  

To plot a track we can simply print one from the list

```{r eval=FALSE}
grid::grid.newpage()
grid::grid.draw(p$CD14)
```

```{r, include=FALSE, eval=FALSE}
plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes.pdf", 
    ArchRProj = projHeme2, 
    addDOC = FALSE, 
    width = 5, 
    height = 5
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-Tracks-Marker-Genes_5.png){width=500 height=500}

We can save pdfs with plotPDF

```{r eval=FALSE}
plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes.pdf", 
    ArchRProj = projHeme2, 
    addDOC = FALSE, width = 5, height = 5)
```
> \## NULL  
## NULL  
## NULL  
## NULL  
## NULL  
## NULL  
## NULL  
## NULL  
## NULL  
## [1] 0  

[Download PDF : Plot-Tracks-Marker-Genes.pdf](images/HemeWalkthrough/PDF/Plot-Tracks-Marker-Genes.pdf)


## Launching the ArchRBrowser

```{r eval=FALSE}
#ArchRBrowser(projHeme2)
```

![](images/HemeWalkthrough/PNG/ArchR_Browser_1.png){width=800 height=500}
![](images/HemeWalkthrough/PNG/ArchR_Browser_2.png){width=800 height=500}
![](images/HemeWalkthrough/PNG/ArchR_Browser_3.png){width=800 height=500}
![](images/HemeWalkthrough/PNG/ArchR_Browser_4.png){width=800 height=500}
![](images/HemeWalkthrough/PNG/ArchR_Browser_5.png){width=800 height=500}
![](images/HemeWalkthrough/PNG/ArchR_Browser_6.png){width=800 height=500}


```{r, include=FALSE, eval=FALSE}
save.image(params$out, compress = FALSE)
```















