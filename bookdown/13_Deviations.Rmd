---
output:
  html_document:
    theme: yeti  # many options for theme, this one is my favorite.
params:
  threads: 20
  rdata: ""
  token: ""
  ref: ""
  out: ""
---

```{r, include=FALSE, eval=FALSE}
params2 <- params
unlockBinding("params", env = .GlobalEnv)
#load("Chapter-13-Footprints.Rdata")
load(params$rdata)
params <- params2
rm(params2)
devtools::install_github("GreenleafLab/ArchR", 
  auth_token = params$token, 
  ref = params$ref,
  repos = BiocManager::repositories(),
  dependencies = FALSE
)
library(ArchR)
fn <- unclass(lsf.str(envir = asNamespace("ArchR"), all = TRUE))
fn <- fn[!grepl("\\.", fn)]
fn <- fn[fn!="ArchRProj"]
for (i in seq_along(fn)){
    tryCatch({
        eval(parse(text = paste0(fn[i], "<-ArchR::", fn[i])))
    }, error = function(x) {
    })
}
addArchRThreads(threads = params$threads)
addArchRGenome("hg19")
# fn <- unclass(lsf.str(envir = asNamespace("ArchR"), all = TRUE))
# fn <- fn[fn!="ArchRProj"]
# for (i in seq_along(fn)) {
#     tryCatch({
#         eval(parse(text = paste0(fn[i], "<-ArchR:::", fn[i])))
#     }, error = function(x) {
#     })
# }
set.seed(1)
```

# ChromVAR Deviatons Enrichment with ArchR

As shown in previous chapters, TF motif enrichments can help us predict which regulatory factors are most active in our cell type of interest. These enrichments, however, are not calculated on a per-cell basis and they do not take into account the insertion sequence bias of the Tn5 transposase. [chromVAR](https://greenleaflab.github.io/chromVAR/index.html), an R packaged from the Greenlead Lab, was created to account for these issues. chromVAR is designed for predicting enrichment of TF activity on a per-cell basis from sparse chromatin accessibility data. The two primary outputs of chromVAR are:

```{r include=FALSE, eval=FALSE,echo=FALSE}
# JJJ I would prefer to have more clear descriptions about deviations vs z scores for chromVAR. I've always found this very nuanced and it was never clear which metric should be used in which scenarios.
```

1. "deviations" - A deviation is a bias-corrected measurement of how far the per-cell accessibility of a given feature (i.e motif) deviates from the expected accessibility based on the average of all cells or samples.
2. "z-score" - The z-score, also known as a "deviation score" is the z-score for each bias-corrected deviation across all cells. The absolute value of the deviation score is correlated with the per-cell read depth. This is because, with more reads, you have higher confidence that the difference in per-cell accessibility of the given feature (i.e. motif) from the expectation is greater than would occur by chance.

One of the primary limitations of chromVAR is that it was designed during the early era of scATAC-seq data generation when an experiment consisted of a few hundred of cells. At this experimental scale, chromVAR could easily read the entire cell-by-peak matrix into memory to quickly compute TF deviations. However, current experimental approaches use tens to hundreds of thousands of cells, generating cell-by-peak matrices that are much more difficult to read into memory. This leads to dramatic increases in run time and memory usage for even moderately sized datasets of 50,000 cells.

To circumvent these limitations, ArchR implements the same chromVAR analysis workflow by analyzing sample sub-matrices independently.

<center>
![](images/ArchR_chromVAR_Parallelization){width=500px}
</center>

```{r include=FALSE, eval=FALSE,echo=FALSE}
# JJJ This description below is from the paper but could be improved. How does ArchR choose which cells go together in each of the sub samples?
```

First, ArchR reads in the global accessibility per peak across all cells in each sub-sample. Second, for each peak, ArchR identifies a set of background peaks that are matched by GC-content and accessibility. Third, ArchR uses this background set of peaks and global accessibility to compute bias-corrected deviations with chromVAR for each sample independently. This implementation requires data from only 5,000-10,000 cells to be loaded into memory at any given time, minimizing the memory requirements, enabling scalable analysis with chromVAR, and improving run-time performance.

## Motif Deviations

First, lets make sure we have added motif annotations to our `ArchRProject`.

```{r eval=FALSE}
if("Motif" %ni% names(projHeme5@peakAnnotation)){
    projHeme5 <- addMotifAnnotations(ArchRProj = projHeme5, motifSet = "cisbp", name = "Motif")
}
```

```{r include=FALSE, eval=FALSE,echo=FALSE}
# JJJ add a description of where the background peaks come from. I dont understand this. If you take the total peak set, are you trying to identify a subset of the those peaks that can be used as the background set? 
```

We also need to add a set of background peaks which are used in computing deviations. Background peaks are chosen using the `chromVAR::getBackgroundPeaks()` function which samples peaks based on similarity in GC-content and number of fragments across all samples using the Mahalanobis distance.

```{r eval=FALSE}
projHeme5 <- addBgdPeaks(projHeme5)
```
> \## Identifying Background Peaks!  
## No methods found in package 'IRanges' for request: 'score' when loading 'TFBSTools'

```{r include=FALSE, eval=FALSE,echo=FALSE}
# JJJ odd IRanges message above 
```

We are now ready to compute per-cell deviations accross all of our motif annotations using the `addDeviationsMatrix()` function. This function has an optional parameter called `matrixName` that allows us to define the name of the deviations matrix that will be stored in the Arrow files. If we do not provide a value to this parameter, as in the example below, this function creates a matrix name by adding the word "Matrix" to the name of the `peakAnnotation`. The example below creates a deviations matrix in each of our Arrow files called "MotifMatrix".

```{r eval=FALSE}
projHeme5 <- addDeviationsMatrix(
  ArchRProj = projHeme5, 
  peakAnnotation = "Motif",
  force = TRUE
)
```
> \## Using Previous Background Peaks!  
## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-103741bce39ff-Date-2020-04-15_Time-10-45-35.log  
## If there is an issue, please report to github with logFile!  
## NULL  
## 2020-04-15 10:45:40 : Batch Execution w/ safelapply!, 0 mins elapsed.  
## ###########  
## 2020-04-15 10:57:19 : Completed Computing Deviations!, 11.734 mins elapsed.  
## ###########  
## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-103741bce39ff-Date-2020-04-15_Time-10-45-35.log  

To access these deviations, we use the `getVarDeviations()` function. If we want this function to return a `ggplot` object, we set `plot = TRUE` otherwise, this function would return the `DataFrame` object. The `head` of that `DataFrame` object is displayed by default when the function is run.

```{r eval=FALSE}
plotVarDev <- getVarDeviations(projHeme5, name = "MotifMatrix", plot = TRUE)
```
> \## DataFrame with 6 rows and 6 columns  
##      seqnames     idx        name     combinedVars       combinedMeans  
##         <Rle> <array>     <array>        <numeric>           <numeric>  
## f388        z     388   GATA2_388 11.9292478607949  -0.034894792575792  
## f155        z     155   CEBPA_155 11.8070700579364  -0.174087405321135  
## f383        z     383   GATA1_383 11.8045825337775 -0.0378306234562619  
## f336        z     336    SPIB_336 11.3432739583017 -0.0819836042460723  
## f385        z     385   GATA5_385 10.8828679211543  -0.036867577013264  
## f651        z     651 SMARCC1_651 10.2885493109675  -0.131812047523969  
##           rank  
##      <integer>  
## f388         1  
## f155         2  
## f383         3  
## f336         4  
## f385         5  
## f651         6  

From the above snapshot of the `DataFrame`, you can see that the `seqnames` of the `MotifMatrix` are not chromosomes. Typically, in matrices like the `TileMatrix`, `PeakMatrix`, and `GeneScoreMatrix`, we store the chromosome information in `seqnames`. The `MotifMatrix` does not have any corresponding position information but, instead, stores both the "devations" and "z-scores" from chromVAR into the same matrix using two different seqnames - `deviations` and `z`. This becomes important later on if you try to use the `MotifMatrix` (which is of class `Sparse.Assays.Matrix`) in functions such as `getMarkerFeatures()`. In these types of operations, ArchR will expect you to subset `MotifMatrix` to one of the two `seqnames` (i.e. select either z-scores or deviations to perform calculations).

We can then plot these variable deviations.
```{r eval=FALSE}
plotVarDev
```
> \## Warning: Removed 1 rows containing missing values (geom_point).

```{r, include=FALSE, eval=FALSE}
plotPDF(plotVarDev, name = "Variable-Motif-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
ArchR:::.convertToPNG(ArchRProj = projHeme5)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Variable-Motif-Deviation-Scores_1.png){width=500 height=500}

To save an editable vectorized version of this plot, we use the `plotPDF()` function.

```{r eval=FALSE}
plotPDF(plotVarDev, name = "Variable-Motif-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
```
> \## [1] "plotting ggplot!"  
## Warning: Removed 1 rows containing missing values (geom_point).  
## Warning: Removed 1 rows containing missing values (geom_point).  
## [1] 0  

What if we want to extract a subset of motifs for downstream analysis? We can do this using the `getFeatures()` function. The `paste(motifs, collapse="|")` statement below creates a concatenated `or` statement that enables selection of all of the motifs.
```{r eval=FALSE}
motifs <- c("GATA1", "CEBPA", "EBF1", "IRF4", "TBX21", "PAX5")
markerMotifs <- getFeatures(projHeme5, select = paste(motifs, collapse="|"), useMatrix = "MotifMatrix")
markerMotifs
```
> \##  [1] "z:TBX21_780"          "z:PAX5_709"           "z:IRF4_632"          
##  [4] "z:GATA1_383"          "z:CEBPA_155"          "z:EBF1_67"           
##  [7] "z:SREBF1_22"          "deviations:TBX21_780" "deviations:PAX5_709"  
## [10] "deviations:IRF4_632"  "deviations:GATA1_383" "deviations:CEBPA_155"  
## [13] "deviations:EBF1_67"   "deviations:SREBF1_22"  

As mentioned above, `MotifMatrix` contains `seqnames` for both z-scores and deviations, shown above by "z:" and "deviations:". To get just the features corresponding to z-scores, we can use `grep`. Unfortunately, in the example motifs shown above, you can see that in addition to "EBF1", we also selected "SREBF1" which we do not want to analyze. Because of this, we remove it below using the `%ni%` expression which is an ArchR helper function that provides the opposite of `%in%` from base R.

```{r eval=FALSE}
markerMotifs <- grep("z:", markerMotifs, value = TRUE)
markerMotifs <- markerMotifs[markerMotifs %ni% "z:SREBF1_22"]
markerMotifs
```
> \## [1] "z:TBX21_780" "z:PAX5_709"  "z:IRF4_632"  "z:GATA1_383" "z:CEBPA_155"  
## [6] "z:EBF1_67"


Now that we have the names of the features that we are interested in, we can plot the distribution of chromVAR deviation scores for each cluster. Notice that we supply the impute weights that we calculated previously during our gene score analyses. As a reminder, these impute weights allow us to smooth the signal across nearby cells which is helpful in the context of our sparse scATAC-seq data.

```{r eval=FALSE}
p <- plotGroups(ArchRProj = projHeme5, 
  groupBy = "Clusters2", 
  colorBy = "MotifMatrix", 
  name = markerMotifs,
  imputeWeights = getImputeWeights(projHeme5)
)
```
> \## Getting ImputeWeights  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## ArchR logging to : ArchRLogs/ArchR-imputeMatrix-103746efc5207-Date-2020-04-15_Time-10-57-40.log  
## If there is an issue, please report to github with logFile!  
## Using weights on disk  
## Using weights on disk  
## 1 2 3 4 5 6  

We can use `cowplot` to plot the distributions of all of these motifs in a single plot.

```{r, eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(seq_along(p), function(x){
  if(x != 1){
    p[[x]] + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6) +
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) +
    theme(
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank()
    ) + ylab("")
  }else{
    p[[x]] + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6) +
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) +
    theme(
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank()
    ) + ylab("")
  }
})
do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2, rep(1, length(p2) - 1))),p2))
```
> \## Picking joint bandwidth of 0.0181  
## Picking joint bandwidth of 0.02  
## Picking joint bandwidth of 0.07  
## Picking joint bandwidth of 0.109  
## Picking joint bandwidth of 0.102  
## Picking joint bandwidth of 0.0703  

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2.1, rep(1, length(p2) - 1))),p2)), 
    name = "Plot-Groups-Deviations-w-Imputation-Cowplot.pdf", 
    ArchRProj = projHeme5,
    addDOC = FALSE,
    width = 6, 
    height = 6
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-Groups-Deviations-w-Imputation-Cowplot_1.png){width=800 height=800}

To save an editable vectorized version of this plot, we use the `plotPDF()` function.

```{r eval=FALSE}
plotPDF(p, name = "Plot-Groups-Deviations-w-Imputation", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
```
> \## [1] "plotting ggplot!"  
## Picking joint bandwidth of 0.0181  
## Picking joint bandwidth of 0.0181  
## [1] "plotting ggplot!"  
## Picking joint bandwidth of 0.02  
## Picking joint bandwidth of 0.02  
## [1] "plotting ggplot!"  
## Picking joint bandwidth of 0.07  
## Picking joint bandwidth of 0.07  
## [1] "plotting ggplot!"  
## Picking joint bandwidth of 0.109  
## Picking joint bandwidth of 0.109  
## [1] "plotting ggplot!"  
## Picking joint bandwidth of 0.102  
## Picking joint bandwidth of 0.102  
## [1] "plotting ggplot!"  
## Picking joint bandwidth of 0.0703  
## Picking joint bandwidth of 0.0703  
## [1] 0  

Instead of looking at the distributions of these z-scores, we can overlay the z-scores on our UMAP embedding as we've done previously for gene scores.
```{r eval=FALSE}
p <- plotEmbedding(
    ArchRProj = projHeme5, 
    colorBy = "MotifMatrix", 
    name = sort(markerMotifs), 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme5)
)
```
> \## Getting ImputeWeights  
## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374bec190f-Date-2020-04-15_Time-10-58-03.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = MotifMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## Imputing Matrix    
## Using weights on disk  
## Using weights on disk  
## Plotting Embedding  
## 1 2 3 4 5 6   
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374bec190f-Date-2020-04-15_Time-10-58-03.log  

We can plot all of these motif UMAPs using `cowplot`.

```{r, eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 3),p2)), 
    name = "Plot-UMAP-MarkerMotifs-W-Imputation.pdf", 
    ArchRProj = projHeme5,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-MarkerMotifs-W-Imputation_1.png){width=800 height=800}


```{r include=FALSE, eval=FALSE,echo=FALSE}
#JJJ This has two sections that say "gene expression" and use "markerRNA" but one is for gene score and the other for RNA
```

To see how these TF deviation z-scores compare to the inferred gene expression via gene scores of the corresponding TF genes, we can overlay the gene scores for each of these TFs on the UMAP embedding.

```{r eval=FALSE}
markerRNA <- getFeatures(projHeme5, select = paste(motifs, collapse="|"), useMatrix = "GeneScoreMatrix")
markerRNA <- markerRNA[markerRNA %ni% c("SREBF1","CEBPA-DT")]
markerRNA
```
> \## [1] "TBX21" "CEBPA" "EBF1"  "IRF4"  "PAX5"  "GATA1"

```{r eval=FALSE}
p <- plotEmbedding(
    ArchRProj = projHeme5, 
    colorBy = "GeneScoreMatrix", 
    name = sort(markerRNA), 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme5)
)
```
> \## Getting ImputeWeights  
## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-1037475e6dc52-Date-2020-04-15_Time-10-58-30.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = GeneScoreMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## Imputing Matrix   
## Using weights on disk  
## Using weights on disk  
## Plotting Embedding  
## 1 2 3 4 5 6   
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-1037475e6dc52-Date-2020-04-15_Time-10-58-30.log  

```{r eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))

```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 3),p2)), 
    name = "Plot-UMAP-MarkerMotifsGS-W-Imputation.pdf", 
    ArchRProj = projHeme5,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-MarkerMotifsGS-W-Imputation_1.png){width=800 height=800}


Similarly, because we previously linked our scATAC-seq data with corresponding scRNA-seq data, we can plot the linked gene expression for each of these TFs on the UMAP embedding.

```{r eval=FALSE}
markerRNA <- getFeatures(projHeme5, select = paste(motifs, collapse="|"), useMatrix = "GeneIntegrationMatrix")
markerRNA <- markerRNA[markerRNA %ni% c("SREBF1","CEBPA-DT")]
markerRNA
```
> \## [1] "TBX21" "CEBPA" "EBF1"  "IRF4"  "PAX5"  "GATA1"

```{r eval=FALSE}

p <- plotEmbedding(
    ArchRProj = projHeme5, 
    colorBy = "GeneIntegrationMatrix", 
    name = sort(markerRNA), 
    embedding = "UMAP",
    continuousSet = "blueYellow",
    imputeWeights = getImputeWeights(projHeme5)
)
```
> \## Getting ImputeWeights  
## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374438d3144-Date-2020-04-15_Time-10-58-56.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = GeneIntegrationMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## Imputing Matrix  
## Using weights on disk  
## Using weights on disk  
## Plotting Embedding  
## 1 2 3 4 5 6   
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374438d3144-Date-2020-04-15_Time-10-58-56.log  

```{r eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))

```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 3),p2)), 
    name = "Plot-UMAP-MarkerMotifsRNA-W-Imputation.pdf", 
    ArchRProj = projHeme5,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-MarkerMotifsRNA-W-Imputation_1.png){width=800 height=800}

## ArchR and Custom Deviations

In the chapter on Peak Annotation Enrichment, we introduced how to create peak annotations for any set of genomic regions. This encluded (i) ArchR-supported region sets such as curated TF binding sites from ENCODE and peak sets from bulk ATAC-seq and (ii) custom user-supplied region sets. If you have not read this section, we recommend doing so to better understand how peak annotations work.

These peak annotations can be used in deviation calculations in the same way as motifs. Here we provide examples of how to run these analyses but note that the downstream analyses are identical to what was shown in the previous section for motifs and thus we do not provide extensive details on each step of the code. Once you create a deviations matrix in your Arrow files, the rest is the same.

### Encode TFBS

In case you have not added an annotations matrix for the "EncodeTFBS" region set, lets do that now.

```{r eval=FALSE}
if("EncodeTFBS" %ni% names(projHeme5@peakAnnotation)){
    projHeme5 <- addArchRAnnotations(ArchRProj = projHeme5, collection = "EncodeTFBS")
}
```

Then, we create a deviations matrix, providing this peak annotation to the `peakAnnotation` parameter.

```{r eval=FALSE}
projHeme5 <- addDeviationsMatrix(
  ArchRProj = projHeme5, 
  peakAnnotation = "EncodeTFBS",
  force = TRUE
)
```
> \## Using Previous Background Peaks!  
## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-10374737762a7-Date-2020-04-15_Time-10-59-20.log  
## If there is an issue, please report to github with logFile!  
## NULL  
## 2020-04-15 10:59:26 : Batch Execution w/ safelapply!, 0 mins elapsed.  
## ###########  
## 2020-04-15 11:08:11 : Completed Computing Deviations!, 8.864 mins elapsed.  
## ###########  
## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-10374737762a7-Date-2020-04-15_Time-10-59-20.log  

We can create a dot plot of the ranked deviations.
```{r eval=FALSE}
plotVarDev <- getVarDeviations(projHeme5, plot = TRUE, name = "EncodeTFBSMatrix")
```
> \## DataFrame with 6 rows and 6 columns  
##      seqnames     idx                    name     combinedVars  
##         <Rle> <array>                 <array>        <numeric>  
## f222        z     222     222.GATA2_S-K562... 13.6382687713858  
## f41         z      41      41.EZH2_39-NHEK... 12.9150554355261  
## f542        z     542     542.TAL1_SC-K562... 11.5490744327685   
## f584        z     584 584.GATA_1-PBDEFetal... 10.7653053700024  
## f498        z     498      498.GATA_2-K562... 10.2384173319845  
## f44         z      44      44.EZH2_39-NHLF... 9.92292044310219  
##             combinedMeans      rank  
##                 <numeric> <integer>  
## f222  -0.0312421757573656         1  
## f41     0.113221166775704         2  
## f542  -0.0155915927183644         3  
## f584 -0.00997025022971285         4  
## f498  -0.0317577572129743         5  
## f44    0.0707460230932926         6  

```{r eval=FALSE}
plotVarDev
```
> \## Warning: Removed 7 rows containing missing values (geom_point).

```{r, include=FALSE, eval=FALSE}
plotPDF(plotVarDev, name = "Variable-EncodeTFBS-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Variable-EncodeTFBS-Deviation-Scores_1.png){width=500 height=500}

```{r eval=FALSE}
plotPDF(plotVarDev, name = "Variable-EncodeTFBS-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
```
> \## [1] "plotting ggplot!"  
## Warning: Removed 7 rows containing missing values (geom_point).  
## Warning: Removed 7 rows containing missing values (geom_point).  
## [1] 0  

Or we can subset these TF binding sites to particular motifs we are interested in and then plot their deviation z-scores per-cell on our UMAP embedding.

```{r eval=FALSE}
tfs <- c("GATA_1", "CEBPB", "EBF1", "IRF4", "TBX21", "PAX5")
getFeatures(projHeme5, select = paste(tfs, collapse="|"), useMatrix = "EncodeTFBSMatrix")
```
> \##  [1] "z:584.GATA_1-PBDEFetal..."          "z:582.GATA_1-PBDE..."               
##  [3] "z:497.GATA_1-K562..."               "z:477.CEBPB-K562..."               
##  [5] "z:462.CEBPB-IMR90..."               "z:427.CEBPB-HepG2..."              
##  [7] "z:426.CEBPB-HepG2..."               "z:379.CEBPB-HeLa_S3..."            
##  [9] "z:344.CEBPB-H1_hESC..."             "z:293.EBF1_SC-GM12878..."          
## [11] "z:278.CEBPB-A549..."                "z:213.CEBPB_S-K562..."             
## [13] "z:173.CEBPB_S-HepG2..."             "z:130.PAX5_C2-GM12892..."          
## [15] "z:123.PAX5_C2-GM12891..."           "z:102.PAX5_N1-GM12878..."          
## [17] "z:101.PAX5_C2-GM12878..."           "z:93.IRF4_SC-GM12878..."           
## [19] "z:87.EBF1_SC-GM12878..."            "z:86.CEBPB_S-GM12878..."           
## [21] "deviations:584.GATA_1-PBDEFetal..." "deviations:582.GATA_1-PBDE..."     
## [23] "deviations:497.GATA_1-K562..."      "deviations:477.CEBPB-K562..."      
## [25] "deviations:462.CEBPB-IMR90..."      "deviations:427.CEBPB-HepG2..."     
## [27] "deviations:426.CEBPB-HepG2..."      "deviations:379.CEBPB-HeLa_S3..."   
## [29] "deviations:344.CEBPB-H1_hESC..."    "deviations:293.EBF1_SC-GM12878..."  
## [31] "deviations:278.CEBPB-A549..."       "deviations:213.CEBPB_S-K562..."    
## [33] "deviations:173.CEBPB_S-HepG2..."    "deviations:130.PAX5_C2-GM12892..."  
## [35] "deviations:123.PAX5_C2-GM12891..."  "deviations:102.PAX5_N1-GM12878..."  
## [37] "deviations:101.PAX5_C2-GM12878..."  "deviations:93.IRF4_SC-GM12878..."   
## [39] "deviations:87.EBF1_SC-GM12878..."   "deviations:86.CEBPB_S-GM12878..."  

```{r eval=FALSE}
markerTFs <- getFeatures(projHeme5, select = paste(tfs, collapse="|"), useMatrix = "EncodeTFBSMatrix")
markerTFs <- sort(grep("z:", markerTFs, value = TRUE))
TFnames <- stringr::str_split(stringr::str_split(markerTFs, pattern = "\\.", simplify=TRUE)[,2], pattern = "-", simplify = TRUE)[,1]
markerTFs <- markerTFs[!duplicated(TFnames)]
markerTFs
```
> \## [1] "z:101.PAX5_C2-GM12878..." "z:102.PAX5_N1-GM12878..."  
## [3] "z:173.CEBPB_S-HepG2..."   "z:278.CEBPB-A549..."     
## [5] "z:293.EBF1_SC-GM12878..." "z:497.GATA_1-K562..."     
## [7] "z:93.IRF4_SC-GM12878..."  

```{r eval=FALSE}
p <- plotEmbedding(
    ArchRProj = projHeme5, 
    colorBy = "EncodeTFBSMatrix", 
    name = markerTFs, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme5)
)
```
> \## Getting ImputeWeights  
## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-103747b681a1c-Date-2020-04-15_Time-11-08-26.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = EncodeTFBSMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## Imputing Matrix  
## Using weights on disk  
## Using weights on disk  
## Plotting Embedding  
## 1 2 3 4 5 6 7  
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-103747b681a1c-Date-2020-04-15_Time-11-08-26.log  

```{r, eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 3),p2)), 
    name = "Plot-UMAP-EncodeTFBS-W-Imputation.pdf", 
    ArchRProj = projHeme5,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-EncodeTFBS-W-Imputation_1.png){width=800 height=800}

### Bulk ATAC-seq

Similarly, we can use ArchR-curated bulk ATAC-seq peak sets for our motif deviation calculations.If you have not added motif annotations

In case you have not added an annotations matrix for the "EncodeTFBS" region set, lets do that now.

```{r eval=FALSE}
if("ATAC" %ni% names(projHeme5@peakAnnotation)){
    projHeme5 <- addArchRAnnotations(ArchRProj = projHeme5, collection = "ATAC")
}
```

Then, we create a deviations matrix, providing this peak annotation to the `peakAnnotation` parameter.

```{r eval=FALSE}
projHeme5 <- addDeviationsMatrix(
  ArchRProj = projHeme5, 
  peakAnnotation = "ATAC",
  force = TRUE
)
```
> \## Using Previous Background Peaks!  
## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-103743481be2a-Date-2020-04-15_Time-11-09-46.log  
## If there is an issue, please report to github with logFile!  
## NULL  
## 2020-04-15 11:09:52 : Batch Execution w/ safelapply!, 0 mins elapsed.  
## ###########  
## 2020-04-15 11:13:09 : Completed Computing Deviations!, 3.376 mins elapsed.  
## ###########  
## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-103743481be2a-Date-2020-04-15_Time-11-09-46.log  

We can create a dot plot of the ranked deviations.

```{r eval=FALSE}
plotVarDev <- getVarDeviations(projHeme5, plot = TRUE, name = "ATACMatrix")
```
> \## DataFrame with 6 rows and 6 columns  
##     seqnames     idx                  name     combinedVars       combinedMeans  
##        <Rle> <array>               <array>        <numeric>           <numeric>  
## f22        z      22 IAtlas_T_CD8posCenMem 12.8413703976471 -0.0972946574781075  
## f86        z      86              Heme_CD8 12.5070480860108  -0.079462324469343  
## f85        z      85              Heme_CD4 12.2753260246254 -0.0561621531675016  
## f23        z      23 IAtlas_T_CD8posEffMem 12.2250185804317  -0.104389732164243  
## f21        z      21       IAtlas_T_CD8pos 12.1998071900673   -0.09178088897301  
## f33        z      33 IAtlas_T_Th1Precursor 12.1352640996498 -0.0819315630754632  
##          rank  
##     <integer>  
## f22         1  
## f86         2  
## f85         3  
## f23         4  
## f21         5  
## f33         6  

```{r eval=FALSE}
plotVarDev
```

```{r, include=FALSE, eval=FALSE}
plotPDF(plotVarDev, name = "Variable-ATAC-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Variable-ATAC-Deviation-Scores_1.png){width=500 height=500}

```{r eval=FALSE}
plotPDF(plotVarDev, name = "Variable-ATAC-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
```
> \## [1] "plotting ggplot!"  
## [1] 0

Or we can plot the deviation z-scores for each of these peak sets per-cell on our UMAP embedding.

```{r eval=FALSE}
ATACPeaks <- c("Heme_HSC", "Heme_LMPP", "Heme_Ery", "Heme_Mono", "Heme_CD4", "Heme_CD8", "Heme_B", "Heme_NK", "IAtlas_DC_Plasmacytoid")
getFeatures(projHeme5, select = paste(ATACPeaks, collapse="|"), useMatrix = "ATACMatrix")
```
> \##  [1] "z:Heme_NK"                         "z:Heme_Mono"                      
##  [3] "z:Heme_LMPP"                       "z:Heme_HSC"                       
##  [5] "z:Heme_Ery"                        "z:Heme_CD8"                       
##  [7] "z:Heme_CD4"                        "z:Heme_B"                         
##  [9] "z:IAtlas_DC_Plasmacytoid"          "deviations:Heme_NK"               
## [11] "deviations:Heme_Mono"              "deviations:Heme_LMPP"             
## [13] "deviations:Heme_HSC"               "deviations:Heme_Ery"              
## [15] "deviations:Heme_CD8"               "deviations:Heme_CD4"              
## [17] "deviations:Heme_B"                 "deviations:IAtlas_DC_Plasmacytoid"  

```{r eval=FALSE}
markerATAC <- getFeatures(projHeme5, select = paste(ATACPeaks, collapse="|"), useMatrix = "ATACMatrix")
markerATAC <- sort(grep("z:", markerATAC, value = TRUE))
markerATAC
```
> \## [1] "z:Heme_B"                 "z:Heme_CD4"              
## [3] "z:Heme_CD8"               "z:Heme_Ery"              
## [5] "z:Heme_HSC"               "z:Heme_LMPP"             
## [7] "z:Heme_Mono"              "z:Heme_NK"               
## [9] "z:IAtlas_DC_Plasmacytoid"  

```{r eval=FALSE}
p <- plotEmbedding(
    ArchRProj = projHeme5, 
    colorBy = "ATACMatrix", 
    name = markerATAC, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme5)
)
```
> \## Getting ImputeWeights  
## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-1037416f3cb56-Date-2020-04-15_Time-11-13-23.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = ATACMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##  
## Imputing Matrix  
## Using weights on disk  
## Using weights on disk  
## Plotting Embedding  
## 1 2 3 4 5 6 7 8 9   
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-1037416f3cb56-Date-2020-04-15_Time-11-13-23.log  

```{r, eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 3),p2)), 
    name = "Plot-UMAP-MarkerATAC-W-Imputation.pdf", 
    ArchRProj = projHeme5,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-MarkerATAC-W-Imputation_1.png){width=800 height=800}

### Custom Deviations

Instead of using the ArchR-curated region sets described above, we can provide our own custom region sets as a peak annotation. These custom annotations can be used in exactly the same way as the ArchR-curated annotations.

First, in case you haven't already created this "EncodePeaks" annotation in a previous chapter, lets create it by downloading some ENCODE peak sets and calling `addPeakAnnotations()`.
```{r eval=FALSE}
#Custom Peak Annotations
EncodePeaks <- c(
  Encode_K562_GATA1 = "https://www.encodeproject.org/files/ENCFF632NQI/@@download/ENCFF632NQI.bed.gz",
  Encode_GM12878_CEBPB = "https://www.encodeproject.org/files/ENCFF761MGJ/@@download/ENCFF761MGJ.bed.gz",
  Encode_K562_Ebf1 = "https://www.encodeproject.org/files/ENCFF868VSY/@@download/ENCFF868VSY.bed.gz",
  Encode_K562_Pax5 = "https://www.encodeproject.org/files/ENCFF339KUO/@@download/ENCFF339KUO.bed.gz"
)
if("ChIP" %ni% names(projHeme5@peakAnnotation)){
    projHeme5 <- addPeakAnnotations(ArchRProj = projHeme5, regions = EncodePeaks, name = "ChIP")
}
```

Then, we make a deviations matrix from this peak annotation.
```{r eval=FALSE}
projHeme5 <- addDeviationsMatrix(
  ArchRProj = projHeme5, 
  peakAnnotation = "ChIP",
  force = TRUE
)
```
> \## Using Previous Background Peaks!  
## ArchR logging to : ArchRLogs/ArchR-addDeviationsMatrix-10374246a529b-Date-2020-04-15_Time-11-13-54.log  
## If there is an issue, please report to github with logFile!  
## NULL  
## 2020-04-15 11:13:59 : Batch Execution w/ safelapply!, 0 mins elapsed.  
## ###########  
## 2020-04-15 11:14:24 : Completed Computing Deviations!, 0.505 mins elapsed.  
## ###########  
## ArchR logging successful to : ArchRLogs/ArchR-addDeviationsMatrix-10374246a529b-Date-2020-04-15_Time-11-13-54.log  

The rest of the analysis workflow is the same as what has now been presented multiple times above.

We can plot the ranked deviations.
```{r eval=FALSE}
plotVarDev <- getVarDeviations(projHeme5, plot = TRUE, name = "ChIPMatrix")
```
> \## DataFrame with 4 rows and 6 columns  
##    seqnames     idx                 name      combinedVars        combinedMeans  
##       <Rle> <array>              <array>         <numeric>            <numeric>  
## f1        z       1    Encode_K562_GATA1  6.33176528990239  -0.0165812177586936  
## f3        z       3     Encode_K562_Ebf1  3.41531511621115   0.0355188580388895  
## f4        z       4     Encode_K562_Pax5  3.24513143947069 -0.00960057929930531  
## f2        z       2 Encode_GM12878_CEBPB 0.822128491900276  0.00742820197777246  
##         rank  
##    <integer>  
## f1         1  
## f3         2  
## f4         3  
## f2         4  

```{r eval=FALSE}
plotVarDev
```
> \## Warning: Removed 21 rows containing missing values (geom_label_repel).

```{r, include=FALSE, eval=FALSE}
plotPDF(plotVarDev, name = "Variable-ChIP-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Variable-ATAC-Deviation-Scores_1.png){width=500 height=500}

```{r eval=FALSE}
plotPDF(plotVarDev, name = "Variable-ChIP-Deviation-Scores", width = 5, height = 5, ArchRProj = projHeme5, addDOC = FALSE)
```
> \## [1] "plotting ggplot!"  
## Warning: Removed 21 rows containing missing values (geom_label_repel).  
## Warning: Removed 21 rows containing missing values (geom_label_repel).  
## [1] 0

And we can plot the deviation z-scores overlayed on our UMAP embedding.

```{r eval=FALSE}
markerChIP <- getFeatures(projHeme5, useMatrix = "ChIPMatrix")
markerChIP <- sort(grep("z:", markerChIP, value = TRUE))
markerChIP
```
> \## [1] "z:Encode_GM12878_CEBPB" "z:Encode_K562_Ebf1"     "z:Encode_K562_GATA1"    
## [4] "z:Encode_K562_Pax5"

```{r eval=FALSE}
p <- plotEmbedding(
    ArchRProj = projHeme5, 
    colorBy = "ChIPMatrix", 
    name = markerChIP, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(projHeme5)
)
```
> \## Getting ImputeWeights  
## ArchR logging to : ArchRLogs/ArchR-plotEmbedding-10374635d5970-Date-2020-04-15_Time-11-14-35.log  
## If there is an issue, please report to github with logFile!  
## Getting UMAP Embedding  
## ColorBy = ChIPMatrix  
## Getting Matrix Values...  
## Getting Matrix Values...  
##   
## Imputing Matrix  
## Using weights on disk  
## Using weights on disk  
## Plotting Embedding  
## 1 2 3 4   
## ArchR logging successful to : ArchRLogs/ArchR-plotEmbedding-10374635d5970-Date-2020-04-15_Time-11-14-35.log  

```{r, eval=FALSE}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 2),p2))
```

```{r, include=FALSE, eval=FALSE}
plotPDF(
    do.call(cowplot::plot_grid, c(list(ncol = 2),p2)), 
    name = "Plot-UMAP-MarkerChIP-W-Imputation.pdf", 
    ArchRProj = projHeme5,
    addDOC = FALSE,
    width = 10, 
    height = 10
)
ArchR:::.convertToPNG(ArchRProj = projHeme2)
system("cp Figures/*.png images/HemeWalkthrough/PNG/")
system("cp Figures/*.pdf images/HemeWalkthrough/PDF/")
```

![](images/HemeWalkthrough/PNG/Plot-UMAP-MarkerChIP-W-Imputation_1.png){width=800 height=800}

```{r, include=FALSE, eval=FALSE}
save.image(params$out, compress = FALSE)
```








